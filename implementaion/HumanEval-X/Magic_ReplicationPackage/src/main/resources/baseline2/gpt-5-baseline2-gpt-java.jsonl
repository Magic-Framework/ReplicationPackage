{"taskId":"Java/0","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(11.0, 2.0, 3.9, 4.0, 5.0, 2.2)), 0.3),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), 0.05),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0)), 0.95),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0)), 0.8),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), 0.1),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1)), 1.0),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1)), 0.5)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n        // Let's think step by step\n        // Input: numbers (List<Double>), threshold (double)\n        // Output: boolean indicating whether any two numbers are closer than threshold\n        // Sequential structure:\n        // 1. If the list is null or has fewer than 2 elements, return false.\n        // 2. Make a copy of the list and sort it to bring close values next to each other.\n        // Loop structure:\n        // 3. Iterate through the sorted list, comparing each element with its previous neighbor.\n        // Branch structure:\n        // 4. If the difference between adjacent elements is less than threshold, return true.\n        // 5. If no such pair is found, return false.\n\n        if (numbers == null || numbers.size() < 2) {\n            return false;\n        }\n\n        List<Double> sorted = new ArrayList<>(numbers);\n        Collections.sort(sorted);\n\n        for (int i = 1; i < sorted.size(); i++) {\n            double diff = Math.abs(sorted.get(i) - sorted.get(i - 1));\n            if (diff < threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n        if (numbers == null || numbers.size() < 2) {\n            return false;\n        }\n\n        List<Double> sorted = new ArrayList<>(numbers);\n        Collections.sort(sorted);\n\n        for (int i = 1; i < sorted.size(); i++) {\n            if (sorted.get(i) - sorted.get(i - 1) < threshold) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","nanoTime":"3735251700"}
{"taskId":"Java/1","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.separateParenGroups(\"(()()) ((())) () ((())()())\").equals(Arrays.asList(\n                        \"(()())\", \"((()))\", \"()\", \"((())()())\"\n                )),\n                s.separateParenGroups(\"() (()) ((())) (((())))\").equals(Arrays.asList(\n                        \"()\", \"(())\", \"((()))\", \"(((())))\"\n                )),\n                s.separateParenGroups(\"(()(())((())))\").equals(Arrays.asList(\n                        \"(()(())((())))\"\n                )),\n                s.separateParenGroups(\"( ) (( )) (( )( ))\").equals(Arrays.asList(\"()\", \"(())\", \"(()())\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separateParenGroups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separateParenGroups(String paren_string) {\n        // Let's think step by step\n        // Input: paren_string, a string possibly containing spaces and parentheses\n        // Output: a List<String> where each element is a balanced group of parentheses\n        // Sequential:\n        // 1) Initialize result list, a StringBuilder for the current group, and a depth counter.\n        // Loop:\n        // 2) Iterate through each character in the input string.\n        // Branch:\n        //    - If it's a space, skip.\n        //    - If it's '(', append to current and increase depth.\n        //    - If it's ')', append to current and decrease depth.\n        //      When depth reaches 0, we've completed a group: add it to the result and reset current.\n        // 3) Return the result list.\n\n        List<String> result = new ArrayList<>();\n        if (paren_string == null || paren_string.isEmpty()) {\n            return result;\n        }\n\n        StringBuilder current = new StringBuilder();\n        int depth = 0;\n\n        for (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n            if (c == ' ') {\n                continue; // ignore spaces\n            } else if (c == '(') {\n                current.append(c);\n                depth++;\n            } else if (c == ')') {\n                current.append(c);\n                depth--;\n                if (depth == 0) {\n                    result.add(current.toString());\n                    current.setLength(0);\n                }\n            } else {\n                // Ignore any non-parenthesis characters (robustness)\n                continue;\n            }\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> separateParenGroups(String parenString) {\n        List<String> result = new ArrayList<>();\n        if (parenString == null || parenString.isEmpty()) {\n            return result;\n        }\n\n        StringBuilder currentGroup = new StringBuilder();\n        int depth = 0;\n\n        for (char c : parenString.toCharArray()) {\n            if (c == ' ') {\n                continue;\n            }\n            currentGroup.append(c);\n            depth += (c == '(') ? 1 : (c == ')') ? -1 : 0;\n\n            if (depth == 0 && currentGroup.length() > 0) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0);\n            }\n        }\n\n        return result;\n    }\n}","nanoTime":"3595820300"}
{"taskId":"Java/2","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n            s.truncateNumber(3.5) == 0.5,\n            Math.abs(s.truncateNumber(1.33) - 0.33) < 1e-6,\n            Math.abs(s.truncateNumber(123.456) - 0.456) < 1e-6\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncateNumber(3.5)\n    0.5\n     */\n    public double truncateNumber(double number) {\n        // Let's think step by step\n        // Input: number, a positive floating point number\n        // Output: decimalPart, the fractional part in [0, 1)\n        // Sequential structure:\n        // 1) Optionally validate the input domain.\n        // 2) Compute the integer part using Math.floor.\n        // 3) Subtract to get the decimal part.\n        // Branch structure:\n        // - If number is not finite or is negative, return NaN (outside problem's domain).\n        // - If decimal is slightly negative due to floating-point error, clamp to 0.\n        // Loop structure:\n        // - While decimal >= 1 (shouldn't happen with correct math), reduce it by 1 to normalize.\n\n        // Write your code here\n        // Branch: handle invalid inputs (outside the stated positive domain)\n        if (!Double.isFinite(number) || number < 0) {\n            return Double.NaN;\n        }\n\n        // Sequential: compute integer part and decimal part\n        double integerPart = Math.floor(number);\n        double decimal = number - integerPart;\n\n        // Loop: normalize in the unlikely event decimal >= 1 due to floating-point artifacts\n        while (decimal >= 1.0) {\n            decimal -= 1.0;\n        }\n\n        // Branch: clamp tiny negative due to rounding\n        if (decimal < 0.0 && decimal > -1e-12) {\n            decimal = 0.0;\n        }\n\n        return decimal;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncateNumber(3.5)\n    0.5\n     */\n    public double truncateNumber(double number) {\n        if (!isValidInput(number)) {\n            return Double.NaN;\n        }\n\n        double decimalPart = number - Math.floor(number);\n        return clampNegativeDecimal(decimalPart);\n    }\n\n    private boolean isValidInput(double number) {\n        return Double.isFinite(number) && number >= 0;\n    }\n\n    private double clampNegativeDecimal(double decimal) {\n        return (decimal < 0.0 && decimal > -1e-12) ? 0.0 : decimal;\n    }\n}","nanoTime":"3582408800"}
{"taskId":"Java/3","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.belowZero(new ArrayList<>(Arrays.asList())),\n                !s.belowZero(new ArrayList<>(Arrays.asList(1, 2, -3, 1, 2, -3))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, 2, -4, 5, 6))),\n                !s.belowZero(new ArrayList<>(Arrays.asList(1, -1, 2, -2, 5, -5, 4, -4))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, -1, 2, -2, 5, -5, 4, -5))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, -2, 2, -2, 5, -5, 4, -4)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> belowZero(Arrays.asList(1, 2, 3))\n    false\n    >>> belowZero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean belowZero(List<Integer> operations) {\n        // Let's think step by step\n        // Input: operations, a list of integers representing deposits(+)/withdrawals(-)\n        // Output: boolean indicating whether the running balance ever drops below zero\n\n        // Sequential structure:\n        // 1. Initialize running balance to 0.\n        // 2. If the operations list is null or empty, return false (no operations means never below zero).\n\n        // Loop structure:\n        // 3. Iterate through each operation amount in the list and update the balance.\n\n        // Branch structure:\n        // 4. After each update, if balance < 0, return true immediately.\n        // 5. If loop completes without balance < 0, return false.\n\n        int balance = 0;\n        if (operations == null || operations.isEmpty()) {\n            return false;\n        }\n        for (Integer op : operations) {\n            if (op != null) {\n                balance += op;\n            }\n            if (balance < 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean belowZero(List<Integer> operations) {\n        if (operations == null || operations.isEmpty()) {\n            return false;\n        }\n\n        int balance = 0;\n        for (Integer op : operations) {\n            if (op != null) {\n                balance += op;\n                if (balance < 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}","nanoTime":"2289584200"}
{"taskId":"Java/4","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0))) - 2.0/3.0) < 1e-6,\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0))) - 1.0) < 1e-6,\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))) - 6.0/5.0) < 1e-6\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> meanAbsoluteDeviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double meanAbsoluteDeviation(List<Double> numbers) {\n        // Let's think step by step\n        // Input: numbers, a list of Double\n        // Output: mad, a double representing the mean absolute deviation\n        // 1) Sequential structure:\n        //    - Validate input\n        //    - Compute mean\n        //    - Compute total absolute deviation\n        //    - Compute average deviation and return\n        // 2) Branch structure:\n        //    - If numbers is null or has no valid (non-null) elements, return 0.0\n        // 3) Loop structure:\n        //    - Loop to compute sum (and count)\n        //    - Loop to compute sum of absolute deviations\n\n        // Branch: handle null or empty input\n        if (numbers == null || numbers.isEmpty()) {\n            return 0.0;\n        }\n\n        // Loop: compute sum and count non-null elements\n        double sum = 0.0;\n        int count = 0;\n        for (Double x : numbers) {\n            if (x == null) { // Branch: skip nulls\n                continue;\n            }\n            sum += x;\n            count++;\n        }\n\n        // Branch: if no valid elements after filtering nulls\n        if (count == 0) {\n            return 0.0;\n        }\n\n        // Sequential: compute mean\n        double mean = sum / count;\n\n        // Loop: compute total absolute deviation\n        double totalAbsDev = 0.0;\n        for (Double x : numbers) {\n            if (x == null) { // Branch: skip nulls\n                continue;\n            }\n            totalAbsDev += Math.abs(x - mean);\n        }\n\n        // Sequential: compute and return MAD\n        double mad = totalAbsDev / count;\n        return mad;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double meanAbsoluteDeviation(List<Double> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return 0.0;\n        }\n\n        double sum = 0.0;\n        double totalAbsDev = 0.0;\n        int count = 0;\n\n        for (Double x : numbers) {\n            if (x != null) {\n                sum += x;\n                totalAbsDev += Math.abs(x);\n                count++;\n            }\n        }\n\n        if (count == 0) {\n            return 0.0;\n        }\n\n        double mean = sum / count;\n        return totalAbsDev / count - mean;\n    }\n}","nanoTime":"3152220600"}
{"taskId":"Java/5","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.intersperse(new ArrayList<>(List.of()), 7).equals(List.of()),\n                s.intersperse(new ArrayList<>(Arrays.asList(5, 6, 3, 2)), 8).equals(Arrays.asList(5, 8, 6, 8, 3, 8, 2)),\n                s.intersperse(new ArrayList<>(Arrays.asList(2, 2, 2)), 2).equals(Arrays.asList(2, 2, 2, 2, 2))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // Let's think step by step\n        // Input: numbers (List<Integer>), delimiter (int)\n        // Output: a new List<Integer> with delimiter inserted between elements\n        // Sequential: initialize result list; handle simple cases; iterate and build output\n        // Branch: if numbers is null or empty, return an empty list; inside loop, if not last element, add delimiter\n        // Loop: go through each index i in numbers from 0 to size - 1\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) {\n            return result;\n        }\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) {\n            return result;\n        }\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.get(i));\n            if (i < numbers.size() - 1) {\n                result.add(delimiter);\n            }\n        }\n        return result;\n    }\n}","nanoTime":"2458831200"}
{"taskId":"Java/6","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.parseNestedParens(\"(()()) ((())) () ((())()())\").equals(Arrays.asList(2, 3, 1, 3)),\n                s.parseNestedParens(\"() (()) ((())) (((())))\").equals(Arrays.asList(1, 2, 3, 4)),\n                s.parseNestedParens(\"(()(())((())))\").equals(Arrays.asList(4))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parseNestedParens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parseNestedParens(String paren_string) {\n        // Let's think step by step\n        // Problem-solving process (using sequential, branch, and loop structures):\n        // Sequential:\n        //   - Initialize the result list.\n        //   - Sanitize the input by trimming and splitting into groups by whitespace.\n        // Loop:\n        //   - For each group, iterate through its characters.\n        // Branch:\n        //   - If character is '(', increment current depth and update max depth if needed.\n        //   - Else if character is ')', decrement current depth.\n        //   - Ignore any other characters (if present).\n        // Finally, append the computed max depth for each group to the result list and return it.\n\n        List<Integer> result = new ArrayList<>();\n\n        if (paren_string == null || paren_string.trim().isEmpty()) {\n            return result;\n        }\n\n        String[] groups = paren_string.trim().split(\"\\\\s+\");\n\n        for (String group : groups) {\n            int currentDepth = 0;\n            int maxDepth = 0;\n\n            for (int i = 0; i < group.length(); i++) {\n                char ch = group.charAt(i);\n                if (ch == '(') { // Branch\n                    currentDepth++;\n                    if (currentDepth > maxDepth) {\n                        maxDepth = currentDepth;\n                    }\n                } else if (ch == ')') { // Branch\n                    currentDepth--;\n                }\n                // Any other characters are ignored.\n            }\n\n            result.add(maxDepth);\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parseNestedParens(String parenString) {\n        List<Integer> result = new ArrayList<>();\n\n        if (parenString == null || parenString.trim().isEmpty()) {\n            return result;\n        }\n\n        String[] groups = parenString.trim().split(\"\\\\s+\");\n\n        for (String group : groups) {\n            result.add(calculateMaxDepth(group));\n        }\n\n        return result;\n    }\n\n    private int calculateMaxDepth(String group) {\n        int currentDepth = 0;\n        int maxDepth = 0;\n\n        for (char ch : group.toCharArray()) {\n            if (ch == '(') {\n                currentDepth++;\n                maxDepth = Math.max(maxDepth, currentDepth);\n            } else if (ch == ')') {\n                currentDepth--;\n            }\n        }\n\n        return maxDepth;\n    }\n}","nanoTime":"3101758500"}
{"taskId":"Java/7","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.filterBySubstring(new ArrayList<>(List.of()), \"john\").equals(List.of()),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), \"xxx\").equals(Arrays.asList(\"xxx\", \"xxxAAA\", \"xxx\")),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), \"xx\").equals(Arrays.asList(\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\")),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"grunt\", \"trumpet\", \"prune\", \"gruesome\")), \"run\").equals(Arrays.asList(\"grunt\", \"prune\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filterBySubstring(List.of(), \"a\")\n    []\n    >>> filterBySubstring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filterBySubstring(List<String> strings, String substring) {\n        // Let's think step by step\n        // Input: strings (List<String>), substring (String)\n        // Output: filtered list containing only strings that include the substring\n        // 1. If strings is null or substring is null, return an empty list. (branch)\n        // 2. Initialize an empty result list to collect matching strings. (sequential)\n        // 3. For each string s in the input list: (loop)\n        // 4.   If s is not null and s contains the substring: (branch)\n        // 5.     Add s to the result list. (sequential)\n        // 6. Return the result list. (sequential)\n        // Write your code here\n        if (strings == null || substring == null) {\n            return new ArrayList<>();\n        }\n        List<String> result = new ArrayList<>();\n        for (String s : strings) {\n            if (s != null && s.contains(substring)) {\n                result.add(s);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> filterBySubstring(List<String> strings, String substring) {\n        if (strings == null || substring == null) {\n            return List.of();\n        }\n        List<String> result = new ArrayList<>();\n        for (String s : strings) {\n            if (s != null && s.contains(substring)) {\n                result.add(s);\n            }\n        }\n        return result;\n    }\n}","nanoTime":"2307882000"}
{"taskId":"Java/8","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumProduct(new ArrayList<>(List.of())).equals(Arrays.asList(0, 1)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(1, 1, 1))).equals(Arrays.asList(3, 1)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(100, 0))).equals(Arrays.asList(100, 0)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(3, 5, 7))).equals(Arrays.asList(3 + 5 + 7, 3 * 5 * 7)),\n                s.sumProduct(new ArrayList<>(List.of(10))).equals(Arrays.asList(10, 10))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sumProduct(List.of())\n    [0, 1]\n    >>> sumProduct(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sumProduct(List<Integer> numbers) {\n        // Let's think step by step\n        // Input: numbers, a list of integers\n        // Output: List<Integer> containing [sum, product]\n        // Sequential structure:\n        // 1. Initialize sum = 0 and product = 1.\n        // Branch structure:\n        // 2. If numbers is null or empty, return [sum, product].\n        // Loop structure:\n        // 3. Otherwise, iterate over each element x in numbers:\n        //    - sum += x\n        //    - product *= x\n        // 4. Return [sum, product].\n        int sum = 0;\n        int product = 1;\n        if (numbers == null || numbers.isEmpty()) {\n            return Arrays.asList(sum, product);\n        }\n        for (int x : numbers) {\n            sum += x;\n            product *= x;\n        }\n        return Arrays.asList(sum, product);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sumProduct(List<Integer> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return List.of(0, 1);\n        }\n        \n        int sum = 0;\n        int product = 1;\n        \n        for (int x : numbers) {\n            sum += x;\n            product *= x;\n        }\n        \n        return List.of(sum, product);\n    }\n}","nanoTime":"1711043800"}
{"taskId":"Java/9","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rollingMax(new ArrayList<>(List.of())).equals(List.of()),\n                s.rollingMax(new ArrayList<>(Arrays.asList(1, 2, 3, 4))).equals(Arrays.asList(1, 2, 3, 4)),\n                s.rollingMax(new ArrayList<>(Arrays.asList(4, 3, 2, 1))).equals(Arrays.asList(4, 4, 4, 4)),\n                s.rollingMax(new ArrayList<>(Arrays.asList(3, 2, 3, 100, 3))).equals(Arrays.asList(3, 3, 3, 100, 100))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rollingMax(List<Integer> numbers) {\n        // Let's think step by step\n        // Input: numbers, a List<Integer>\n        // Output: a List<Integer> containing the running maximum at each position\n        // Sequential structure:\n        // 1) Initialize an output list \"result\".\n        // 2) Initialize a variable \"currentMax\" to the smallest possible integer.\n        // Branch structure:\n        // 3) If \"numbers\" is null or empty, return the empty \"result\".\n        // Loop structure:\n        // 4) For each value \"num\" in \"numbers\":\n        //    - If num > currentMax, update currentMax = num.\n        //    - Append currentMax to \"result\".\n        // 5) Return \"result\".\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) {\n            return result;\n        }\n        int currentMax = Integer.MIN_VALUE;\n        for (int num : numbers) {\n            if (num > currentMax) {\n                currentMax = num;\n            }\n            result.add(currentMax);\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rollingMax(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers == null || numbers.isEmpty()) {\n            return result;\n        }\n        int currentMax = Integer.MIN_VALUE;\n        for (int num : numbers) {\n            currentMax = Math.max(currentMax, num);\n            result.add(currentMax);\n        }\n        return result;\n    }\n}","nanoTime":"3544823700"}
{"taskId":"Java/10","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.makePalindrome(\"\"), \"\"),\n                Objects.equals(s.makePalindrome(\"x\"), \"x\"),\n                Objects.equals(s.makePalindrome(\"xyz\"), \"xyzyx\"),\n                Objects.equals(s.makePalindrome(\"xyx\"), \"xyx\"),\n                Objects.equals(s.makePalindrome(\"jerry\"), \"jerryrrej\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Test if given string is a palindrome\n     */\n    public boolean isPalindrome(String string) {\n        int i = 0;\n        int j = string.length() - 1;\n        while (i < j) {\n            if (string.charAt(i)!= string.charAt(j)) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n    /**\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> makePalindrome(\"\")\n    \"\"\n    >>> makePalindrome(\"cat\")\n    \"catac\"\n    >>> makePalindrome(\"cata\")\n    \"catac\"\n     */\n    public String makePalindrome(String string) {\n        // Let's think step by step\n        // Input: string (a String)\n        // Output: shortest palindrome that begins with 'string'\n        // Sequential structure:\n        // 1) Handle trivial cases (empty or single-character string).\n        // 2) Search for the longest palindromic suffix by scanning start indices.\n        // 3) Once found, append the reverse of the prefix before that suffix.\n        // Branch structure: Use if statements to handle base cases and to check palindromicity.\n        // Loop structure: Use a loop to find the palindromic suffix and another loop to append reversed prefix.\n\n        // 1) Base cases\n        if (string == null || string.length() <= 1) {\n            return string == null ? null : string;\n        }\n\n        // 2) Find the smallest index 'cut' such that string.substring(cut) is a palindrome.\n        // This gives the longest palindromic suffix.\n        int n = string.length();\n        int cut = n; // default (should be updated in loop)\n        for (int i = 0; i < n; i++) { // loop structure\n            if (isPalindrome(string.substring(i))) { // branch structure\n                cut = i;\n                break; // found the longest palindromic suffix\n            }\n        }\n\n        // 3) Append reverse of prefix string[0..cut-1] to the end\n        StringBuilder result = new StringBuilder(string);\n        for (int k = cut - 1; k >= 0; k--) { // loop structure\n            result.append(string.charAt(k));\n        }\n\n        return result.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isPalindrome(String string) {\n        int left = 0;\n        int right = string.length() - 1;\n        while (left < right) {\n            if (string.charAt(left) != string.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public String makePalindrome(String string) {\n        if (string == null || string.length() <= 1) {\n            return string;\n        }\n\n        int n = string.length();\n        int cut = n;\n\n        for (int i = 0; i < n; i++) {\n            if (isPalindrome(string.substring(i))) {\n                cut = i;\n                break;\n            }\n        }\n\n        StringBuilder result = new StringBuilder(string);\n        for (int k = cut - 1; k >= 0; k--) {\n            result.append(string.charAt(k));\n        }\n\n        return result.toString();\n    }\n}","nanoTime":"3653536000"}
{"taskId":"Java/11","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.stringXor(\"111000\", \"101010\"), \"010010\"),\n                Objects.equals(s.stringXor(\"1\", \"1\"), \"0\"),\n                Objects.equals(s.stringXor(\"0101\", \"0000\"), \"0101\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> stringXor(\"010\", \"110\")\n    \"100\"\n     */\n    public String stringXor(String a, String b) {\n        // Let's think step by step\n        // Input: two binary strings a and b\n        // Output: a binary string representing their bitwise XOR\n        // Sequential steps:\n        // 1) Normalize lengths by left-padding the shorter string with '0's.\n        // 2) Initialize a StringBuilder for the result.\n        // Loop + Branch:\n        // 3) For each index i from 0 to length-1:\n        //    - If a[i] == b[i], append '0' to result; else append '1'.\n        // 4) Return the result string.\n\n        // 1) Normalize lengths (sequential + branch + loop)\n        int lenA = a.length();\n        int lenB = b.length();\n        if (lenA < lenB) { // branch\n            int diff = lenB - lenA;\n            StringBuilder pad = new StringBuilder();\n            for (int i = 0; i < diff; i++) { // loop\n                pad.append('0');\n            }\n            a = pad.append(a).toString();\n        } else if (lenB < lenA) { // branch\n            int diff = lenA - lenB;\n            StringBuilder pad = new StringBuilder();\n            for (int i = 0; i < diff; i++) { // loop\n                pad.append('0');\n            }\n            b = pad.append(b).toString();\n        }\n\n        // 2) Initialize result (sequential)\n        int n = a.length(); // now equal to b.length()\n        StringBuilder result = new StringBuilder(n);\n\n        // 3) Compute XOR (loop + branch)\n        for (int i = 0; i < n; i++) {\n            char ca = a.charAt(i);\n            char cb = b.charAt(i);\n            if (ca == cb) { // branch\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        // 4) Return result (sequential)\n        return result.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> stringXor(\"010\", \"110\")\n    \"100\"\n     */\n    public String stringXor(String a, String b) {\n        int maxLength = Math.max(a.length(), b.length());\n        StringBuilder result = new StringBuilder(maxLength);\n\n        a = padLeft(a, maxLength);\n        b = padLeft(b, maxLength);\n\n        for (int i = 0; i < maxLength; i++) {\n            result.append(a.charAt(i) == b.charAt(i) ? '0' : '1');\n        }\n\n        return result.toString();\n    }\n\n    private String padLeft(String str, int length) {\n        StringBuilder padded = new StringBuilder(length);\n        int paddingLength = length - str.length();\n        for (int i = 0; i < paddingLength; i++) {\n            padded.append('0');\n        }\n        padded.append(str);\n        return padded.toString();\n    }\n}","nanoTime":"2944299300"}
{"taskId":"Java/12","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.longest(new ArrayList<>(List.of())).isEmpty(),\n                Objects.equals(s.longest(new ArrayList<>(Arrays.asList(\"x\", \"y\", \"z\"))).get(), \"x\"),\n                Objects.equals(s.longest(new ArrayList<>(Arrays.asList(\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).get(), \"zzzz\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest(List.of())\n    Optional.empty\n    >>> longest(Arrays.asList(\"a\", \"b\", \"c\"))\n    Optional[a]\n    >>> longest(Arrays.asList(\"a\", \"bb\", \"ccc\"))\n    Optional[ccc]\n     */\n    public Optional<String> longest(List<String> strings) {\n        // Let's think step by step\n        // Input: strings, a List<String>\n        // Output: Optional<String> representing the longest string\n        // Sequential structure:\n        // 1. Initialize tracking variables for the current longest string and its length.\n        // Branch structure:\n        // 2. If the input list is null or empty, return Optional.empty().\n        // Loop structure:\n        // 3. Iterate through each string in the list.\n        //    - If the current string is null, skip it.\n        //    - If its length is greater than the current max, update the tracking variables.\n        // Sequential/Branch:\n        // 4. Return Optional.of(longest) if found; otherwise Optional.empty().\n\n        // Write your code here\n        if (strings == null || strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int maxLen = -1;\n        String longestStr = null;\n\n        for (String s : strings) {\n            if (s == null) continue;\n            int len = s.length();\n            if (len > maxLen) {\n                maxLen = len;\n                longestStr = s;\n            }\n        }\n\n        return longestStr == null ? Optional.empty() : Optional.of(longestStr);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<String> longest(List<String> strings) {\n        if (strings == null || strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        return strings.stream()\n                .filter(Objects::nonNull)\n                .reduce((s1, s2) -> s1.length() >= s2.length() ? s1 : s2);\n    }\n}","nanoTime":"2167652100"}
{"taskId":"Java/13","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.greatestCommonDivisor(3, 7) == 1,\n                s.greatestCommonDivisor(10, 15) == 5,\n                s.greatestCommonDivisor(49, 14) == 7,\n                s.greatestCommonDivisor(144, 60) == 12\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatestCommonDivisor(3, 5)\n    1\n    >>> greatestCommonDivisor(25, 15)\n    5\n     */\n    public int greatestCommonDivisor(int a, int b) {\n        // Let's think step by step\n        // Input: a, b as integers\n        // Output: gcd as an integer\n        // Sequential: Normalize inputs to non-negative values\n        // Branch: If either number is zero, return the absolute value of the other\n        // Loop: Apply the Euclidean algorithm repeatedly until the remainder is zero\n        // Steps:\n        // 1. Convert a and b to their absolute values.\n        // 2. If a == 0, return b; if b == 0, return a.\n        // 3. While b != 0:\n        // 4.   Compute r = a % b.\n        // 5.   Set a = b; b = r.\n        // 6. Return a as the gcd.\n\n        long x = Math.abs((long) a);\n        long y = Math.abs((long) b);\n\n        if (x == 0) return (int) y;\n        if (y == 0) return (int) x;\n\n        while (y != 0) {\n            long r = x % y;\n            x = y;\n            y = r;\n        }\n        return (int) x;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a greatest common divisor of two integers a and b\n    >>> greatestCommonDivisor(3, 5)\n    1\n    >>> greatestCommonDivisor(25, 15)\n    5\n    */\n    public int greatestCommonDivisor(int a, int b) {\n        if (a == 0) return Math.abs(b);\n        if (b == 0) return Math.abs(a);\n\n        return gcd(Math.abs(a), Math.abs(b));\n    }\n\n    private int gcd(int x, int y) {\n        while (y != 0) {\n            int r = x % y;\n            x = y;\n            y = r;\n        }\n        return x;\n    }\n}","nanoTime":"3412756900"}
{"taskId":"Java/14","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.allPrefixes(\"\").equals(List.of()),\n                s.allPrefixes(\"asdfgh\").equals(Arrays.asList(\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\")),\n                s.allPrefixes(\"WWW\").equals(Arrays.asList(\"W\", \"WW\", \"WWW\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> allPrefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> allPrefixes(String string) {\n        // Let's think step by step\n        // Input: string, a String\n        // Output: a list of prefixes from shortest to longest\n        // 1. Initialize an empty list \"prefixes\" to store results. (sequential)\n        // 2. If the input string is null or empty, return the empty list. (branch)\n        // 3. For i from 1 to length of string inclusive: (loop)\n        // 4.   Take substring from 0 to i and add to list. (sequential)\n        // 5. Return the list. (sequential)\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.length() == 0) {\n            return prefixes;\n        }\n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        return prefixes;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> allPrefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> allPrefixes(String string) {\n        List<String> prefixes = new ArrayList<>();\n        if (string == null || string.isEmpty()) {\n            return prefixes;\n        }\n        for (int i = 1; i <= string.length(); i++) {\n            prefixes.add(string.substring(0, i));\n        }\n        return prefixes;\n    }\n}","nanoTime":"2029379300"}
{"taskId":"Java/15","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.stringSequence(0).equals(\"0\"),\n                s.stringSequence(3).equals(\"0 1 2 3\"),\n                s.stringSequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> stringSequence(0)\n    \"0\"\n    >>> stringSequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String stringSequence(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: a string with space-delimited integers from 0 to n inclusive\n        // 1. Sequential: Initialize a StringBuilder to build the result.\n        // 2. Branch: If n < 0, return an empty string (no valid sequence from 0 up to a negative number).\n        // 3. Loop: For i from 0 to n inclusive:\n        //    - Append i to the builder.\n        //    - If i is not the last number, append a space.\n        // 4. Sequential: Convert the builder to a string and return it.\n        StringBuilder sb = new StringBuilder();\n        if (n < 0) {\n            return \"\";\n        }\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) sb.append(' ');\n            sb.append(i);\n        }\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> stringSequence(0)\n    \"0\"\n    >>> stringSequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String stringSequence(int n) {\n        if (n < 0) {\n            return \"\";\n        }\n        return IntStream.rangeClosed(0, n)\n                        .mapToObj(String::valueOf)\n                        .collect(Collectors.joining(\" \"));\n    }\n}","nanoTime":"2058297800"}
{"taskId":"Java/16","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countDistinctCharacters(\"\") == 0,\n                s.countDistinctCharacters(\"abcde\") == 5,\n                s.countDistinctCharacters(\"abcde\" + \"cade\" + \"CADE\") == 5,\n                s.countDistinctCharacters(\"aaaaAAAAaaaa\") == 1,\n                s.countDistinctCharacters(\"Jerry jERRY JeRRRY\") == 5\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> countDistinctCharacters(\"xyzXYZ\")\n    3\n    >>> countDistinctCharacters(\"Jerry\")\n    4\n     */\n    public int countDistinctCharacters(String string) {\n        // Let's think step by step\n        // Input: string, a String\n        // Output: count, an integer\n        // 1. Sequential: Normalize input to lower-case and prepare a set to store seen characters.\n        // 2. Branch: If input string is null, return 0.\n        // 3. Loop: Iterate through each character, add it to the set.\n        // 4. Sequential: After the loop, the set size is the number of distinct characters.\n        // 5. Return the size.\n        // Write your code here\n        if (string == null) {\n            return 0;\n        }\n        String s = string.toLowerCase(Locale.ROOT);\n        Set<Character> seen = new HashSet<>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            seen.add(c);\n        }\n        return seen.size();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> countDistinctCharacters(\"xyzXYZ\")\n    3\n    >>> countDistinctCharacters(\"Jerry\")\n    4\n     */\n    public int countDistinctCharacters(String string) {\n        if (string == null) {\n            return 0;\n        }\n        Set<Character> seen = new HashSet<>();\n        for (char c : string.toLowerCase(Locale.ROOT).toCharArray()) {\n            seen.add(c);\n        }\n        return seen.size();\n    }\n}","nanoTime":"2687412900"}
{"taskId":"Java/17","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.parseMusic(\"\").equals(List.of()),\n                s.parseMusic(\"o o o o\").equals(Arrays.asList(4, 4, 4, 4)),\n                s.parseMusic(\".| .| .| .|\").equals(Arrays.asList(1, 1, 1, 1)),\n                s.parseMusic(\"o| o| .| .| o o o o\").equals(Arrays.asList(2, 2, 1, 1, 4, 4, 4, 4)),\n                s.parseMusic(\"o| .| o| .| o o| o o|\").equals(Arrays.asList(2, 1, 2, 1, 4, 2, 4, 2))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    \"o\" - whole note, lasts four beats\n    \"o|\" - half note, lasts two beats\n    \".|\" - quater note, lasts one beat\n\n    >>> parseMusic(\"o o| .| o| o| .| .| .| .| o o\")\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n     */\n    public List<Integer> parseMusic(String string) {\n        // Let's think step by step\n        // Input: string of notes separated by spaces\n        // Output: list of integers representing beats for each note\n        // Sequential structure:\n        // 1) Initialize the result list.\n        // 2) Split the input string into tokens by whitespace.\n        // Loop structure:\n        // 3) Iterate over each token.\n        // Branch structure:\n        // 4) If token is \"o\" -> add 4; else if token is \"o|\" -> add 2; else if token is \".|\" -> add 1; else ignore.\n        // 5) Return the result list.\n\n        List<Integer> result = new ArrayList<>();\n\n        if (string == null || string.trim().isEmpty()) {\n            return result;\n        }\n\n        String[] tokens = string.trim().split(\"\\\\s+\");\n        for (String token : tokens) {\n            if (\"o\".equals(token)) {\n                result.add(4);\n            } else if (\"o|\".equals(token)) {\n                result.add(2);\n            } else if (\".|\".equals(token)) {\n                result.add(1);\n            }\n            // Unknown tokens are ignored as per robust parsing.\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parseMusic(String string) {\n        List<Integer> result = new ArrayList<>();\n        \n        if (string == null || string.trim().isEmpty()) {\n            return result;\n        }\n\n        String[] tokens = string.trim().split(\"\\\\s+\");\n        for (String token : tokens) {\n            switch (token) {\n                case \"o\":\n                    result.add(4);\n                    break;\n                case \"o|\":\n                    result.add(2);\n                    break;\n                case \".|\":\n                    result.add(1);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        return result;\n    }\n}","nanoTime":"2334409600"}
{"taskId":"Java/18","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.howManyTimes(\"\", \"x\") == 0,\n                s.howManyTimes(\"xyxyxyx\", \"x\") == 4,\n                s.howManyTimes(\"cacacacac\", \"cac\") == 4,\n                s.howManyTimes(\"john doe\", \"john\") == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> howManyTimes(\"\", \"a\")\n    0\n    >>> howManyTimes(\"aaa\", \"a\")\n    3\n    >>> howManyTimes(\"aaaa\", \"aa\")\n    3\n     */\n    public int howManyTimes(String string, String substring) {\n        // Let's think step by step\n        // Input: string, substring\n        // Output: integer count\n        // Sequential structure:\n        // 1. Prepare lengths and initial count.\n        // Branch structure:\n        // 2. If string or substring is null, return 0.\n        // 3. If substring length is 0, return 0.\n        // 4. If substring length > string length, return 0.\n        // Loop structure:\n        // 5. Iterate over all possible starting indices and compare; count overlaps.\n        // 6. Return the count.\n        // Write your code here\n        if (string == null || substring == null) {\n            return 0;\n        }\n        int n = string.length();\n        int m = substring.length();\n        if (m == 0) {\n            return 0;\n        }\n        if (m > n) {\n            return 0;\n        }\n        int count = 0;\n        for (int i = 0; i <= n - m; i++) {\n            if (string.startsWith(substring, i)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> howManyTimes(\"\", \"a\")\n    0\n    >>> howManyTimes(\"aaa\", \"a\")\n    3\n    >>> howManyTimes(\"aaaa\", \"aa\")\n    3\n     */\n    public int howManyTimes(String string, String substring) {\n        if (string == null || substring == null || substring.isEmpty() || substring.length() > string.length()) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.startsWith(substring, i)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","nanoTime":"2862188100"}
{"taskId":"Java/19","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sortNumbers(\"\").equals(\"\"),\n                s.sortNumbers(\"three\").equals(\"three\"),\n                s.sortNumbers(\"three five nine\").equals(\"three five nine\"),\n                s.sortNumbers(\"five zero four seven nine eight\").equals(\"zero four five seven eight nine\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sortNumbers(\"three one five\")\n    \"one three five\"\n     */\n    public String sortNumbers(String numbers) {\n        // Let's think step by step\n        // Input: numbers, a space-delimited string of numerals 'zero'..'nine'\n        // Output: a string with the numerals sorted ascending\n        // Problem-solving process using sequential, branch, and loop structures:\n        // Sequential:\n        //   - Prepare mapping from digits to words and a counting array.\n        // Branch:\n        //   - If input is null or empty after trimming, return empty string.\n        //   - Use a switch-case to map each word to its numeric value.\n        // Loop:\n        //   - Loop over tokens to count occurrences.\n        //   - Loop over digits 0..9 and for each, loop counts times to build the result.\n        // Steps:\n        // 1. Handle null/empty input.\n        // 2. Initialize counts array and split input into tokens.\n        // 3. For each token, map to a digit and increment its count.\n        // 4. Build the output by iterating digits from 0 to 9 and appending words accordingly.\n        // 5. Return the built string.\n\n        // Write your code here\n        if (numbers == null) {\n            return \"\";\n        }\n        String trimmed = numbers.trim();\n        if (trimmed.isEmpty()) {\n            return \"\";\n        }\n\n        String[] digitWords = new String[] {\n            \"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"\n        };\n        int[] counts = new int[10];\n\n        String[] tokens = trimmed.split(\"\\\\s+\");\n        for (String tok : tokens) {\n            if (tok == null || tok.isEmpty()) {\n                continue;\n            }\n            String w = tok.toLowerCase(Locale.ROOT);\n            int val;\n            switch (w) {\n                case \"zero\": val = 0; break;\n                case \"one\": val = 1; break;\n                case \"two\": val = 2; break;\n                case \"three\": val = 3; break;\n                case \"four\": val = 4; break;\n                case \"five\": val = 5; break;\n                case \"six\": val = 6; break;\n                case \"seven\": val = 7; break;\n                case \"eight\": val = 8; break;\n                case \"nine\": val = 9; break;\n                default:\n                    // Ignore invalid tokens (according to spec, all tokens are valid)\n                    continue;\n            }\n            counts[val]++;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            for (int c = 0; c < counts[i]; c++) {\n                if (sb.length() > 0) sb.append(' ');\n                sb.append(digitWords[i]);\n            }\n        }\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String sortNumbers(String numbers) {\n        if (numbers == null || numbers.trim().isEmpty()) {\n            return \"\";\n        }\n\n        String[] digitWords = {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n        };\n        int[] counts = new int[10];\n\n        for (String token : numbers.trim().split(\"\\\\s+\")) {\n            int value = getValue(token.toLowerCase(Locale.ROOT));\n            if (value >= 0) {\n                counts[value]++;\n            }\n        }\n\n        return buildSortedString(digitWords, counts);\n    }\n\n    private int getValue(String word) {\n        switch (word) {\n            case \"zero\": return 0;\n            case \"one\": return 1;\n            case \"two\": return 2;\n            case \"three\": return 3;\n            case \"four\": return 4;\n            case \"five\": return 5;\n            case \"six\": return 6;\n            case \"seven\": return 7;\n            case \"eight\": return 8;\n            case \"nine\": return 9;\n            default: return -1;\n        }\n    }\n\n    private String buildSortedString(String[] digitWords, int[] counts) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < counts.length; i++) {\n            for (int j = 0; j < counts[i]; j++) {\n                if (sb.length() > 0) {\n                    sb.append(' ');\n                }\n                sb.append(digitWords[i]);\n            }\n        }\n        return sb.toString();\n    }\n}","nanoTime":"8195591400"}
{"taskId":"Java/20","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.9, 4.0, 5.0, 2.2))).equals(Arrays.asList(3.9, 4.0)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0))).equals(Arrays.asList(5.0, 5.9)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))).equals(Arrays.asList(2.0, 2.2)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))).equals(Arrays.asList(2.0, 2.0)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1))).equals(Arrays.asList(2.2, 3.1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n    [2.0, 2.2]\n    >>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n    [2.0, 2.0]\n     */\n    public List<Double> findClosestElements(List<Double> numbers) {\n        // Let's think step by step\n        // Input: numbers, a list of Double with length >= 2\n        // Output: a list of two Doubles [smaller, larger] that are closest to each other\n\n        // Sequential structure:\n        // 1) Copy the input list to avoid modifying it.\n        // 2) Sort the copied list in ascending order.\n        List<Double> sorted = new ArrayList<>(numbers);\n        Collections.sort(sorted);\n\n        // Loop + Branch structures:\n        // 3) Initialize variables to track the minimum difference and best pair.\n        // 4) Loop through adjacent pairs in the sorted list.\n        // 5) For each pair, compute the difference and, if it's smaller than the current minimum (branch),\n        //    update the best pair.\n        double minDiff = Double.POSITIVE_INFINITY;\n        double bestLower = sorted.get(0);\n        double bestUpper = sorted.get(1);\n\n        for (int i = 0; i < sorted.size() - 1; i++) { // loop\n            double x = sorted.get(i);\n            double y = sorted.get(i + 1);\n            double diff = y - x; // y >= x due to sorting\n            if (diff < minDiff) { // branch\n                minDiff = diff;\n                bestLower = x;\n                bestUpper = y;\n            }\n        }\n\n        // 6) Return the best pair as [smaller, larger].\n        return Arrays.asList(bestLower, bestUpper);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> findClosestElements(List<Double> numbers) {\n        List<Double> sorted = new ArrayList<>(numbers);\n        Collections.sort(sorted);\n\n        double minDiff = Double.POSITIVE_INFINITY;\n        double bestLower = sorted.get(0);\n        double bestUpper = sorted.get(1);\n\n        for (int i = 0; i < sorted.size() - 1; i++) {\n            double x = sorted.get(i);\n            double y = sorted.get(i + 1);\n            double diff = y - x;\n            if (diff < minDiff) {\n                minDiff = diff;\n                bestLower = x;\n                bestUpper = y;\n            }\n        }\n\n        return List.of(bestLower, bestUpper);\n    }\n}","nanoTime":"3115447800"}
{"taskId":"Java/21","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rescaleToUnit(new ArrayList<>(Arrays.asList(2.0, 49.9))).equals(Arrays.asList(0.0, 1.0)),\n                s.rescaleToUnit(new ArrayList<>(Arrays.asList(100.0, 49.9))).equals(Arrays.asList(1.0, 0.0)),\n                s.rescaleToUnit(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))).equals(Arrays.asList(0.0, 0.25, 0.5, 0.75, 1.0)),\n                s.rescaleToUnit(new ArrayList<>(Arrays.asList(2.0, 1.0, 5.0, 3.0, 4.0))).equals(Arrays.asList(0.25, 0.0, 1.0, 0.5, 0.75)),\n                s.rescaleToUnit(new ArrayList<>(Arrays.asList(12.0, 11.0, 15.0, 13.0, 14.0))).equals(Arrays.asList(0.25, 0.0, 1.0, 0.5, 0.75))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescaleToUnit(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n     */\n    public List<Double> rescaleToUnit(List<Double> numbers) {\n        // Let's think step by step\n        // Input: numbers, a list of Double with at least two elements\n        // Output: rescaled, a list of Double where min maps to 0.0 and max maps to 1.0\n        // Sequential: define variables, compute range, and build result\n        // Branch: handle null/empty input and the case where all values are equal\n        // Loop: iterate to find min/max and to compute each rescaled value\n\n        // 1) Branch: handle null or empty input\n        if (numbers == null || numbers.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // 2) Sequential: initialize min and max\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n\n        // 3) Loop: determine min and max values\n        for (Double v : numbers) {\n            if (v < min) min = v;\n            if (v > max) max = v;\n        }\n\n        // 4) Sequential: compute the range\n        double range = max - min;\n\n        // 5) Branch + Loop: if all values are the same, return all zeros\n        List<Double> result = new ArrayList<>(numbers.size());\n        if (range == 0.0) {\n            for (int i = 0; i < numbers.size(); i++) {\n                result.add(0.0);\n            }\n            return result;\n        }\n\n        // 6) Loop: compute rescaled values\n        for (Double v : numbers) {\n            result.add((v - min) / range);\n        }\n\n        // 7) Sequential: return the result\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> rescaleToUnit(List<Double> numbers) {\n        if (numbers == null || numbers.size() < 2) {\n            return new ArrayList<>();\n        }\n\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n\n        for (Double v : numbers) {\n            if (v < min) min = v;\n            if (v > max) max = v;\n        }\n\n        double range = max - min;\n        List<Double> result = new ArrayList<>(numbers.size());\n\n        if (range == 0.0) {\n            for (int i = 0; i < numbers.size(); i++) {\n                result.add(0.0);\n            }\n        } else {\n            for (Double v : numbers) {\n                result.add((v - min) / range);\n            }\n        }\n\n        return result;\n    }\n}","nanoTime":"2856515100"}
{"taskId":"Java/22","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.filterIntergers(new ArrayList<>(List.of())).equals(List.of()),\n                s.filterIntergers(new ArrayList<>(Arrays.asList(4, Map.of(), List.of(), 23.2, 9, \"adasd\"))).equals(Arrays.asList(4, 9)),\n                s.filterIntergers(new ArrayList<>(Arrays.asList(3, 'c', 3, 3, 'a', 'b'))).equals(Arrays.asList(3, 3, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filter_integers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filter_integers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filterIntergers(List<Object> values) {\n        // Let's think step by step\n        // Input: values, a list of Objects\n        // Output: a list containing only Integer elements from values\n        // Sequential structure:\n        // 1. Initialize an empty result list to collect integers.\n        // 2. If the input list is null, return the empty result immediately.\n        // Loop structure:\n        // 3. Iterate over each element in the input list.\n        // Branch structure:\n        // 4. For each element, if it is an instance of Integer, add it to the result list.\n        // 5. After processing all elements, return the result list.\n\n        List<Integer> result = new ArrayList<>();\n        if (values == null) {\n            return result;\n        }\n        for (Object v : values) {\n            if (v instanceof Integer) {\n                result.add((Integer) v);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter given list of any values only for integers\n    >>> filterIntegers(Arrays.asList('a', 3.14, 5))\n    [5]\n    >>> filterIntegers(Arrays.asList(1, 2, 3, \"abc\", Map.of(), List.of()))\n    [1, 2, 3]\n     */\n    public List<Integer> filterIntegers(List<Object> values) {\n        List<Integer> result = new ArrayList<>();\n        if (values != null) {\n            for (Object v : values) {\n                if (v instanceof Integer) {\n                    result.add((Integer) v);\n                }\n            }\n        }\n        return result;\n    }\n}","nanoTime":"2971040300"}
{"taskId":"Java/23","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.strlen(\"\") == 0,\n                s.strlen(\"x\") == 1,\n                s.strlen(\"asdasnakj\") == 9\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        // Let's think step by step\n        // Input: string (String)\n        // Output: length (int)\n        // Sequential structure:\n        // 1. Initialize a counter to 0.\n        // 2. Prepare to traverse the characters of the string.\n        // Branch structure:\n        // - If string is null, return 0 (treat as empty).\n        // - Otherwise, proceed to count characters.\n        // Loop structure:\n        // - For each character in the string, increment the counter by 1.\n        // - After the loop finishes, return the counter.\n        if (string == null) {\n            return 0;\n        }\n        int count = 0;\n        for (char c : string.toCharArray()) {\n            count++;\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return length of given string\n    >>> strlen(\"\")\n    0\n    >>> strlen(\"abc\")\n    3\n     */\n    public int strlen(String string) {\n        return (string == null) ? 0 : string.length();\n    }\n}","nanoTime":"1441815000"}
{"taskId":"Java/24","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.largestDivisor(3) == 1,\n                s.largestDivisor(7) == 1,\n                s.largestDivisor(10) == 5,\n                s.largestDivisor(100) == 50,\n                s.largestDivisor(49) == 7\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largestDivisor(15)\n    5\n     */\n    public int largestDivisor(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: the largest integer d such that d < n and n % d == 0\n        // Sequential:\n        // 1) Initialize and handle trivial cases.\n        // Branch:\n        // 2) If n <= 1, there is no proper positive divisor; return 0.\n        // 3) If n is even, the largest proper divisor is n / 2.\n        // Loop:\n        // 4) Otherwise, search for the smallest divisor d in [3, sqrt(n)] stepping by 2.\n        // 5) If found, the largest proper divisor is n / d (since d is the smallest > 1).\n        // 6) If no divisor found, n is prime; return 1.\n\n        // Write your code here\n        if (n <= 1) {\n            return 0;\n        }\n        if (n % 2 == 0) {\n            return n / 2;\n        }\n        for (int d = 3; d * d <= n; d += 2) {\n            if (n % d == 0) {\n                return n / d;\n            }\n        }\n        return 1;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largestDivisor(15)\n    5\n     */\n    public int largestDivisor(int n) {\n        if (n <= 1) {\n            return 0;\n        }\n        if (n % 2 == 0) {\n            return n / 2;\n        }\n        for (int d = 3; d * d <= n; d += 2) {\n            if (n % d == 0) {\n                return n / d;\n            }\n        }\n        return 1;\n    }\n}","nanoTime":"1873087700"}
{"taskId":"Java/25","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.factorize(2).equals(List.of(2)),\n                s.factorize(4).equals(Arrays.asList(2, 2)),\n                s.factorize(8).equals(Arrays.asList(2, 2, 2)),\n                s.factorize(3 * 19).equals(Arrays.asList(3, 19)),\n                s.factorize(3 * 19 * 3 * 19).equals(Arrays.asList(3, 3, 19, 19)),\n                s.factorize(3 * 19 * 3 * 19 * 3 * 19).equals(Arrays.asList(3, 3, 3, 19, 19, 19)),\n                s.factorize(3 * 19 * 19 * 19).equals(Arrays.asList(3, 19, 19, 19)),\n                s.factorize(3 * 2 * 3).equals(Arrays.asList(2, 3, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n     */\n    public List<Integer> factorize(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: List<Integer> of prime factors in non-decreasing order\n        // Sequential structure:\n        // 1. Initialize an empty list \"factors\".\n        // 2. If n < 2, return empty list (no prime factors).\n        // 3. Repeatedly divide out factor 2 and append it to the list.\n        // 4. For odd candidate factors from 3 up to sqrt(n), repeatedly divide them out and append.\n        // 5. If after the loop n > 1, it is a prime factor; append it.\n        // 6. Return the list \"factors\".\n        // Branch structure:\n        // - If n < 2, return immediately.\n        // - If n % 2 == 0, handle factor 2.\n        // - If at the end n > 1, append remaining n.\n        // Loop structure:\n        // - While loops to extract repeated factors.\n        // - For loop to try odd candidate factors.\n        List<Integer> factors = new ArrayList<>();\n        if (n < 2) {\n            return factors;\n        }\n        // Extract factor 2\n        while (n % 2 == 0) {\n            factors.add(2);\n            n /= 2;\n        }\n        // Extract odd factors up to sqrt(n)\n        for (int f = 3; f <= n / f; f += 2) {\n            while (n % f == 0) {\n                factors.add(f);\n                n /= f;\n            }\n        }\n        // If remaining n is > 1, it is a prime factor\n        if (n > 1) {\n            factors.add(n);\n        }\n        return factors;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> factorize(int n) {\n        List<Integer> factors = new ArrayList<>();\n        if (n < 2) {\n            return factors;\n        }\n        extractFactors(n, 2, factors);\n        for (int f = 3; f * f <= n; f += 2) {\n            extractFactors(n, f, factors);\n        }\n        if (n > 1) {\n            factors.add(n);\n        }\n        return factors;\n    }\n\n    private void extractFactors(int n, int factor, List<Integer> factors) {\n        while (n % factor == 0) {\n            factors.add(factor);\n            n /= factor;\n        }\n    }\n}","nanoTime":"3398814900"}
{"taskId":"Java/26","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.removeDuplicates(new ArrayList<>(List.of())).equals(List.of()),\n                s.removeDuplicates(new ArrayList<>(Arrays.asList(1, 2, 3, 4))).equals(Arrays.asList(1, 2, 3, 4)),\n                s.removeDuplicates(new ArrayList<>(Arrays.asList(1, 2, 3, 2, 4, 3, 5))).equals(Arrays.asList(1, 4, 5))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> removeDuplicates(Array.asList(1, 2, 3, 2, 4))\n    [1, 3, 4]\n     */\n    public List<Integer> removeDuplicates(List<Integer> numbers) {\n        // Let's think step by step\n        // Input: numbers, a list of integers\n        // Output: a list containing only the elements that appear exactly once, preserving input order\n        // 1. Sequential: Initialize a frequency map to count occurrences of each number.\n        // 2. Loop: Iterate through the list and update the frequency map.\n        // 3. Sequential: Initialize a result list to store unique elements.\n        // 4. Loop: Iterate through the list again.\n        // 5. Branch: If the count of the current number is exactly 1, add it to the result list.\n        // 6. Sequential: Return the result list.\n        // Write your code here\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (Integer num : numbers) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (Integer num : numbers) {\n            if (freq.get(num) == 1) {\n                result.add(num);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> removeDuplicates(Arrays.asList(1, 2, 3, 2, 4))\n    [1, 3, 4]\n     */\n    public List<Integer> removeDuplicates(List<Integer> numbers) {\n        Map<Integer, Long> frequencyMap = numbers.stream()\n            .collect(Collectors.groupingBy(num -> num, Collectors.counting()));\n        \n        return numbers.stream()\n            .filter(num -> frequencyMap.get(num) == 1)\n            .collect(Collectors.toList());\n    }\n}","nanoTime":"2172183300"}
{"taskId":"Java/27","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.flipCase(\"\"), \"\"),\n                Objects.equals(s.flipCase(\"Hello!\"), \"hELLO!\"),\n                Objects.equals(s.flipCase(\"These violent delights have violent ends\"), \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flipCase(\"Hello\")\n    \"hELLO\"\n     */\n    public String flipCase(String string) {\n        // Let's think step by step\n        // Input: string, a String\n        // Output: flipped, a String where lowercase letters become uppercase and uppercase become lowercase\n        // Plan using three programming structures:\n        // Sequential: Initialize a StringBuilder to accumulate result.\n        // Loop: Iterate over each character in the input string.\n        // Branch: For each character, if it's lowercase, convert to uppercase; else if it's uppercase, convert to lowercase; else leave unchanged.\n        // Finally, return the accumulated string.\n\n        // Sequential: handle null and initialize builder\n        if (string == null) {\n            return null;\n        }\n        StringBuilder sb = new StringBuilder(string.length());\n\n        // Loop: traverse characters\n        for (int i = 0; i < string.length(); i++) {\n            char ch = string.charAt(i);\n            // Branch: decide how to transform the character\n            if (Character.isLowerCase(ch)) {\n                sb.append(Character.toUpperCase(ch));\n            } else if (Character.isUpperCase(ch)) {\n                sb.append(Character.toLowerCase(ch));\n            } else {\n                sb.append(ch);\n            }\n        }\n\n        // Sequential: return result\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flipCase(\"Hello\")\n    \"hELLO\"\n     */\n    public String flipCase(String string) {\n        if (string == null) {\n            return null;\n        }\n        \n        StringBuilder sb = new StringBuilder(string.length());\n        \n        for (char ch : string.toCharArray()) {\n            sb.append(Character.isLowerCase(ch) ? Character.toUpperCase(ch) : \n                       Character.isUpperCase(ch) ? Character.toLowerCase(ch) : ch);\n        }\n        \n        return sb.toString();\n    }\n}","nanoTime":"1645559100"}
{"taskId":"Java/28","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.concatenate(new ArrayList<>(List.of())), \"\"),\n                Objects.equals(s.concatenate(new ArrayList<>(Arrays.asList(\"x\", \"y\", \"z\"))), \"xyz\"),\n                Objects.equals(s.concatenate(new ArrayList<>(Arrays.asList(\"x\", \"y\", \"z\", \"w\", \"k\"))), \"xyzwk\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(Arrays.asList(\"a\", \"b\", \"c\"))\n    \"abc\"\n     */\n    public String concatenate(List<String> strings) {\n        // Let's think step by step\n        // Input: strings, a list of strings (may be null or contain null elements)\n        // Output: a single concatenated string\n        // Sequential structure:\n        // 1. Initialize a StringBuilder to accumulate characters.\n        // Branch structure:\n        // 2. If the list is null or empty, return an empty string immediately.\n        // Loop structure:\n        // 3. For each element in the list:\n        //    - If the element is not null, append it to the StringBuilder.\n        // 4. Convert the StringBuilder to a String and return it.\n\n        StringBuilder sb = new StringBuilder();\n\n        if (strings == null || strings.isEmpty()) {\n            return \"\";\n        }\n\n        for (String s : strings) {\n            if (s != null) {\n                sb.append(s);\n            }\n        }\n\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Concatenate list of strings into a single string\n    >>> concatenate(List.of())\n    \"\"\n    >>> concatenate(List.of(\"a\", \"b\", \"c\"))\n    \"abc\"\n    */\n    public String concatenate(List<String> strings) {\n        if (strings == null || strings.isEmpty()) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String s : strings) {\n            if (s != null) {\n                sb.append(s);\n            }\n        }\n\n        return sb.toString();\n    }\n}","nanoTime":"2973651400"}
{"taskId":"Java/29","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.filterByPrefix(new ArrayList<>(List.of()), \"john\").equals(List.of()),\n                s.filterByPrefix(new ArrayList<>(Arrays.asList(\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), \"xxx\").equals(Arrays.asList(\"xxx\", \"xxxAAA\", \"xxx\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filterByPrefix(List.of(), \"a\")\n    []\n    >>> filterByPrefix(Arrays.asList(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n     */\n    public List<String> filterByPrefix(List<String> strings, String prefix) {\n        // Let's think step by step\n        // Input: strings: List<String>, prefix: String\n        // Output: List<String> containing only the elements that start with prefix\n        // Sequential structure:\n        // 1) Initialize an empty result list.\n        // 2) Validate inputs.\n        // Loop structure:\n        // 3) Iterate over each string in the input list.\n        // Branch structure:\n        // 4) If the current string is non-null and starts with the prefix, add it to the result.\n        // 5) Return the result list.\n\n        List<String> result = new ArrayList<>();\n        if (strings == null || prefix == null) {\n            return result;\n        }\n        for (String s : strings) {\n            if (s != null && s.startsWith(prefix)) {\n                result.add(s);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filterByPrefix(List.of(), \"a\")\n    []\n    >>> filterByPrefix(List.of(\"abc\", \"bcd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"array\"]\n     */\n    public List<String> filterByPrefix(List<String> strings, String prefix) {\n        List<String> result = new ArrayList<>();\n        if (strings == null || prefix == null) {\n            return result;\n        }\n        for (String s : strings) {\n            if (s != null && s.startsWith(prefix)) {\n                result.add(s);\n            }\n        }\n        return result;\n    }\n}","nanoTime":"2358026400"}
{"taskId":"Java/30","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getPositive(new ArrayList<>(Arrays.asList(-1, -2, 4, 5, 6))).equals(Arrays.asList(4, 5, 6)),\n                s.getPositive(new ArrayList<>(Arrays.asList(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10))).equals(Arrays.asList(5, 3, 2, 3, 3, 9, 123, 1)),\n                s.getPositive(new ArrayList<>(Arrays.asList(-1, -2))).equals(List.of()),\n                s.getPositive(List.of()).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> getPositive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> getPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> getPositive(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a List<Integer>\n        // Output: a List<Integer> containing only the positive numbers (> 0), preserving order\n        // Sequential structure:\n        // 1) Initialize an empty result list.\n        // Branch structure:\n        // 2) If the input list is null, return the empty result.\n        // Loop structure:\n        // 3) Iterate over each element in the list.\n        // 4) Branch inside the loop: if the element is not null and greater than 0, add it to result.\n        // 5) Return the result list.\n\n        List<Integer> result = new ArrayList<>();\n        if (l == null) {\n            return result;\n        }\n        for (Integer x : l) {\n            if (x != null && x > 0) {\n                result.add(x);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return only positive numbers in the list.\n    >>> getPositive(Arrays.asList(-1, 2, -4, 5, 6))\n    [2, 5, 6]\n    >>> getPositive(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    [5, 3, 2, 3, 9, 123, 1]\n     */\n    public List<Integer> getPositive(List<Integer> l) {\n        List<Integer> result = new ArrayList<>();\n        if (l != null) {\n            for (Integer x : l) {\n                if (x != null && x > 0) {\n                    result.add(x);\n                }\n            }\n        }\n        return result;\n    }\n}","nanoTime":"3410316500"}
{"taskId":"Java/31","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isPrime(6),\n                s.isPrime(101),\n                s.isPrime(11),\n                s.isPrime(13441),\n                s.isPrime(61),\n                !s.isPrime(4),\n                !s.isPrime(1),\n                s.isPrime(5),\n                s.isPrime(11),\n                s.isPrime(17),\n                !s.isPrime(5 * 17),\n                !s.isPrime(11 * 7),\n                !s.isPrime(13441 * 19)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> isPrime(6)\n    false\n    >>> isPrime(101)\n    true\n    >>> isPrime(11)\n    true\n    >>> isPrime(13441)\n    true\n    >>> isPrime(61)\n    true\n    >>> isPrime(4)\n    false\n    >>> isPrime(1)\n    false\n     */\n    public boolean isPrime(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: boolean indicating whether n is prime\n        // Sequential: set up and handle base cases\n        // Branch:\n        // 1. If n <= 1, it's not prime -> return false\n        // 2. If n == 2, it's prime -> return true\n        // 3. If n is even and greater than 2, it's not prime -> return false\n        // Loop:\n        // 4. Initialize i = 3\n        // 5. While i * i <= n (checked as i <= n / i to avoid overflow):\n        //    - Branch: If n % i == 0, return false\n        //    - Increment i by 2 to test only odd divisors\n        // 6. If no divisors found, return true\n\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n\n        int i = 3;\n        while (i <= n / i) {\n            if (n % i == 0) return false;\n            i += 2;\n        }\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n}","nanoTime":"1443343700"}
{"taskId":"Java/32","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Random rand = new Random(42);\n        for (int i = 0; i < 100; i++) {\n            int ncoeff = 2 * (rand.nextInt(3) + 1);\n            List<Double> coeffs = new ArrayList<>();\n            for (int j = 0; j < ncoeff; j++) {\n                int coeff = rand.nextInt(20) - 10;\n                if (coeff == 0) {\n                    coeff = 1;\n                }\n                coeffs.add((double) coeff);\n            }\n            double solution = s.findZero(coeffs);\n            if (Math.abs(s.poly(coeffs, solution)) > 1e-4) {\n                throw new AssertionError();\n            }\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    findZero find x such that poly(x) = 0.\n    findZero returns only only zero point, even if there are many.\n    Moreover, findZero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> findZero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> findZero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double findZero(List<Double> xs) {\n        // Let's think step by step\n        // Input: xs, a List<Double> of polynomial coefficients with even size and non-zero leading coefficient\n        // Output: a double value r such that poly(xs, r) == 0 (approximately)\n        // Sequential structure:\n        // 1) Validate that xs is non-empty, has even length, and its last coefficient is non-zero.\n        // 2) Initialize a symmetric search interval [-range, range] with range = 1.0 and evaluate f(a), f(b).\n        // Loop structure:\n        // 3) While f(a) and f(b) have the same sign, expand the interval by doubling its size.\n        // Branch structure:\n        // 4) If an endpoint evaluates to zero, return it. Otherwise, apply the bisection method:\n        //    - Compute midpoint, evaluate function, choose the half-interval that keeps a sign change.\n        // 5) Stop when the function value is small or the interval is sufficiently tight, and return the midpoint.\n\n        if (xs == null || xs.isEmpty()) {\n            throw new IllegalArgumentException(\"xs must be non-empty\");\n        }\n        if ((xs.size() & 1) != 0) {\n            throw new IllegalArgumentException(\"xs must have an even number of coefficients (odd degree)\");\n        }\n        double leading = xs.get(xs.size() - 1);\n        if (leading == 0.0) {\n            throw new IllegalArgumentException(\"Leading coefficient must be non-zero\");\n        }\n\n        // Step 2: Initialize bracket\n        double a = -1.0;\n        double b = 1.0;\n        double fa = poly(xs, a);\n        double fb = poly(xs, b);\n\n        if (fa == 0.0) return a;\n        if (fb == 0.0) return b;\n\n        // Step 3: Expand interval until sign change\n        int expandIters = 0;\n        while (fa * fb > 0.0 && expandIters < 60) { // 2^60 is huge; should bracket for odd-degree polynomials\n            a *= 2.0;\n            b *= 2.0;\n            fa = poly(xs, a);\n            fb = poly(xs, b);\n            expandIters++;\n        }\n\n        if (fa == 0.0) return a;\n        if (fb == 0.0) return b;\n\n        if (fa * fb > 0.0) {\n            // Fallback attempt (shouldn't occur for valid inputs per spec)\n            return Double.NaN;\n        }\n\n        // Step 4: Bisection method\n        double left = a, right = b;\n        double fLeft = fa, fRight = fb;\n        double tol = 1e-12;\n\n        for (int iter = 0; iter < 200; iter++) {\n            double mid = 0.5 * (left + right);\n            double fMid = poly(xs, mid);\n\n            if (Math.abs(fMid) <= tol) {\n                return mid;\n            }\n\n            // Choose the subinterval that retains a sign change\n            if (fLeft * fMid <= 0.0) {\n                right = mid;\n                fRight = fMid;\n            } else {\n                left = mid;\n                fLeft = fMid;\n            }\n\n            if (Math.abs(right - left) <= tol * Math.max(1.0, Math.max(Math.abs(left), Math.abs(right)))) {\n                return 0.5 * (left + right);\n            }\n        }\n\n        return 0.5 * (left + right);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double poly(List<Double> coefficients, double x) {\n        double result = 0;\n        double power = 1;\n        for (double coefficient : coefficients) {\n            result += coefficient * power;\n            power *= x;\n        }\n        return result;\n    }\n\n    public double findZero(List<Double> coefficients) {\n        validateInput(coefficients);\n\n        double a = -1.0;\n        double b = 1.0;\n        double fa = poly(coefficients, a);\n        double fb = poly(coefficients, b);\n\n        if (fa == 0.0) return a;\n        if (fb == 0.0) return b;\n\n        expandInterval(coefficients, fa, fb);\n\n        return bisectionMethod(coefficients, a, b);\n    }\n\n    private void validateInput(List<Double> coefficients) {\n        if (coefficients == null || coefficients.isEmpty()) {\n            throw new IllegalArgumentException(\"Coefficients must be non-empty\");\n        }\n        if ((coefficients.size() & 1) != 0) {\n            throw new IllegalArgumentException(\"Coefficients must have an even number of coefficients (odd degree)\");\n        }\n        if (coefficients.get(coefficients.size() - 1) == 0.0) {\n            throw new IllegalArgumentException(\"Leading coefficient must be non-zero\");\n        }\n    }\n\n    private void expandInterval(List<Double> coefficients, double fa, double fb) {\n        int expandIters = 0;\n        while (fa * fb > 0.0 && expandIters < 60) {\n            fa = poly(coefficients, (fa *= 2.0));\n            fb = poly(coefficients, (fb *= 2.0));\n            expandIters++;\n        }\n    }\n\n    private double bisectionMethod(List<Double> coefficients, double a, double b) {\n        double left = a, right = b;\n        double fLeft = poly(coefficients, left);\n        double fRight = poly(coefficients, right);\n        double tol = 1e-12;\n\n        for (int iter = 0; iter < 200; iter++) {\n            double mid = 0.5 * (left + right);\n            double fMid = poly(coefficients, mid);\n\n            if (Math.abs(fMid) <= tol) {\n                return mid;\n            }\n\n            if (fLeft * fMid <= 0.0) {\n                right = mid;\n                fRight = fMid;\n            } else {\n                left = mid;\n                fLeft = fMid;\n            }\n\n            if (Math.abs(right - left) <= tol * Math.max(1.0, Math.max(Math.abs(left), Math.abs(right)))) {\n                return 0.5 * (left + right);\n            }\n        }\n\n        return 0.5 * (left + right);\n    }\n}","nanoTime":"6495841800"}
{"taskId":"Java/33","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sortThird(new ArrayList<>(Arrays.asList(5, 6, 3, 4, 8, 9, 2))).equals(Arrays.asList(2, 6, 3, 4, 8, 9, 5)),\n                s.sortThird(new ArrayList<>(Arrays.asList(5, 8, 3, 4, 6, 9, 2))).equals(Arrays.asList(2, 8, 3, 4, 6, 9, 5)),\n                s.sortThird(new ArrayList<>(Arrays.asList(5, 6, 9, 4, 8, 3, 2))).equals(Arrays.asList(2, 6, 9, 4, 8, 3, 5)),\n                s.sortThird(new ArrayList<>(Arrays.asList(5, 6, 3, 4, 8, 9, 2, 1))).equals(Arrays.asList(2, 6, 3, 4, 8, 9, 5, 1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sortThird(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sortThird(Arrays.asList(5, 6, 3, 4, 8, 9, 2))\n    [2, 6, 3, 4, 8, 9, 5]\n     */\n    public List<Integer> sortThird(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a List<Integer>\n        // Output: a new List<Integer> where elements at indices divisible by 3 are sorted ascending,\n        //         while elements at other indices remain in their original positions.\n        //\n        // Sequential structure:\n        // 1. Handle trivial cases (null or size <= 1).\n        // 2. Create a mutable copy of the input list to build the result.\n        // 3. Collect indices i where i % 3 == 0 and their corresponding values from l.\n        // 4. Sort the collected values.\n        // 5. Place the sorted values back into the copied list at the collected indices.\n        //\n        // Branch structure:\n        // - If l is null, return null.\n        // - If l has length 0 or 1, simply return a copy (already \"sorted\").\n        //\n        // Loop structure:\n        // - Loop over indices to collect values at indices divisible by 3.\n        // - Loop over the collected indices to put sorted values back.\n\n        // Branch: handle null or very small list\n        if (l == null) {\n            return null;\n        }\n        if (l.size() <= 1) {\n            return new ArrayList<>(l);\n        }\n\n        // Sequential: create a mutable copy for the result\n        List<Integer> result = new ArrayList<>(l);\n\n        // Loop: collect indices divisible by 3 and their corresponding values\n        List<Integer> indices = new ArrayList<>();\n        List<Integer> values = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) { // Branch: check divisibility by 3\n                indices.add(i);\n                values.add(l.get(i));\n            }\n        }\n\n        // Sequential: sort the collected values\n        Collections.sort(values);\n\n        // Loop: place sorted values back into their respective positions\n        for (int j = 0; j < indices.size(); j++) {\n            result.set(indices.get(j), values.get(j));\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sortThird(List<Integer> l) {\n        if (l == null) {\n            return null;\n        }\n        if (l.size() <= 1) {\n            return new ArrayList<>(l);\n        }\n\n        List<Integer> result = new ArrayList<>(l);\n        List<Integer> values = new ArrayList<>();\n        \n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                values.add(l.get(i));\n            }\n        }\n\n        Collections.sort(values);\n\n        for (int j = 0, k = 0; j < l.size(); j++) {\n            if (j % 3 == 0) {\n                result.set(j, values.get(k++));\n            }\n        }\n\n        return result;\n    }\n}","nanoTime":"3631041500"}
{"taskId":"Java/34","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.unique(new ArrayList<>(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))).equals(Arrays.asList(0, 2, 3, 5, 9, 123))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a List<Integer>\n        // Output: a List<Integer> containing sorted unique integers\n        // Sequential:\n        // 1) Handle null input by returning an empty list.\n        // 2) Initialize a HashSet \"seen\" to track unique elements and an ArrayList \"ans\" to collect them.\n        // Loop:\n        // 3) For each element \"x\" in l:\n        // Branch:\n        //    a) If x is null, skip it.\n        //    b) If x is not in \"seen\", add x to both \"seen\" and \"ans\".\n        // Sequential:\n        // 4) Sort \"ans\" in ascending order.\n        // 5) Return \"ans\".\n        if (l == null || l.isEmpty()) {\n            return new ArrayList<>();\n        }\n        Set<Integer> seen = new HashSet<>();\n        List<Integer> ans = new ArrayList<>();\n        for (Integer x : l) {\n            if (x == null) {\n                continue;\n            }\n            if (!seen.contains(x)) {\n                seen.add(x);\n                ans.add(x);\n            }\n        }\n        Collections.sort(ans);\n        return ans;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique elements in a list\n    >>> unique(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [0, 2, 3, 5, 9, 123]\n     */\n    public List<Integer> unique(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            return Collections.emptyList();\n        }\n        Set<Integer> seen = new HashSet<>();\n        for (Integer x : l) {\n            if (x != null) {\n                seen.add(x);\n            }\n        }\n        List<Integer> ans = new ArrayList<>(seen);\n        Collections.sort(ans);\n        return ans;\n    }\n}","nanoTime":"2198646100"}
{"taskId":"Java/35","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.maxElement(new ArrayList<>(Arrays.asList(1, 2, 3))) == 3,\n                s.maxElement(new ArrayList<>(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10))) == 124\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> maxElement(Arrays.asList(1, 2, 3))\n    3\n    >>> maxElement(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int maxElement(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a list of integers\n        // Output: the maximum integer in the list\n        // Sequential, Branch, Loop structures:\n        // 1. Sequential: Validate input and initialize variables.\n        // 2. Branch: If l is null or empty, throw an exception.\n        // 3. Sequential: Set max to the first element.\n        // 4. Loop: Iterate through the rest of the list.\n        // 5. Branch inside loop: If current element > max, update max.\n        // 6. Sequential: Return max.\n\n        if (l == null || l.isEmpty()) { // Branch: input validation\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n\n        int max = l.get(0); // Sequential: initialization\n        for (int i = 1; i < l.size(); i++) { // Loop: iterate over elements\n            int current = l.get(i);\n            if (current > max) { // Branch: compare and update\n                max = current;\n            }\n        }\n        return max; // Sequential: output\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return maximum element in the list.\n    >>> maxElement(List.of(1, 2, 3))\n    3\n    >>> maxElement(List.of(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n    123\n     */\n    public int maxElement(List<Integer> l) {\n        if (l == null || l.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n\n        return l.stream()\n                .max(Integer::compareTo)\n                .orElseThrow(() -> new IllegalArgumentException(\"List must not be empty\"));\n    }\n}","nanoTime":"2801861400"}
{"taskId":"Java/36","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fizzBuzz(50) == 0,\n                s.fizzBuzz(78) == 2,\n                s.fizzBuzz(79) == 3,\n                s.fizzBuzz(100) == 3,\n                s.fizzBuzz(200) == 6,\n                s.fizzBuzz(4000) == 192,\n                s.fizzBuzz(10000) == 639,\n                s.fizzBuzz(100000) == 8026\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizzBuzz(50)\n    0\n    >>> fizzBuzz(78)\n    2\n    >>> fizzBuzz(79)\n    3\n     */\n    public int fizzBuzz(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: count, an integer\n        // Sequential structure:\n        // 1. Initialize a counter \"count\" to 0.\n        // 2. Iterate through all integers i from 1 to n - 1.\n        // Branch structure:\n        // 3. For each i, check if i is divisible by 11 or by 13.\n        //    - If true, proceed to count how many '7' digits are in i.\n        // Loop structure:\n        // 4. To count '7's in i, repeatedly extract the last digit and compare to 7.\n        // 5. Accumulate the total number of '7's into \"count\".\n        // 6. After finishing the loop, return \"count\".\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                int x = i;\n                while (x > 0) {\n                    if (x % 10 == 7) {\n                        count++;\n                    }\n                    x /= 10;\n                }\n            }\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizzBuzz(50)\n    0\n    >>> fizzBuzz(78)\n    2\n    >>> fizzBuzz(79)\n    3\n     */\n    public int fizzBuzz(int n) {\n        int count = 0;\n        for (int i = 1; i < n; i++) {\n            if (isDivisibleBy11Or13(i)) {\n                count += countSevens(i);\n            }\n        }\n        return count;\n    }\n\n    private boolean isDivisibleBy11Or13(int number) {\n        return number % 11 == 0 || number % 13 == 0;\n    }\n\n    private int countSevens(int number) {\n        int count = 0;\n        while (number > 0) {\n            if (number % 10 == 7) {\n                count++;\n            }\n            number /= 10;\n        }\n        return count;\n    }\n}","nanoTime":"4984297100"}
{"taskId":"Java/37","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sortEven(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(1, 2, 3)),\n                s.sortEven(new ArrayList<>(Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))).equals(Arrays.asList(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123)),\n                s.sortEven(new ArrayList<>(Arrays.asList(5, 8, -12, 4, 23, 2, 3, 11, 12, -10))).equals(Arrays.asList(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sortEven(Arrays.asList(1, 2, 3))\n    [1, 2, 3]\n    >>> sortEven(Arrays.asList(5, 6, 3, 4))\n    [3, 6, 5, 4]\n     */\n    public List<Integer> sortEven(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a list of integers\n        // Output: a new list l' meeting the specification\n        // Sequential structure:\n        // 1. Handle edge cases and prepare a mutable copy of the list.\n        // 2. Collect elements at even indices into a separate list.\n        // 3. Sort that list in non-decreasing order.\n        // 4. Place the sorted even-index elements back into their original even positions.\n        // Branch structure:\n        // - If the input list is null or has fewer than 2 elements, simply return a copy as is.\n        // Loop structure:\n        // - Use loops to collect even-indexed elements and to write them back after sorting.\n\n        // Write your code here\n        if (l == null) {\n            return null;\n        }\n        int n = l.size();\n        if (n <= 1) {\n            return new ArrayList<>(l);\n        }\n\n        List<Integer> evens = new ArrayList<>();\n        for (int i = 0; i < n; i += 2) {\n            evens.add(l.get(i));\n        }\n\n        Collections.sort(evens);\n\n        List<Integer> result = new ArrayList<>(l);\n\n        int idx = 0;\n        for (int i = 0; i < n; i += 2) {\n            result.set(i, evens.get(idx));\n            idx++;\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sortEven(List<Integer> l) {\n        if (l == null || l.size() <= 1) {\n            return new ArrayList<>(l);\n        }\n\n        List<Integer> evens = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 2) {\n            evens.add(l.get(i));\n        }\n\n        Collections.sort(evens);\n\n        List<Integer> result = new ArrayList<>(l);\n        for (int i = 0, idx = 0; i < result.size(); i += 2, idx++) {\n            result.set(i, evens.get(idx));\n        }\n\n        return result;\n    }\n}","nanoTime":"2237023500"}
{"taskId":"Java/38","test":"public class Main {\n    static char[] letters = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\n    static Random rand = new Random(42);\n    public static String random_string(int length) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            sb.append(letters[rand.nextInt(26)]);\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        for (int i = 0; i < 100; i++) {\n            String str = random_string(rand.nextInt(10) + 10);\n            String encode_str = s.encodeCyclic(str);\n            if (!s.decodeCyclic(encode_str).equals(str)) {\n                throw new AssertionError();\n            }\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decodeCyclic(String s) {\n        // Let's think step by step\n        // Input: s, a string encoded by encodeCyclic\n        // Output: original decoded string\n        // 1. Split s into groups of length 3. (sequential)\n        // 2. For each group, iterate over all groups. (loop)\n        // 3.   If a group length is exactly 3, rotate it right by 1 (last char to front). (branch)\n        // 4.   Otherwise, leave the group unchanged.\n        // 5. Join all groups back into a single string and return it.\n        // Write your code here\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        for (int i = 0; i < groups.size(); i++) {\n            String g = groups.get(i);\n            if (g.length() == 3) {\n                groups.set(i, g.substring(2) + g.substring(0, 2));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encodeCyclic(String s) {\n        return processCyclic(s, true);\n    }\n\n    public String decodeCyclic(String s) {\n        return processCyclic(s, false);\n    }\n\n    private String processCyclic(String s, boolean isEncoding) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < s.length(); i += 3) {\n            String group = s.substring(i, Math.min(i + 3, s.length()));\n            if (group.length() == 3) {\n                group = isEncoding ? group.substring(1) + group.charAt(0) : group.charAt(2) + group.substring(0, 2);\n            }\n            result.append(group);\n        }\n        return result.toString();\n    }\n}","nanoTime":"2630263700"}
{"taskId":"Java/39","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.primeFib(1) == 2,\n                s.primeFib(2) == 3,\n                s.primeFib(3) == 5,\n                s.primeFib(4) == 13,\n                s.primeFib(5) == 89,\n                s.primeFib(6) == 233,\n                s.primeFib(7) == 1597,\n                s.primeFib(8) == 28657,\n                s.primeFib(9) == 514229,\n                s.primeFib(10) == 433494437\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    primeFib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> primeFib(1)\n    2\n    >>> primeFib(2)\n    3\n    >>> primeFib(3)\n    5\n    >>> primeFib(4)\n    13\n    >>> primeFib(5)\n    89\n     */\n    public int primeFib(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: the n-th Fibonacci number that is also prime\n        // Sequential structure:\n        // 1. Initialize Fibonacci seeds a = 0, b = 1 and a counter count = 0.\n        // Loop structure:\n        // 2. Repeatedly generate next Fibonacci number c = a + b.\n        //    Update a = b, b = c for next iteration.\n        // Branch structure:\n        // 3. If c is prime, increment count.\n        // 4. If count == n, return c.\n        // 5. Continue looping until result is found or overflow occurs.\n\n        if (n <= 0) {\n            return -1;\n        }\n\n        int a = 0, b = 1;\n        int count = 0;\n\n        while (true) {\n            int c = a + b;\n            a = b;\n            b = c;\n\n            if (c > 1 && isPrime(c)) {\n                count++;\n                if (count == n) {\n                    return c;\n                }\n            }\n\n            // Prevent infinite loop in case of integer overflow\n            if (c <= 0) {\n                break;\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n        for (int i = 5; (long) i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    primeFib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> primeFib(1)\n    2\n    >>> primeFib(2)\n    3\n    >>> primeFib(3)\n    5\n    >>> primeFib(4)\n    13\n    >>> primeFib(5)\n    89\n     */\n    public int primeFib(int n) {\n        if (n <= 0) {\n            return -1;\n        }\n\n        int a = 0, b = 1;\n        int count = 0;\n\n        while (true) {\n            int c = a + b;\n            a = b;\n            b = c;\n\n            if (c > 1 && isPrime(c) && ++count == n) {\n                return c;\n            }\n\n            if (c <= 0) {\n                break;\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean isPrime(int num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n        for (int i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n}","nanoTime":"6589063900"}
{"taskId":"Java/40","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, 0))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, -1))),\n                s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, -2, 1))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 2, 3, 7))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 2, 5, 7))),\n                s.triplesSumToZero(new ArrayList<>(Arrays.asList(2, 4, -5, 3, 9, 7))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, -100))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(100, 3, 5, -100)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    triplesSumToZero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triplesSumToZero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> triplesSumToZero(Arrays.asList(1, 3, -2, 1))\n    true\n    >>> triplesSumToZero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> triplesSumToZero(Arrays.asList(2, 4, -5, 3, 9, 7))\n    true\n    >>> triplesSumToZero(Arrays.asList(1))\n    false\n     */\n    public boolean triplesSumToZero(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a list of integers\n        // Output: boolean indicating if there exist three distinct indices whose values sum to zero\n        // Sequential steps:\n        // 1. If l is null or its size is less than 3, immediately return false.\n        // 2. Copy list elements into an array and sort it (preparation for two-pointer technique).\n        // 3. Loop (for) over each index i from 0 to n-3:\n        //    - Initialize two pointers: left = i + 1 and right = n - 1.\n        //    - Loop (while) while left < right:\n        //        a) Compute sum = arr[i] + arr[left] + arr[right].\n        //        b) Branch:\n        //           - If sum == 0, we found three distinct elements; return true.\n        //           - Else if sum < 0, increase left to get a larger sum.\n        //           - Else (sum > 0), decrease right to get a smaller sum.\n        // 4. If no such triplet is found after all iterations, return false.\n        //\n        // This uses:\n        // - Sequential structure for setup and steps.\n        // - Branch structure via if/else decisions.\n        // - Loop structures via for and while loops.\n\n        // Step 1: Guard checks\n        if (l == null || l.size() < 3) {\n            return false;\n        }\n\n        // Step 2: Copy and sort\n        int n = l.size();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = l.get(i);\n        }\n        Arrays.sort(arr);\n\n        // Step 3: Iterate and use two-pointer technique\n        for (int i = 0; i < n - 2; i++) {\n            // Optional optimization: if current number is > 0, further sums will be > 0\n            if (arr[i] > 0) {\n                break;\n            }\n\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left < right) {\n                long sum = (long) arr[i] + arr[left] + arr[right]; // use long to avoid potential int overflow\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        // Step 4: No triplet found\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean triplesSumToZero(List<Integer> numbers) {\n        if (numbers == null || numbers.size() < 3) {\n            return false;\n        }\n\n        int[] sortedArray = numbers.stream().mapToInt(Integer::intValue).toArray();\n        Arrays.sort(sortedArray);\n\n        for (int i = 0; i < sortedArray.length - 2; i++) {\n            if (sortedArray[i] > 0) {\n                break;\n            }\n\n            int left = i + 1;\n            int right = sortedArray.length - 1;\n\n            while (left < right) {\n                long sum = (long) sortedArray[i] + sortedArray[left] + sortedArray[right];\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return false;\n    }\n}","nanoTime":"3779952400"}
{"taskId":"Java/41","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.carRaceCollision(2) == 4,\n                s.carRaceCollision(3) == 9,\n                s.carRaceCollision(4) == 16,\n                s.carRaceCollision(8) == 64,\n                s.carRaceCollision(10) == 100\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int carRaceCollision(int n) {\n        // Let's think step by step\n        // Input: n, number of cars in each direction (non-negative integer)\n        // Output: total number of collisions (int)\n\n        // Sequential structure:\n        // 1) Validate input n.\n        // 2) Observation: Each left-to-right car will meet (collide with) every right-to-left car exactly once.\n        // 3) Therefore, total collisions = n * n. Compute and return the result.\n\n        // Branch structure:\n        // - If n <= 0, there are no cars in at least one direction, so return 0.\n\n        // Loop structure (conceptual reasoning, not executed for efficiency):\n        // - For i from 1 to n:\n        //     total += n   // each left-to-right car collides with all n right-to-left cars\n        // - This would yield total = n * n, but we avoid the actual loop to keep time O(1).\n\n        // Final code:\n        if (n <= 0) {\n            return 0;\n        }\n        return (int)((long) n * (long) n);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from\n    each other. All cars move at the same speed. Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n     */\n    public int carRaceCollision(int n) {\n        if (n <= 0) {\n            return 0;\n        }\n        return n * n;\n    }\n}","nanoTime":"2370575800"}
{"taskId":"Java/42","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.incrList(new ArrayList<>(Arrays.asList())).equals(List.of()),\n                s.incrList(new ArrayList<>(Arrays.asList(3, 2, 1))).equals(Arrays.asList(4, 3, 2)),\n                s.incrList(new ArrayList<>(Arrays.asList(5, 2, 5, 2, 3, 3, 9, 0, 123))).equals(Arrays.asList(6, 3, 6, 3, 4, 4, 10, 1, 124))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incrList(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incrList(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incrList(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a List<Integer>\n        // Output: a new List<Integer> with each element increased by 1\n        // Sequential structure:\n        // 1. Initialize an empty result list.\n        // Branch structure:\n        // 2. If the input list is null, return the empty result immediately.\n        // Loop structure:\n        // 3. Iterate through each element in the input list:\n        //    - If the element is non-null, add element + 1 to the result.\n        //    - Otherwise, add null to the result to preserve positions.\n        // 4. Return the result list.\n\n        // 1. Initialize result\n        List<Integer> result = new ArrayList<>();\n        // 2. Branch: handle null input\n        if (l == null) {\n            return result;\n        }\n        // 3. Loop: process each element\n        for (Integer val : l) {\n            if (val != null) {\n                result.add(val + 1);\n            } else {\n                result.add(null);\n            }\n        }\n        // 4. Return\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\nimport java.util.stream.Collectors;\n\nclass Solution {\n    /**\n    Return list with elements incremented by 1.\n    >>> incrList(Arrays.asList(1, 2, 3))\n    [2, 3, 4]\n    >>> incrList(Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n     */\n    public List<Integer> incrList(List<Integer> l) {\n        List<Integer> result = new ArrayList<>();\n        if (l == null) {\n            return result;\n        }\n        for (Integer val : l) {\n            result.add(val == null ? null : val + 1);\n        }\n        return result;\n    }\n}","nanoTime":"3395380700"}
{"taskId":"Java/43","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, 0))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 3, -2, 1))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 2, 3, 7))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(2, 4, -5, 3, 5, 7))),\n                !s.pairsSumToZero(new ArrayList<>(List.of(1))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 3, 2, 30))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 3, 2, 31))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 4, 2, 30))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 4, 2, 31)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairsSumToZero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairsSumToZero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairsSumToZero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairsSumToZero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairsSumToZero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairsSumToZero(Arrays.asList(1))\n    false\n     */\n    public boolean pairsSumToZero(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a list of integers\n        // Output: boolean indicating whether two distinct elements sum to zero\n\n        // Sequential structure:\n        // 1) Handle edge cases and initialize data structures.\n        // Branch structure:\n        // - If the list is null or has fewer than 2 elements, return false.\n        if (l == null || l.size() < 2) {\n            return false;\n        }\n\n        // Sequential step: initialize a set to store seen numbers.\n        Set<Integer> seen = new HashSet<>();\n\n        // Loop structure:\n        // 2) Iterate over each number in the list.\n        for (Integer x : l) {\n            // Branch structure: skip nulls if any.\n            if (x == null) {\n                continue;\n            }\n            // Branch structure:\n            // 3) If the additive inverse of current number has been seen,\n            //    we found two distinct elements summing to zero.\n            if (seen.contains(-x)) {\n                return true;\n            }\n            // Sequential step within loop:\n            // 4) Otherwise, record the current number as seen.\n            seen.add(x);\n        }\n\n        // Sequential step:\n        // 5) If no such pair exists after the loop, return false.\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean pairsSumToZero(List<Integer> l) {\n        if (l == null || l.size() < 2) {\n            return false;\n        }\n\n        Set<Integer> seen = new HashSet<>();\n\n        for (Integer x : l) {\n            if (x != null && seen.contains(-x)) {\n                return true;\n            }\n            if (x != null) {\n                seen.add(x);\n            }\n        }\n\n        return false;\n    }\n}","nanoTime":"2962889900"}
{"taskId":"Java/44","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.changeBase(8, 3), \"22\"),\n                Objects.equals(s.changeBase(9, 3), \"100\"),\n                Objects.equals(s.changeBase(234, 2), \"11101010\"),\n                Objects.equals(s.changeBase(16, 2), \"10000\"),\n                Objects.equals(s.changeBase(8, 2), \"1000\"),\n                Objects.equals(s.changeBase(7, 2), \"111\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n        for (int x = 2; x < 8; x++) {\n            if (!Objects.equals(s.changeBase(x, x + 1), String.valueOf(x))) {\n                throw new AssertionError();\n            }\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> changeBase(8, 3)\n    \"22\"\n    >>> changeBase(8, 2)\n    \"1000\"\n    >>> changeBase(7, 2)\n    \"111\"\n     */\n    public String changeBase(int x, int base) {\n        // Let's think step by step\n        // Input: x (integer), base (integer less than 10)\n        // Output: string representation of x in the given base\n        // Sequential:\n        // 1. Validate base is within valid range (2 to 9).\n        // 2. Handle special case when x == 0 -> return \"0\".\n        // 3. Prepare to build the result string.\n        // Loop:\n        // 4. While the absolute value of x is greater than 0:\n        // 5.   Compute remainder by modulo with base.\n        // 6.   Append corresponding digit character.\n        // 7.   Divide the value by base and continue.\n        // Branch:\n        // 8. If original number was negative, prefix '-' to the result.\n        // 9. Return the constructed string.\n\n        // Step 1: validate base\n        if (base < 2 || base > 9) {\n            throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        }\n\n        // Step 2: handle zero\n        if (x == 0) {\n            return \"0\";\n        }\n\n        // Use long to safely handle Integer.MIN_VALUE\n        long value = x;\n        boolean negative = value < 0;\n        if (negative) {\n            value = -value;\n        }\n\n        // Step 3: prepare builder\n        StringBuilder sb = new StringBuilder();\n\n        // Steps 4-7: conversion loop (collect digits in reverse)\n        while (value > 0) {\n            int rem = (int) (value % base); // base < 10 so single digit 0..9\n            sb.append((char) ('0' + rem));\n            value /= base;\n        }\n\n        // Reverse to correct order\n        sb.reverse();\n\n        // Step 8: handle negativity\n        if (negative) {\n            sb.insert(0, '-');\n        }\n\n        // Step 9: return result\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String changeBase(int x, int base) {\n        validateBase(base);\n        if (x == 0) return \"0\";\n\n        long value = Math.abs((long) x);\n        StringBuilder sb = new StringBuilder();\n\n        while (value > 0) {\n            sb.append((char) ('0' + (value % base)));\n            value /= base;\n        }\n\n        if (x < 0) sb.append('-');\n        return sb.reverse().toString();\n    }\n\n    private void validateBase(int base) {\n        if (base < 2 || base > 9) {\n            throw new IllegalArgumentException(\"Base must be between 2 and 9\");\n        }\n    }\n}","nanoTime":"3448672400"}
{"taskId":"Java/45","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.triangleArea(5, 3) == 7.5,\n                s.triangleArea(2, 2) == 2.0,\n                s.triangleArea(10, 8) == 40.0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and high return area for a triangle.\n    >>> triangleArea(5, 3)\n    7.5\n     */\n    public double triangleArea(double a, double h) {\n        // Let's think step by step\n        // Input: a (base length), h (height)\n        // Output: area as a double\n        // Sequential structure:\n        // 1. Receive inputs a and h.\n        // 2. Apply the formula area = 0.5 * a * h.\n        // Branch structure:\n        // 3. If either a <= 0 or h <= 0, return 0.0 to indicate invalid dimensions.\n        // Loop structure:\n        // 4. No loop is required for a single triangle; if handling multiple triangles, we would loop over the collection and apply the same formula to each.\n        // Final code:\n        if (a <= 0 || h <= 0) {\n            return 0.0;\n        }\n        return 0.5 * a * h;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given length of a side and height, return area for a triangle.\n    >>> triangleArea(5, 3)\n    7.5\n     */\n    public double triangleArea(double base, double height) {\n        if (base <= 0 || height <= 0) {\n            return 0.0;\n        }\n        return calculateArea(base, height);\n    }\n\n    private double calculateArea(double base, double height) {\n        return 0.5 * base * height;\n    }\n}","nanoTime":"2629220400"}
{"taskId":"Java/46","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fib4(5) == 4,\n                s.fib4(8) == 28,\n                s.fib4(10) == 104,\n                s.fib4(12) == 386\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: fib4(n), an integer\n        // Sequential:\n        // 1) Use a direct lookup for base cases (branch structure).\n        // 2) Initialize rolling variables for f(n-4), f(n-3), f(n-2), f(n-1).\n        // Loop:\n        // 3) For i from 4 to n, compute next = a + b + c + d, then shift the window.\n        // 4) Return the computed value.\n        // Branch structure for base cases\n        if (n <= 3) {\n            int[] base = {0, 0, 2, 0};\n            return base[n];\n        }\n        // Sequential initialization\n        int a = 0; // f(0)\n        int b = 0; // f(1)\n        int c = 2; // f(2)\n        int d = 0; // f(3)\n        // Loop to build up to n\n        for (int i = 4; i <= n; i++) {\n            int next = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = next;\n        }\n        return d;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fib4(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"Input must be non-negative.\");\n        if (n <= 3) return new int[]{0, 0, 2, 0}[n];\n\n        int[] fib = new int[n + 1];\n        fib[0] = 0;\n        fib[1] = 0;\n        fib[2] = 2;\n        fib[3] = 0;\n\n        for (int i = 4; i <= n; i++) {\n            fib[i] = fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4];\n        }\n        return fib[n];\n    }\n}","nanoTime":"3546326300"}
{"taskId":"Java/47","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.median(new ArrayList<>(Arrays.asList(3, 1, 2, 4, 5))) == 3,\n                s.median(new ArrayList<>(Arrays.asList(-10, 4, 6, 1000, 10, 20))) == 8.0,\n                s.median(new ArrayList<>(Arrays.asList(5))) == 5,\n                s.median(new ArrayList<>(Arrays.asList(6, 5))) == 5.5\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return median of elements in the list l.\n    >>> median(Arrays.asList(3, 1, 2, 4, 5))\n    3\n    >>> median(Arrays.asList(-10, 4, 6, 1000, 10, 20))\n    15.0\n     */\n    public double median(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a list of integers\n        // Output: the median value as a double\n        // Sequential structure:\n        // 1) If the list is empty, return 0.0 (or could throw, but we choose 0.0 here).\n        // 2) Copy elements into an array.\n        // 3) Sort the array.\n        // Branch structure:\n        // 4) If the number of elements is odd, return the middle element.\n        // 5) Else (even), return the average of the two middle elements.\n        // Loop structure:\n        // - Use a loop to copy elements from the list into an array.\n\n        int n = l.size();\n        if (n == 0) {\n            return 0.0;\n        }\n\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) { // loop to copy elements\n            arr[i] = l.get(i);\n        }\n\n        Arrays.sort(arr);\n\n        if (n % 2 == 1) { // odd length\n            return (double) arr[n / 2];\n        } else { // even length\n            int a = arr[n / 2 - 1];\n            int b = arr[n / 2];\n            return (a + b) / 2.0;\n        }\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double median(List<Integer> l) {\n        int n = l.size();\n        if (n == 0) {\n            return 0.0;\n        }\n\n        List<Integer> sortedList = new ArrayList<>(l);\n        Collections.sort(sortedList);\n\n        if (n % 2 == 1) {\n            return sortedList.get(n / 2);\n        } else {\n            return (sortedList.get(n / 2 - 1) + sortedList.get(n / 2)) / 2.0;\n        }\n    }\n}","nanoTime":"2620302700"}
{"taskId":"Java/48","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isPalindrome(\"\"),\n                s.isPalindrome(\"aba\"),\n                s.isPalindrome(\"aaaaa\"),\n                !s.isPalindrome(\"zbcd\"),\n                s.isPalindrome(\"xywyx\"),\n                !s.isPalindrome(\"xywyz\"),\n                !s.isPalindrome(\"xywzx\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> isPalindrome(\"\")\n    true\n    >>> isPalindrome(\"aba\")\n    true\n    >>> isPalindrome(\"aaaaa\")\n    true\n    >>> isPalindrome(\"zbcd\")\n    false\n     */\n    public boolean isPalindrome(String text) {\n        // Let's think step by step\n        // Input: text, a String\n        // Output: boolean indicating if text is a palindrome\n        // 1. If text is null, return false. (Branch)\n        // 2. Initialize two pointers: left = 0, right = text.length() - 1. (Sequential)\n        // 3. While left < right: (Loop)\n        // 4.   If characters at left and right differ, return false. (Branch)\n        // 5.   Move left forward and right backward. (Sequential within loop)\n        // 6. If loop completes, return true. (Sequential)\n        if (text == null) {\n            return false;\n        }\n        int left = 0;\n        int right = text.length() - 1;\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> isPalindrome(\"\")\n    true\n    >>> isPalindrome(\"aba\")\n    true\n    >>> isPalindrome(\"aaaaa\")\n    true\n    >>> isPalindrome(\"zbcd\")\n    false\n     */\n    public boolean isPalindrome(String text) {\n        if (text == null) {\n            return false;\n        }\n        int left = 0;\n        int right = text.length() - 1;\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}","nanoTime":"2452841400"}
{"taskId":"Java/49","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.modp(3, 5) == 3,\n                s.modp(1101, 101) == 2,\n                s.modp(0, 101) == 1,\n                s.modp(3, 11) == 8,\n                s.modp(100, 101) == 1,\n                s.modp(30, 5) == 4,\n                s.modp(31, 5) == 3\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n        // Let's think step by step\n        // Input: n (exponent), p (modulus), both integers\n        // Output: (2^n) mod p as an integer\n        //\n        // Sequential structure:\n        // 1) Handle trivial cases:\n        //    - If p == 1, answer is 0 (everything modulo 1 is 0).\n        //    - If n == 0, answer is 1 % p.\n        // 2) Initialize:\n        //    - result = 1 (accumulator)\n        //    - base = 2 % p\n        //    - exp = n\n        //\n        // Loop structure:\n        // 3) While exp > 0:\n        //    - Branch structure:\n        //      a) If current bit of exp is 1 (exp is odd), multiply result by base modulo p.\n        //    - Square the base modulo p.\n        //    - Shift exp right by 1 (divide by 2).\n        //\n        // 4) Return result as int.\n        //\n        // Be aware of numerics: use long to avoid overflow during multiplication before modulo.\n\n        if (p == 1) {\n            return 0;\n        }\n        if (n == 0) {\n            return 1 % p;\n        }\n\n        long mod = p;             // promote to long for safe arithmetic\n        long result = 1L;\n        long base = 2L % mod;\n        int exp = n;\n\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % mod;\n            }\n            base = (base * base) % mod;\n            exp >>= 1;\n        }\n\n        return (int) (result % mod);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n        if (p <= 1) {\n            return 0;\n        }\n        if (n == 0) {\n            return 1;\n        }\n\n        long result = 1L;\n        long base = 2L % p;\n\n        for (int exp = n; exp > 0; exp >>= 1) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % p;\n            }\n            base = (base * base) % p;\n        }\n\n        return (int) result;\n    }\n}","nanoTime":"3919744600"}
{"taskId":"Java/50","test":"public class Main {\n    static char[] letters = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\n    static Random rand = new Random(42);\n\n    public static String random_string(int length) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            sb.append(letters[rand.nextInt(26)]);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        for (int i = 0; i < 100; i++) {\n            String str = random_string(rand.nextInt(10) + 10);\n            String encode_str = s.encodeShift(str);\n            if (!s.decodeShift(encode_str).equals(str)) {\n                throw new AssertionError();\n            }\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by shifting every character by 5 in the alphabet.\n     */\n    public String encodeShift(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            sb.append((char) ('a' + ((ch + 5 - 'a') % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n    takes as input string encoded with encodeShift function. Returns decoded string.\n     */\n    public String decodeShift(String s) {\n        // Let's think step by step\n        // Input: s, a string encoded by shifting each character by +5 with wrap-around\n        // Output: decoded string, where each character is shifted back by 5 with wrap-around\n        // 1. Initialize a StringBuilder to accumulate the decoded characters. (sequential)\n        // 2. For each character ch in the input string: (loop)\n        // 3.   Compute delta = (ch - 'a' - 5) % 26.\n        // 4.   If delta is negative, add 26 to wrap around. (branch)\n        // 5.   Append ('a' + delta) as the decoded character to the builder.\n        // 6. Return the built string. (sequential)\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            int delta = (ch - 'a' - 5) % 26;\n            if (delta < 0) {\n                delta += 26;\n            }\n            sb.append((char) ('a' + delta));\n        }\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    private static final int SHIFT = 5;\n    private static final int ALPHABET_SIZE = 26;\n    private static final char BASE_CHAR = 'a';\n\n    public String encodeShift(String s) {\n        return shiftString(s, SHIFT);\n    }\n\n    public String decodeShift(String s) {\n        return shiftString(s, -SHIFT);\n    }\n\n    private String shiftString(String s, int shift) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            char shiftedChar = (char) (BASE_CHAR + (ch - BASE_CHAR + shift + ALPHABET_SIZE) % ALPHABET_SIZE);\n            sb.append(shiftedChar);\n        }\n        return sb.toString();\n    }\n}","nanoTime":"2296002500"}
{"taskId":"Java/51","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.removeVowels(\"\"), \"\"),\n                Objects.equals(s.removeVowels(\"abcdef\\nghijklm\"), \"bcdf\\nghjklm\"),\n                Objects.equals(s.removeVowels(\"fedcba\"), \"fdcb\"),\n                Objects.equals(s.removeVowels(\"eeeee\"), \"\"),\n                Objects.equals(s.removeVowels(\"acBAA\"), \"cB\"),\n                Objects.equals(s.removeVowels(\"EcBOO\"), \"cB\"),\n                Objects.equals(s.removeVowels(\"ybcd\"), \"ybcd\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    removeVowels is a function that takes string and returns string without vowels.\n    >>> removeVowels(\"\")\n    \"\"\n    >>> removeVowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> removeVowels(\"abcdef\")\n    \"bcdf\"\n    >>> removeVowels(\"aaaaa\")\n    \"\"\n    >>> removeVowels(\"aaBAA\")\n    \"B\"\n    >>> removeVowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String removeVowels(String text) {\n        // Let's think step by step\n        // Input: text, a String\n        // Output: a String with all vowels (a, e, i, o, u in both cases) removed\n        // 1. If text is null or empty, return an empty string. (sequential + branch)\n        // 2. Initialize a StringBuilder to build the result. (sequential)\n        // 3. Loop through each character in text. (loop)\n        // 4.   If the character is a vowel, skip it. (branch)\n        // 5.   Else, append the character to the result. (branch)\n        // 6. Return the built string. (sequential)\n\n        if (text == null || text.length() == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            switch (c) {\n                case 'a': case 'e': case 'i': case 'o': case 'u':\n                case 'A': case 'E': case 'I': case 'O': case 'U':\n                    // Vowel detected, skip adding it\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    removeVowels is a function that takes string and returns string without vowels.\n    >>> removeVowels(\"\")\n    \"\"\n    >>> removeVowels(\"abcdef\\nghijklm\")\n    \"bcdf\\nghjklm\"\n    >>> removeVowels(\"abcdef\")\n    \"bcdf\"\n    >>> removeVowels(\"aaaaa\")\n    \"\"\n    >>> removeVowels(\"aaBAA\")\n    \"B\"\n    >>> removeVowels(\"zbcd\")\n    \"zbcd\"\n     */\n    public String removeVowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return \"\";\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isVowel(char c) {\n        return \"aeiouAEIOU\".indexOf(c) != -1;\n    }\n}","nanoTime":"3861628900"}
{"taskId":"Java/52","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.belowThreshold(new ArrayList<>(Arrays.asList(1, 2, 4, 10)), 100),\n                !s.belowThreshold(new ArrayList<>(Arrays.asList(1, 20, 4, 10)), 5),\n                s.belowThreshold(new ArrayList<>(Arrays.asList(1, 20, 4, 10)), 21),\n                s.belowThreshold(new ArrayList<>(Arrays.asList(1, 20, 4, 10)), 22),\n                s.belowThreshold(new ArrayList<>(Arrays.asList(1, 8, 4, 10)), 11),\n                !s.belowThreshold(new ArrayList<>(Arrays.asList(1, 8, 4, 10)), 10)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> belowThreshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> belowThreshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean belowThreshold(List<Integer> l, int t) {\n        // Let's think step by step\n        // Input: l (list of integers), t (threshold integer)\n        // Output: boolean indicating if all elements are strictly less than t\n        // 1. Sequential: Initialize a flag allBelow to true.\n        // 2. Loop: Iterate through each element x in list l.\n        // 3. Branch: If x is greater than or equal to t, set allBelow to false and break the loop.\n        // 4. Sequential: Return the allBelow flag as the result.\n\n        boolean allBelow = true;\n        for (int x : l) {\n            if (x >= t) {\n                allBelow = false;\n                break;\n            }\n        }\n        return allBelow;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if all numbers in the list l are below threshold t.\n    >>> belowThreshold(Arrays.asList(1, 2, 4, 10), 100)\n    true\n    >>> belowThreshold(Arrays.asList(1, 20, 4, 10), 5)\n    false\n     */\n    public boolean belowThreshold(List<Integer> l, int t) {\n        return l.stream().allMatch(x -> x < t);\n    }\n}","nanoTime":"2835302800"}
{"taskId":"Java/53","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Random rand = new Random(42);\n        List<Boolean> correct = Arrays.asList(\n                s.add(0, 1) == 1,\n                s.add(1, 0) == 1,\n                s.add(2, 3) == 5,\n                s.add(5, 7) == 12,\n                s.add(7, 5) == 12\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n        for (int i = 0; i < 100; i++) {\n            int x = rand.nextInt(1000), y = rand.nextInt(1000);\n            if (s.add(x, y) != x + y) {\n                throw new AssertionError();\n            }\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n     */\n    public int add(int x, int y) {\n        // Let's think step by step\n        // Input: integers x and y\n        // Output: integer sum of x and y\n        // Sequential structure:\n        // 1. Initialize a = x, b = y.\n        // 2. We'll use bitwise operations to compute the sum iteratively.\n        // Branch structure:\n        // 3. If b == 0, return a immediately as the sum.\n        // Loop structure:\n        // 4. While b != 0:\n        //    - Compute carry as common set bits of a and b.\n        //    - Compute partial sum without carry using XOR.\n        //    - Move carry to the next higher bit.\n        // 5. Return a as the final sum.\n\n        int a = x;\n        int b = y;\n\n        if (b == 0) {\n            return a;\n        }\n\n        while (b != 0) {\n            int carry = a & b;\n            a = a ^ b;\n            b = carry << 1;\n        }\n\n        return a;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int add(int x, int y) {\n        while (y != 0) {\n            int carry = x & y;\n            x = x ^ y;\n            y = carry << 1;\n        }\n        return x;\n    }\n}","nanoTime":"1606236200"}
{"taskId":"Java/54","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),\n                s.sameChars(\"abcd\", \"dddddddabc\"),\n                s.sameChars(\"dddddddabc\", \"abcd\"),\n                !s.sameChars(\"eabcd\", \"dddddddabc\"),\n                !s.sameChars(\"abcd\", \"dddddddabcf\"),\n                !s.sameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),\n                !s.sameChars(\"aabb\", \"aaccc\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if two words have the same characters.\n    >>> sameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n    true\n    >>> sameChars(\"abcd\", \"dddddddabc\")\n    true\n    >>> sameChars(\"dddddddabc\", \"abcd\")\n    true\n    >>> sameChars(\"eabcd\", \"dddddddabc\")\n    false\n    >>> sameChars(\"abcd\", \"dddddddabce\")\n    false\n    >>> sameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n    false\n     */\n    public boolean sameChars(String s0, String s1) {\n        // Let's think step by step\n        // Input: s0, s1 (strings)\n        // Output: boolean indicating if both strings contain the same unique characters (ignoring counts)\n        // Problem-solving process using three programming structures:\n        // Sequential:\n        // 1) Initialize two empty sets to store unique characters from each string.\n        // Loop:\n        // 2) Traverse each string and add each character to its corresponding set.\n        // Branch:\n        // 3) If the sets differ in size, return false immediately.\n        // 4) Otherwise, check each character of the first set for membership in the second; if any is missing, return false.\n        // 5) If all checks pass, return true.\n\n        // Final code:\n        Set<Character> set0 = new HashSet<>();\n        for (int i = 0; i < s0.length(); i++) {\n            set0.add(s0.charAt(i));\n        }\n\n        Set<Character> set1 = new HashSet<>();\n        for (int i = 0; i < s1.length(); i++) {\n            set1.add(s1.charAt(i));\n        }\n\n        if (set0.size() != set1.size()) {\n            return false;\n        }\n\n        for (Character c : set0) {\n            if (!set1.contains(c)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean sameChars(String s0, String s1) {\n        Set<Character> set0 = new HashSet<>();\n        Set<Character> set1 = new HashSet<>();\n\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n\n        return set0.equals(set1);\n    }\n}","nanoTime":"2270348300"}
{"taskId":"Java/55","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fib(10) == 55,\n                s.fib(1) == 1,\n                s.fib(8) == 21,\n                s.fib(11) == 89,\n                s.fib(12) == 144\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: the n-th Fibonacci number as an integer\n        // Sequential: set up initial values for Fibonacci computation\n        // Branch: handle base cases (n <= 0, n == 1, n == 2)\n        // Loop: iterate from 3 to n to compute subsequent Fibonacci numbers\n        // 1. If n <= 0, return 0.\n        // 2. If n is 1 or 2, return 1.\n        // 3. Initialize a = 1 (F1) and b = 1 (F2).\n        // 4. For i from 3 to n:\n        // 5.   c = a + b\n        // 6.   a = b\n        // 7.   b = c\n        // 8. Return b as the result.\n        if (n <= 0) {\n            return 0;\n        }\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        int a = 1;\n        int b = 1;\n        for (int i = 3; i <= n; i++) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n     */\n    public int fib(int n) {\n        if (n <= 0) return 0;\n        if (n <= 2) return 1;\n\n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}","nanoTime":"3338779600"}
{"taskId":"Java/56","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.correctBracketing(\"<>\"),\n                s.correctBracketing(\"<<><>>\"),\n                s.correctBracketing(\"<><><<><>><>\"),\n                s.correctBracketing(\"<><><<<><><>><>><<><><<>>>\"),\n                !s.correctBracketing(\"<<<><>>>>\"),\n                !s.correctBracketing(\"><<>\"),\n                !s.correctBracketing(\"<\"),\n                !s.correctBracketing(\"<<<<\"),\n                !s.correctBracketing(\">\"),\n                !s.correctBracketing(\"<<>\"),\n                !s.correctBracketing(\"<><><<><>><>><<>\"),\n                !s.correctBracketing(\"<><><<><>><>>><>\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    \n    >>> correctBracketing(\"<\")\n    false\n    >>> correctBracketing(\"<>\")\n    true\n    >>> correctBracketing(\"<<><>>\")\n    true\n    >>> correctBracketing(\"><<>\")\n    false\n     */\n    public boolean correctBracketing(String brackets) {\n        // Let's think step by step\n        // Input: brackets, a string of '<' and '>'\n        // Output: boolean indicating if brackets are correctly matched\n        // Sequential structure:\n        // 1. Initialize a counter to track unmatched '<' brackets.\n        int count = 0;\n        // Loop structure:\n        // 2. Iterate through each character in the string.\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            // Branch structure:\n            // 3. If the character is '<', increment the counter.\n            // 4. Else (it's '>'), decrement the counter. If it goes negative, return false immediately.\n            if (c == '<') {\n                count++;\n            } else { // c == '>'\n                count--;\n                if (count < 0) {\n                    return false;\n                }\n            }\n        }\n        // Sequential structure:\n        // 5. After processing all characters, return true only if all openings were matched.\n        return count == 0;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correctBracketing(String brackets) {\n        int count = 0;\n        for (char c : brackets.toCharArray()) {\n            count += (c == '<') ? 1 : -1;\n            if (count < 0) {\n                return false;\n            }\n        }\n        return count == 0;\n    }\n}","nanoTime":"1562061400"}
{"taskId":"Java/57","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.monotonic(new ArrayList<>(Arrays.asList(1, 2, 4, 10))),\n                s.monotonic(new ArrayList<>(Arrays.asList(1, 2, 4, 20))),\n                !s.monotonic(new ArrayList<>(Arrays.asList(1, 20, 4, 10))),\n                s.monotonic(new ArrayList<>(Arrays.asList(4, 1, 0, -10))),\n                s.monotonic(new ArrayList<>(Arrays.asList(4, 1, 1, 0))),\n                !s.monotonic(new ArrayList<>(Arrays.asList(1, 2, 3, 2, 5, 60))),\n                s.monotonic(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 60))),\n                s.monotonic(new ArrayList<>(Arrays.asList(9, 9, 9, 9)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n     */\n    public boolean monotonic(List<Integer> l) {\n        // Let's think step by step\n        // Input: l, a list of integers\n        // Output: boolean indicating whether l is monotonic (non-decreasing or non-increasing)\n        // Sequential:\n        // 1. If the list has size 0, 1, or 2, it's trivially monotonic.\n        // 2. Initialize a variable \"direction\" to 0 (unknown): 1 means increasing, -1 means decreasing.\n        // Loop:\n        // 3. Iterate through the list from index 1 to end:\n        //    a. Compute the relation between current and previous element.\n        // Branch:\n        //    b. If equal, continue.\n        //    c. If direction is unknown, set it based on the first non-equal pair.\n        //    d. If direction is increasing and we find a decrease, return false.\n        //    e. If direction is decreasing and we find an increase, return false.\n        // 4. If the loop completes without contradiction, return true.\n\n        int n = l.size();\n        if (n <= 2) {\n            return true;\n        }\n        int direction = 0; // 0: unknown, 1: increasing, -1: decreasing\n\n        for (int i = 1; i < n; i++) {\n            int prev = l.get(i - 1);\n            int curr = l.get(i);\n\n            if (curr == prev) {\n                continue;\n            }\n\n            if (direction == 0) {\n                direction = (curr > prev) ? 1 : -1;\n            } else {\n                if (direction == 1 && curr < prev) {\n                    return false;\n                }\n                if (direction == -1 && curr > prev) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic(Arrays.asList(1, 2, 4, 20))\n    true\n    >>> monotonic(Arrays.asList(1, 20, 4, 10))\n    false\n    >>> monotonic(Arrays.asList(4, 1, 0, -10))\n    true\n    */\n    public boolean monotonic(List<Integer> list) {\n        int n = list.size();\n        if (n <= 2) {\n            return true;\n        }\n\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < n; i++) {\n            if (list.get(i) > list.get(i - 1)) {\n                decreasing = false;\n            } else if (list.get(i) < list.get(i - 1)) {\n                increasing = false;\n            }\n        }\n        return increasing || decreasing;\n    }\n}","nanoTime":"2520169200"}
{"taskId":"Java/58","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.common(new ArrayList<>(Arrays.asList(1, 4, 3, 34, 653, 2, 5)), new ArrayList<>(Arrays.asList(5, 7, 1, 5, 9, 653, 121))).equals(Arrays.asList(1, 5, 653)),\n                s.common(new ArrayList<>(Arrays.asList(5, 3, 2, 8)), new ArrayList<>(Arrays.asList(3, 2))).equals(Arrays.asList(2, 3)),\n                s.common(new ArrayList<>(Arrays.asList(4, 3, 2, 8)), new ArrayList<>(Arrays.asList(3, 2, 4))).equals(Arrays.asList(2, 3, 4)),\n                s.common(new ArrayList<>(Arrays.asList(4, 3, 2, 8)), new ArrayList<>(List.of())).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Let's think step by step\n        // Input: l1, l2 - two lists of integers\n        // Output: a list of integers sorted in ascending order containing unique elements common to both lists\n\n        // Sequential structure:\n        // 1. Handle null inputs by treating them as empty lists.\n        // 2. Place all elements of l1 into a HashSet for fast lookup.\n        // 3. Prepare a result HashSet to store unique common elements.\n        if (l1 == null || l2 == null) {\n            return new ArrayList<>();\n        }\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> resultSet = new HashSet<>();\n\n        // Loop structure:\n        // 4. Iterate through each element in l2.\n        for (Integer x : l2) {\n            // Branch structure:\n            // 5. If the current element exists in set1, add it to resultSet (ensures uniqueness).\n            if (set1.contains(x)) {\n                resultSet.add(x);\n            }\n        }\n\n        // Sequential structure:\n        // 6. Convert resultSet to a list and sort it in ascending order.\n        // 7. Return the sorted list.\n        List<Integer> result = new ArrayList<>(resultSet);\n        Collections.sort(result);\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return sorted unique common elements for two lists.\n    >>> common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121))\n    [1, 5, 653]\n    >>> common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2))\n    [2, 3]\n     */\n    public List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        if (l1 == null || l2 == null) {\n            return Collections.emptyList();\n        }\n        \n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> resultSet = new HashSet<>();\n\n        for (Integer x : l2) {\n            if (set1.contains(x)) {\n                resultSet.add(x);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(resultSet);\n        Collections.sort(result);\n        return result;\n    }\n}","nanoTime":"4343750300"}
{"taskId":"Java/59","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.largestPrimeFactor(15) == 5,\n                s.largestPrimeFactor(27) == 3,\n                s.largestPrimeFactor(63) == 7,\n                s.largestPrimeFactor(330) == 11,\n                s.largestPrimeFactor(13195) == 29\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largestPrimeFactor(13195)\n    29\n    >>> largestPrimeFactor(2048)\n    2\n     */\n    public int largestPrimeFactor(int n) {\n        // Let's think step by step\n        // Input: n (integer > 1 and composite)\n        // Output: largest prime factor (integer)\n        // Sequential structure:\n        // 1. Initialize a variable \"largest\" to track the current largest prime factor.\n        // 2. Remove the factor 2 from n repeatedly and update \"largest\".\n        // 3. Check odd factors starting from 3 up to sqrt(n); for each factor, divide it out completely and update \"largest\".\n        // 4. If after removing all small factors n > 1, then n itself is a prime and is the largest factor.\n        // Branch structure:\n        // - If n is even, handle factor 2.\n        // - If n is divisible by an odd i, divide it out.\n        // - If leftover n > 1, update \"largest\".\n        // Loop structure:\n        // - While loop to strip factor 2.\n        // - While loop over odd i where i*i <= n.\n        // - Inner while loop to divide out each found factor completely.\n        int largest = 1;\n\n        // Remove factor 2\n        while ((n & 1) == 0) {\n            largest = 2;\n            n >>= 1;\n        }\n\n        // Check odd factors\n        int i = 3;\n        while (i * i <= n) {\n            if (n % i == 0) {\n                largest = i;\n                while (n % i == 0) {\n                    n /= i;\n                }\n            }\n            i += 2;\n        }\n\n        // If n is now a prime greater than 1, it's the largest prime factor\n        if (n > 1) {\n            if (n > largest) {\n                largest = n;\n            }\n        }\n\n        return largest;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largestPrimeFactor(13195)\n    29\n    >>> largestPrimeFactor(2048)\n    2\n     */\n    public int largestPrimeFactor(int n) {\n        int largest = 1;\n\n        // Remove factor 2\n        while (n % 2 == 0) {\n            largest = 2;\n            n /= 2;\n        }\n\n        // Check odd factors\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                largest = i;\n                n /= i;\n            }\n        }\n\n        // If n is now a prime greater than 1, it's the largest prime factor\n        if (n > 1) {\n            largest = Math.max(largest, n);\n        }\n\n        return largest;\n    }\n}","nanoTime":"3101724100"}
{"taskId":"Java/60","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumToN(1) == 1,\n                s.sumToN(6) == 21,\n                s.sumToN(11) == 66,\n                s.sumToN(30) == 465,\n                s.sumToN(100) == 5050\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sumToN is a function that sums numbers from 1 to n.\n    >>> sumToN(30)\n    465\n    >>> sumToN(100)\n    5050\n    >>> sumToN(5)\n    15\n    >>> sumToN(10)\n    55\n    >>> sumToN(1)\n    1\n     */\n    public int sumToN(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: sum, an integer\n        // 1) Sequential: Initialize variables \"sum\" to 0 and \"i\" to 1.\n        // 2) Branch: If n <= 0, return 0 since there are no positive numbers to sum.\n        // 3) Loop: While i <= n, add i to sum and increment i by 1.\n        // 4) Return the computed sum.\n        if (n <= 0) {\n            return 0;\n        }\n        int sum = 0;\n        int i = 1;\n        while (i <= n) {\n            sum += i;\n            i++;\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumToN(int n) {\n        if (n <= 0) {\n            return 0;\n        }\n        return n * (n + 1) / 2;\n    }\n}","nanoTime":"1111173300"}
{"taskId":"Java/61","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.correctBracketing(\"()\"),\n                s.correctBracketing(\"(()())\"),\n                s.correctBracketing(\"()()(()())()\"),\n                s.correctBracketing(\"()()((()()())())(()()(()))\"),\n                !s.correctBracketing(\"((()())))\"),\n                !s.correctBracketing(\")(()\"),\n                !s.correctBracketing(\"(\"),\n                !s.correctBracketing(\"((((\"),\n                !s.correctBracketing(\")\"),\n                !s.correctBracketing(\"(()\"),\n                !s.correctBracketing(\"()()(()())())(()\"),\n                !s.correctBracketing(\"()()(()())()))()\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correctBracketing(\"(\")\n    false\n    >>> correctBracketing(\"()\")\n    true\n    >>> correctBracketing(\"(()())\")\n    true\n    >>> correctBracketing(\")(()\")\n    false\n     */\n    public boolean correctBracketing(String brackets) {\n        // Let's think step by step\n        // Input: brackets, a string consisting of '(' and ')'\n        // Output: boolean indicating whether all opening brackets are properly closed\n        // Sequential:\n        // 1. Initialize a counter \"balance\" to 0 to track unmatched '('.\n        // Loop:\n        // 2. Iterate over each character in the string:\n        //    Branch:\n        //    a) If the character is '(', increment balance.\n        //    b) Else if the character is ')', decrement balance.\n        //       If balance becomes negative at any point, return false (a closing bracket appears before a matching opening).\n        // 3. After the loop, return true if balance == 0 (all opened are closed), else false.\n        int balance = 0;\n        for (int i = 0; i < brackets.length(); i++) {\n            char c = brackets.charAt(i);\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n        return balance == 0;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean correctBracketing(String brackets) {\n        int balance = 0;\n        for (char c : brackets.toCharArray()) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                if (--balance < 0) {\n                    return false;\n                }\n            }\n        }\n        return balance == 0;\n    }\n}","nanoTime":"2327076100"}
{"taskId":"Java/62","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.derivative(new ArrayList<>(Arrays.asList(3, 1, 2, 4, 5))).equals(Arrays.asList(1, 4, 12, 20)),\n                s.derivative(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(2, 6)),\n                s.derivative(new ArrayList<>(Arrays.asList(3, 2, 1))).equals(Arrays.asList(2, 2)),\n                s.derivative(new ArrayList<>(Arrays.asList(3, 2, 1, 0, 4))).equals(Arrays.asList(2, 2, 0, 16)),\n                s.derivative(List.of(1)).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3]))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        // Let's think step by step\n        // Input: xs, a list of integers representing coefficients of a polynomial\n        // Output: a list of integers representing coefficients of the derivative\n        // 1. Sequential: Initialize an empty list \"ans\" to store derivative coefficients and get n = xs.size() (guard against null).\n        // 2. Branch: If xs is null or n <= 1, return the empty list (derivative of constant or empty polynomial is empty).\n        // 3. Loop: For each index i from 1 to n-1, compute coeff = i * xs.get(i) and append to \"ans\".\n        // 4. Sequential: Return \"ans\".\n        // Write your code here\n        List<Integer> ans = new ArrayList<>();\n        if (xs == null) {\n            return ans;\n        }\n        int n = xs.size();\n        if (n <= 1) {\n            return ans;\n        }\n        for (int i = 1; i < n; i++) {\n            ans.add(i * xs.get(i));\n        }\n        return ans;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n        if (xs == null || xs.size() <= 1) {\n            return new ArrayList<>();\n        }\n        \n        List<Integer> ans = new ArrayList<>(xs.size() - 1);\n        for (int i = 1; i < xs.size(); i++) {\n            ans.add(i * xs.get(i));\n        }\n        return ans;\n    }\n}","nanoTime":"3156536800"}
{"taskId":"Java/63","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fibfib(2) == 1,\n                s.fibfib(1) == 0,\n                s.fibfib(5) == 4,\n                s.fibfib(8) == 24,\n                s.fibfib(10) == 81,\n                s.fibfib(12) == 274,\n                s.fibfib(14) == 927\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n     */\n    public int fibfib(int n) {\n        // Let's think step by step\n        // Input: n, an integer index\n        // Output: the n-th fibfib number as an integer\n        // Sequential structure:\n        // 1. Prepare base values and variables.\n        // Branch structure:\n        // 2. If n is 0 or 1, return 0; if n is 2, return 1.\n        // Loop structure:\n        // 3. For i from 3 to n, iteratively compute next = a + b + c and shift window.\n        // 4. Return the final computed value.\n        // Write your code here\n\n        // Branch: handle base cases\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        // Sequential: initialize the first three known values\n        int a = 0; // fibfib(0)\n        int b = 0; // fibfib(1)\n        int c = 1; // fibfib(2)\n\n        // Loop: compute up to n\n        for (int i = 3; i <= n; i++) {\n            int next = a + b + c;\n            a = b;\n            b = c;\n            c = next;\n        }\n\n        return c;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fibfib(int n) {\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n            return 1;\n        }\n\n        int a = 0, b = 0, c = 1;\n\n        for (int i = 3; i <= n; i++) {\n            int next = a + b + c;\n            a = b;\n            b = c;\n            c = next;\n        }\n\n        return c;\n    }\n}","nanoTime":"2847755000"}
{"taskId":"Java/64","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.vowelsCount(\"abcde\") == 2,\n                s.vowelsCount(\"Alone\") == 3,\n                s.vowelsCount(\"key\") == 2,\n                s.vowelsCount(\"bye\") == 1,\n                s.vowelsCount(\"keY\") == 2,\n                s.vowelsCount(\"bYe\") == 1,\n                s.vowelsCount(\"ACEDY\") == 3\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function vowelsCount which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowelsCount(\"abcde\")\n    2\n    >>> vowelsCount(\"ACEDY\")\n    3\n     */\n    public int vowelsCount(String s) {\n        // Let's think step by step\n        // Input: s, a string (word)\n        // Output: count, an integer\n        // 1. If s is null or empty, return 0. (branch)\n        // 2. Convert s to lowercase. (sequential)\n        // 3. Initialize count = 0. (sequential)\n        // 4. For each character c in s: (loop)\n        // 5.   If c is one of 'a','e','i','o','u', increment count. (branch)\n        // 6. After the loop, if the last character is 'y', increment count. (branch)\n        // 7. Return count.\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        String t = s.toLowerCase(Locale.ROOT);\n        int count = 0;\n        for (int i = 0; i < t.length(); i++) {\n            char c = t.charAt(i);\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                count++;\n            }\n        }\n        if (t.charAt(t.length() - 1) == 'y') {\n            count++;\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int vowelsCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        String lowerCaseString = s.toLowerCase(Locale.ROOT);\n        int count = 0;\n        for (char c : lowerCaseString.toCharArray()) {\n            if (isVowel(c)) {\n                count++;\n            }\n        }\n        if (lowerCaseString.endsWith(\"y\")) {\n            count++;\n        }\n        return count;\n    }\n\n    private boolean isVowel(char c) {\n        return \"aeiou\".indexOf(c) >= 0;\n    }\n}","nanoTime":"2675732900"}
{"taskId":"Java/65","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.circularShift(100, 2).equals(\"001\"),\n                s.circularShift(12, 2).equals(\"12\"),\n                s.circularShift(97, 8).equals(\"79\"),\n                s.circularShift(12, 1).equals(\"21\"),\n                s.circularShift(11, 101).equals(\"11\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circularShift(12, 1)\n    \"21\"\n    >>> circularShift(12, 2)\n    \"12\"\n     */\n    public String circularShift(int x, int shift) {\n        // Let's think step by step\n        // Input: x (integer), shift (integer)\n        // Output: String representing the digits of x circularly right-shifted by 'shift';\n        //         if shift > number of digits, return the digits reversed.\n        //\n        // Problem-solving process using three programming structures:\n        // 1) Sequential structure:\n        //    - Determine the sign of x and obtain its absolute value as a string of digits.\n        //    - Compute the number of digits n.\n        // 2) Branch structure:\n        //    - If n <= 1, return the digits as is (with sign if negative).\n        //    - Else if shift > n, reverse the digits and return (with sign if negative).\n        //    - Else perform a right circular shift by 'shift' positions.\n        // 3) Loop structure:\n        //    - Use a loop to build the reversed string when reversing is required.\n        //\n        // Write your code here\n        boolean negative = x < 0;\n        long abs = Math.abs((long) x); // avoid overflow for Integer.MIN_VALUE\n        String s = Long.toString(abs);\n        int n = s.length();\n\n        if (n <= 1) {\n            return negative ? \"-\" + s : s;\n        }\n\n        if (shift > n) {\n            // Reverse the digits using a loop\n            StringBuilder rev = new StringBuilder(n);\n            for (int i = n - 1; i >= 0; i--) {\n                rev.append(s.charAt(i));\n            }\n            String res = rev.toString();\n            return negative ? \"-\" + res : res;\n        } else {\n            // Right circular shift by 'shift' positions\n            int k = shift % n;\n            if (k < 0) {\n                // Handle negative shifts by converting to equivalent right shift\n                k = (k + n) % n;\n            }\n            String rotated;\n            if (k == 0) {\n                rotated = s;\n            } else {\n                rotated = s.substring(n - k) + s.substring(0, n - k);\n            }\n            return negative ? \"-\" + rotated : rotated;\n        }\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String circularShift(int x, int shift) {\n        boolean negative = x < 0;\n        String s = Long.toString(Math.abs((long) x));\n        int n = s.length();\n\n        if (n <= 1) {\n            return negative ? \"-\" + s : s;\n        }\n\n        if (shift > n) {\n            return negative ? \"-\" + reverseString(s) : reverseString(s);\n        } else {\n            return negative ? \"-\" + rotateString(s, shift) : rotateString(s, shift);\n        }\n    }\n\n    private String reverseString(String s) {\n        return new StringBuilder(s).reverse().toString();\n    }\n\n    private String rotateString(String s, int shift) {\n        int k = shift % s.length();\n        return k == 0 ? s : s.substring(s.length() - k) + s.substring(0, s.length() - k);\n    }\n}","nanoTime":"3471856700"}
{"taskId":"Java/66","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.digitSum(\"\") == 0,\n                s.digitSum(\"abAB\") == 131,\n                s.digitSum(\"abcCd\") == 67,\n                s.digitSum(\"helloE\") == 69,\n                s.digitSum(\"woArBld\") == 131,\n                s.digitSum(\"aAaaaXa\") == 153,\n                s.digitSum(\" How are yOu?\") == 151,\n                s.digitSum(\"You arE Very Smart\") == 327\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n     */\n    public int digitSum(String s) {\n        // Let's think step by step\n        // Input: s, a string\n        // Output: sum, an integer\n        // 1. Initialize sum to 0. (sequential)\n        // 2. If s is null or empty, return 0. (branch)\n        // 3. Loop through each character in s: (loop)\n        //    - If the character is an uppercase letter 'A' to 'Z', add its ASCII value to sum. (branch)\n        // 4. Return sum. (sequential)\n        int sum = 0;\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c >= 'A' && c <= 'Z') {\n                sum += (int) c;\n            }\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int digitSum(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        return s.chars()\n                 .filter(Character::isUpperCase)\n                 .sum();\n    }\n}","nanoTime":"1341925100"}
{"taskId":"Java/67","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fruitDistribution(\"5 apples and 6 oranges\",19) == 8,\n                s.fruitDistribution(\"5 apples and 6 oranges\",21) == 10,\n                s.fruitDistribution(\"0 apples and 1 oranges\",3) == 2,\n                s.fruitDistribution(\"1 apples and 0 oranges\",3) == 2,\n                s.fruitDistribution(\"2 apples and 3 oranges\",100) == 95,\n                s.fruitDistribution(\"2 apples and 3 oranges\",5) == 0,\n                s.fruitDistribution(\"1 apples and 100 oranges\",120) == 19\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    In this task, you will be given a string that represents a number of apples and oranges\n    that are distributed in a basket of fruit this basket contains\n    apples, oranges, and mango fruits. Given the string that represents the total number of\n    the oranges and apples and an integer that represent the total number of the fruits\n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n     */\n    public int fruitDistribution(String s, int n) {\n        // Let's think step by step\n        // Input: s, a string containing counts for apples and oranges; n, total fruits.\n        // Output: number of mango fruits.\n        // Sequential steps:\n        // 1. Initialize variables to capture the two numbers (apples and oranges).\n        // 2. Loop through the string characters to parse contiguous digits into integers.\n        // 3. Branch on whether the current character is a digit to build numbers or finalize them.\n        // 4. After the loop, handle any trailing number not yet finalized.\n        // 5. Compute mangoes as n - apples - oranges.\n        // 6. Return the result.\n\n        int apples = 0;\n        int oranges = 0;\n        int current = 0;\n        boolean inNumber = false;\n        int countFound = 0;\n\n        // Loop through characters to extract numbers\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                // Branch: we are within a number\n                inNumber = true;\n                current = current * 10 + (c - '0');\n            } else {\n                // Branch: non-digit ends a number if we were building one\n                if (inNumber) {\n                    if (countFound == 0) {\n                        apples = current;\n                    } else if (countFound == 1) {\n                        oranges = current;\n                    }\n                    countFound++;\n                    current = 0;\n                    inNumber = false;\n                    // Optional: could break after finding two numbers\n                }\n            }\n        }\n\n        // Handle trailing number after loop ends\n        if (inNumber) {\n            if (countFound == 0) {\n                apples = current;\n            } else if (countFound == 1) {\n                oranges = current;\n            }\n            countFound++;\n        }\n\n        // Compute and return result\n        int mangoes = n - apples - oranges;\n        return mangoes;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fruitDistribution(String s, int n) {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        Matcher matcher = pattern.matcher(s);\n        \n        int apples = 0;\n        int oranges = 0;\n        int countFound = 0;\n\n        while (matcher.find()) {\n            if (countFound == 0) {\n                apples = Integer.parseInt(matcher.group());\n            } else if (countFound == 1) {\n                oranges = Integer.parseInt(matcher.group());\n            }\n            countFound++;\n        }\n\n        return n - apples - oranges;\n    }\n}","nanoTime":"2089437500"}
{"taskId":"Java/68","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.pluck(new ArrayList<>(Arrays.asList(4, 2, 3))).equals(Arrays.asList(2, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(2, 1)),\n                s.pluck(new ArrayList<>(List.of())).equals(List.of()),\n                s.pluck(new ArrayList<>(Arrays.asList(5, 0, 3, 0, 4, 2))).equals(Arrays.asList(0, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(1, 2, 3, 0, 5, 3))).equals(Arrays.asList(0, 3)),\n                s.pluck(new ArrayList<>(Arrays.asList(5, 4, 8, 4, 8))).equals(Arrays.asList(4, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(7, 6, 7, 1))).equals(Arrays.asList(6, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(7, 9, 7, 1))).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 3:\n        Input: []\n        Output: []\n\n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of non-negative integers\n        // Output: a list [smallest_even_value, its index] or [] if none exists\n        // Sequential structure:\n        // 1. If arr is null or empty, return [].\n        // 2. Initialize minVal to +infinity (Integer.MAX_VALUE) and minIdx to -1.\n        // Loop structure:\n        // 3. For i from 0 to arr.size()-1:\n        //    a. Read val = arr.get(i).\n        // Branch structure:\n        //    b. If val is even (val % 2 == 0):\n        //       i. If val < minVal, update minVal = val and minIdx = i.\n        // Branch structure:\n        // 4. After the loop, if minIdx == -1, return [] (no even values found).\n        // 5. Else return [minVal, minIdx].\n\n        if (arr == null || arr.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int minVal = Integer.MAX_VALUE;\n        int minIdx = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int val = arr.get(i);\n            if (val % 2 == 0) {\n                if (val < minVal) {\n                    minVal = val;\n                    minIdx = i;\n                }\n            }\n        }\n\n        if (minIdx == -1) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> result = new ArrayList<>(2);\n        result.add(minVal);\n        result.add(minIdx);\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        int minVal = Integer.MAX_VALUE;\n        int minIdx = -1;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int val = arr.get(i);\n            if (val % 2 == 0 && val < minVal) {\n                minVal = val;\n                minIdx = i;\n            }\n        }\n\n        if (minIdx == -1) {\n            return new ArrayList<>();\n        }\n\n        return List.of(minVal, minIdx);\n    }\n}","nanoTime":"2480104100"}
{"taskId":"Java/69","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.search(new ArrayList<>(Arrays.asList(5, 5, 5, 5, 1))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(4, 1, 4, 1, 4, 4))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(3, 3))) == -1,\n                s.search(new ArrayList<>(Arrays.asList(8, 8, 8, 8, 8, 8, 8, 8))) == 8,\n                s.search(new ArrayList<>(Arrays.asList(2, 3, 3, 2, 2))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(3, 2, 8, 2))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(8, 8, 3, 6, 5, 6, 4))) == -1,\n                s.search(new ArrayList<>(Arrays.asList(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(1, 9, 10, 1, 3))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10))) == 5,\n                s.search(new ArrayList<>(List.of(1))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8))) == -1,\n                s.search(new ArrayList<>(List.of(10))) == -1,\n                s.search(new ArrayList<>(Arrays.asList(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(3, 10, 10, 9, 2))) == -1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n    zero, and has a frequency greater than or equal to the value of the integer itself.\n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n        search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n        search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a non-empty list of positive integers\n        // Output: the greatest integer x > 0 such that frequency(x) >= x, else -1\n        // Sequential structure:\n        // 1. Create a frequency map to count occurrences of each number.\n        // 2. Initialize result to -1 (default if no valid number exists).\n        // Loop structure:\n        // 3. Iterate over lst to populate the frequency map.\n        // 4. Iterate over the entries of the frequency map to evaluate the condition.\n        // Branch structure:\n        // 5. If count >= number and number > result, update result with this number.\n        // 6. After processing all entries, return result.\n\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int num : lst) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        int result = -1;\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n            int num = entry.getKey();\n            int count = entry.getValue();\n            if (num > 0 && count >= num && num > result) {\n                result = num;\n            }\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.merge(num, 1, Integer::sum);\n        }\n\n        int maxValidNumber = -1;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int number = entry.getKey();\n            int frequency = entry.getValue();\n            if (frequency >= number) {\n                maxValidNumber = Math.max(maxValidNumber, number);\n            }\n        }\n\n        return maxValidNumber;\n    }\n}","nanoTime":"2044933900"}
{"taskId":"Java/70","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.strangeSortList(new ArrayList<>(Arrays.asList(1, 2, 3, 4))).equals(Arrays.asList(1, 4, 2, 3)),\n                s.strangeSortList(new ArrayList<>(Arrays.asList(5, 6, 7, 8, 9))).equals(Arrays.asList(5, 9, 6, 8, 7)),\n                s.strangeSortList(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5))).equals(Arrays.asList(1, 5, 2, 4, 3)),\n                s.strangeSortList(new ArrayList<>(Arrays.asList(5, 6, 7, 8, 9, 1))).equals(Arrays.asList(1, 9, 5, 8, 6, 7)),\n                s.strangeSortList(new ArrayList<>(Arrays.asList(5, 5, 5, 5))).equals(Arrays.asList(5, 5, 5, 5)),\n                s.strangeSortList(new ArrayList<>(List.of())).equals(List.of()),\n                s.strangeSortList(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8))).equals(Arrays.asList(1, 8, 2, 7, 3, 6, 4, 5)),\n                s.strangeSortList(new ArrayList<>(Arrays.asList(0, 2, 2, 2, 5, 5, -5, -5))).equals(Arrays.asList(-5, 5, -5, 5, 0, 2, 2, 2)),\n                s.strangeSortList(new ArrayList<>(List.of(111111))).equals(List.of(111111))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strangeSortList(Arrays.asList(1, 2, 3, 4)) == Arrays.asList(1, 4, 2, 3)\n    strangeSortList(Arrays.asList(5, 5, 5, 5)) == Arrays.asList(5, 5, 5, 5)\n    strangeSortList(Arrays.asList()) == Arrays.asList()\n     */\n    public List<Integer> strangeSortList(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a List<Integer>\n        // Output: result, a List<Integer> in strange order\n        // Sequential structure:\n        // 1. If lst is null, return an empty list.\n        // 2. Copy lst into a new list 'sorted'.\n        // 3. Sort 'sorted' in non-decreasing order.\n        // 4. Initialize two pointers: i at start, j at end.\n        // 5. Initialize a boolean flag minTurn = true to alternate picks.\n        // Loop structure:\n        // 6. While i <= j:\n        //    a. If minTurn, pick sorted.get(i) and i++.\n        //    b. Else, pick sorted.get(j) and j--.\n        //    c. Toggle minTurn.\n        // Branch structure:\n        // 7. The branch is the decision based on minTurn inside the loop.\n        // 8. Return the result list after the loop.\n\n        // Write your code here\n        if (lst == null) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> sorted = new ArrayList<>(lst);\n        Collections.sort(sorted);\n\n        List<Integer> result = new ArrayList<>(sorted.size());\n        int i = 0;\n        int j = sorted.size() - 1;\n        boolean minTurn = true;\n\n        while (i <= j) {\n            if (minTurn) {\n                result.add(sorted.get(i));\n                i++;\n            } else {\n                result.add(sorted.get(j));\n                j--;\n            }\n            minTurn = !minTurn;\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> strangeSortList(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> sorted = new ArrayList<>(lst);\n        Collections.sort(sorted);\n\n        List<Integer> result = new ArrayList<>(sorted.size());\n        int left = 0;\n        int right = sorted.size() - 1;\n        boolean isMinTurn = true;\n\n        while (left <= right) {\n            if (isMinTurn) {\n                result.add(sorted.get(left++));\n            } else {\n                result.add(sorted.get(right--));\n            }\n            isMinTurn = !isMinTurn;\n        }\n\n        return result;\n    }\n}","nanoTime":"3604789500"}
{"taskId":"Java/71","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.triangleArea(3, 4, 5) == 6.00,\n                s.triangleArea(1, 2, 10) == -1,\n                s.triangleArea(4, 8, 5) == 8.18,\n                s.triangleArea(2, 2, 2) == 1.73,\n                s.triangleArea(1, 2, 3) == -1,\n                s.triangleArea(10, 5, 7) == 16.25,\n                s.triangleArea(2, 6, 3) == -1,\n                s.triangleArea(1, 1, 1) == 0.43,\n                s.triangleArea(2, 2, 10) == -1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangleArea(3, 4, 5) == 6.00\n    triangleArea(1, 2, 10) == -1\n     */\n    public double triangleArea(double a, double b, double c) {\n        // Let's think step by step\n        // Input: a, b, c - doubles\n        // Output: area rounded to 2 decimals as double, or -1 if invalid\n        // 1. Sequential: Place sides into an array for looping.\n        // 2. Loop: Ensure all sides are positive.\n        // 3. Loop: Check triangle inequalities: each side less than the sum of the other two.\n        // 4. Branch: If any check fails, return -1.\n        // 5. Sequential: Compute semiperimeter s.\n        // 6. Sequential: Compute area using Heron's formula.\n        // 7. Sequential: Round area to 2 decimal places.\n        // 8. Return the rounded area.\n\n        double[] sides = new double[] {a, b, c};\n\n        // Loop: Check positivity of sides\n        for (int i = 0; i < 3; i++) {\n            if (sides[i] <= 0) {\n                return -1;\n            }\n        }\n\n        // Loop: Check triangle inequality for all three sides\n        for (int i = 0; i < 3; i++) {\n            double sumOther = sides[(i + 1) % 3] + sides[(i + 2) % 3];\n            if (!(sides[i] < sumOther)) {\n                return -1;\n            }\n        }\n\n        // Sequential: Compute area using Heron's formula\n        double s = (a + b + c) / 2.0;\n        double radicand = s * (s - a) * (s - b) * (s - c);\n        if (radicand < 0) {\n            // Numerical guard\n            return -1;\n        }\n        double area = Math.sqrt(radicand);\n\n        // Sequential: Round to 2 decimal places\n        double rounded = Math.round(area * 100.0) / 100.0;\n        return rounded;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double triangleArea(double a, double b, double c) {\n        if (!isValidTriangle(a, b, c)) {\n            return -1;\n        }\n        double area = calculateArea(a, b, c);\n        return roundToTwoDecimalPlaces(area);\n    }\n\n    private boolean isValidTriangle(double a, double b, double c) {\n        return a > 0 && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a;\n    }\n\n    private double calculateArea(double a, double b, double c) {\n        double s = (a + b + c) / 2.0;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    private double roundToTwoDecimalPlaces(double value) {\n        return Math.round(value * 100.0) / 100.0;\n    }\n}","nanoTime":"3662516900"}
{"taskId":"Java/72","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.willItFly(new ArrayList<>(Arrays.asList(3, 2, 3)), 9),\n                !s.willItFly(new ArrayList<>(Arrays.asList(1, 2)), 5),\n                s.willItFly(new ArrayList<>(List.of(3)), 5),\n                !s.willItFly(new ArrayList<>(Arrays.asList(3, 2, 3)), 1),\n                !s.willItFly(new ArrayList<>(Arrays.asList(1, 2, 3)), 6),\n                s.willItFly(new ArrayList<>(List.of(5)), 5)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    willItFly(Arrays.asList(1, 2), 5) -> false\n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    willItFly(Arrays.asList(3, 2, 3), 1) -> false\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    willItFly(Arrays.asList(3, 2, 3), 9) -> true\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    willItFly(Arrays.asList(3), 5) -> true\n    # 3 is less than the maximum possible weight, and it's balanced.\n     */\n    public boolean willItFly(List<Integer> q, int w) {\n        // Let's think step by step\n        // Input: q, a list of integers; w, an integer (max weight)\n        // Output: boolean indicating if the object will fly\n        // Sequential structure:\n        // 1. If q is null, return false (invalid input).\n        // 2. Get n = q.size().\n        // Loop structure:\n        // 3. Check if q is a palindrome using two pointers:\n        //    for i from 0 to n/2 - 1:\n        //       if q[i] != q[n-1-i], it's unbalanced -> return false.\n        // Branch structure:\n        // 4. If it's balanced, compute the sum of elements.\n        // Loop structure:\n        // 5. Sum all elements in q.\n        // Branch structure:\n        // 6. If sum <= w, return true; otherwise, return false.\n\n        if (q == null) {\n            return false;\n        }\n\n        int n = q.size();\n\n        // Check palindromic (balanced)\n        for (int i = 0; i < n / 2; i++) {\n            Integer left = q.get(i);\n            Integer right = q.get(n - 1 - i);\n            if (left == null || right == null || !left.equals(right)) {\n                return false;\n            }\n        }\n\n        // Compute sum\n        long sum = 0L;\n        for (Integer val : q) {\n            if (val != null) {\n                sum += val;\n            } else {\n                // Treat null as 0 to avoid NPE; adjust if problem requires otherwise\n                // sum += 0;\n            }\n        }\n\n        return sum <= (long) w;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean willItFly(List<Integer> q, int w) {\n        if (q == null || q.isEmpty()) {\n            return false;\n        }\n\n        int n = q.size();\n        if (!isPalindrome(q, n)) {\n            return false;\n        }\n\n        long sum = calculateSum(q);\n        return sum <= w;\n    }\n\n    private boolean isPalindrome(List<Integer> q, int n) {\n        for (int i = 0; i < n / 2; i++) {\n            if (!q.get(i).equals(q.get(n - 1 - i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private long calculateSum(List<Integer> q) {\n        long sum = 0;\n        for (Integer val : q) {\n            sum += (val != null) ? val : 0;\n        }\n        return sum;\n    }\n}","nanoTime":"3059145200"}
{"taskId":"Java/73","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))) == 4,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 3, 2, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 4, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 4, 4, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 2, 1))) == 0,\n                s.smallestChange(new ArrayList<>(Arrays.asList(3, 1, 1, 3))) == 0,\n                s.smallestChange(new ArrayList<>(List.of(1))) == 0,\n                s.smallestChange(new ArrayList<>(Arrays.asList(0, 1))) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallestChange(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n    smallestChange(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n    smallestChange(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallestChange(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of integers\n        // Output: minimum number of changes to make arr palindromic\n        // Sequential structure:\n        // 1. Handle edge cases (null or size <= 1) -> return 0.\n        // 2. Initialize two pointers i = 0 and j = arr.size() - 1.\n        // 3. Initialize a counter 'changes' = 0.\n        // Loop structure:\n        // 4. While i < j:\n        //    Branch structure:\n        //    a. If arr[i] != arr[j], increment 'changes' by 1 because one change can fix the pair.\n        //    b. Move pointers inward: i++, j--.\n        // 5. Return 'changes'.\n        if (arr == null || arr.size() <= 1) {\n            return 0;\n        }\n        int i = 0, j = arr.size() - 1;\n        int changes = 0;\n        while (i < j) {\n            if (!Objects.equals(arr.get(i), arr.get(j))) {\n                changes++;\n            }\n            i++;\n            j--;\n        }\n        return changes;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallestChange(List<Integer> arr) {\n        if (arr == null || arr.size() <= 1) {\n            return 0;\n        }\n        \n        int changes = 0;\n        int size = arr.size();\n        for (int i = 0; i < size / 2; i++) {\n            if (!Objects.equals(arr.get(i), arr.get(size - 1 - i))) {\n                changes++;\n            }\n        }\n        return changes;\n    }\n}","nanoTime":"1837686000"}
{"taskId":"Java/74","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.totalMatch(new ArrayList<>(List.of()), new ArrayList<>(List.of())).equals(List.of()),\n                s.totalMatch(new ArrayList<>(Arrays.asList(\"hi\", \"admin\")), new ArrayList<>(Arrays.asList(\"hi\", \"hi\"))).equals(Arrays.asList(\"hi\", \"hi\")),\n                s.totalMatch(new ArrayList<>(Arrays.asList(\"hi\", \"admin\")), new ArrayList<>(Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\"))).equals(Arrays.asList(\"hi\", \"admin\")),\n                s.totalMatch(new ArrayList<>(List.of(\"4\")), new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"))).equals(List.of(\"4\")),\n                s.totalMatch(new ArrayList<>(Arrays.asList(\"hi\", \"admin\")), new ArrayList<>(Arrays.asList(\"hI\", \"Hi\"))).equals(Arrays.asList(\"hI\", \"Hi\")),\n                s.totalMatch(new ArrayList<>(Arrays.asList(\"hi\", \"admin\")), new ArrayList<>(Arrays.asList(\"hI\", \"hi\", \"hi\"))).equals(Arrays.asList(\"hI\", \"hi\", \"hi\")),\n                s.totalMatch(new ArrayList<>(Arrays.asList(\"hi\", \"admin\")), new ArrayList<>(Arrays.asList(\"hI\", \"hi\", \"hii\"))).equals(Arrays.asList(\"hi\", \"admin\")),\n                s.totalMatch(new ArrayList<>(List.of()), new ArrayList<>(List.of(\"this\"))).equals(List.of()),\n                s.totalMatch(new ArrayList<>(List.of(\"this\")), new ArrayList<>(List.of())).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    totalMatch(Arrays.asList(), Arrays.asList()) -> []\n    totalMatch(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"Hi\")) -> [\"hI\", \"Hi\"]\n    totalMatch(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hi\", \"hi\", \"admin\", \"project\")) -> [\"hi\", \"admin\"]\n    totalMatch(Arrays.asList(\"hi\", \"admin\"), Arrays.asList(\"hI\", \"hi\", \"hi\")) -> [\"hI\", \"hi\", \"hi\"]\n    totalMatch(Arrays.asList(\"4\"), Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\")) -> [\"4\"]\n     */\n    public List<String> totalMatch(List<String> lst1, List<String> lst2) {\n        // Let's think step by step\n        // Input: lst1, lst2 - two lists of strings\n        // Output: the list whose total character count is less; if equal, return lst1\n        // Sequential: initialize sums and handle potential null lists\n        if (lst1 == null) lst1 = Collections.emptyList();\n        if (lst2 == null) lst2 = Collections.emptyList();\n        int sum1 = 0;\n        int sum2 = 0;\n        // Loop: accumulate total lengths of strings in each list\n        for (String s : lst1) {\n            if (s != null) {\n                sum1 += s.length();\n            }\n        }\n        for (String s : lst2) {\n            if (s != null) {\n                sum2 += s.length();\n            }\n        }\n        // Branch: compare totals and decide which list to return\n        if (sum1 <= sum2) {\n            return lst1;\n        } else {\n            return lst2;\n        }\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> totalMatch(List<String> lst1, List<String> lst2) {\n        lst1 = (lst1 == null) ? Collections.emptyList() : lst1;\n        lst2 = (lst2 == null) ? Collections.emptyList() : lst2;\n\n        int sum1 = calculateTotalLength(lst1);\n        int sum2 = calculateTotalLength(lst2);\n\n        return (sum1 <= sum2) ? lst1 : lst2;\n    }\n\n    private int calculateTotalLength(List<String> list) {\n        return list.stream()\n                   .filter(Objects::nonNull)\n                   .mapToInt(String::length)\n                   .sum();\n    }\n}","nanoTime":"4513369400"}
{"taskId":"Java/75","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isMultiplyPrime(5),\n                s.isMultiplyPrime(30),\n                s.isMultiplyPrime(8),\n                !s.isMultiplyPrime(10),\n                s.isMultiplyPrime(125),\n                s.isMultiplyPrime(3 * 5 * 7),\n                !s.isMultiplyPrime(3 * 6 * 7),\n                !s.isMultiplyPrime(9 * 9 * 9),\n                !s.isMultiplyPrime(11 * 9 * 9),\n                s.isMultiplyPrime(11 * 13 * 7)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100.\n    Example:\n    isMultiplyPrime(30) == true\n    30 = 2 * 3 * 5\n     */\n    public boolean isMultiplyPrime(int a) {\n        // Let's think step by step\n        // Input: a, an integer less than 100\n        // Output: boolean indicating if a is a product of exactly three prime numbers (with multiplicity)\n        // Sequential structure:\n        // 1. Initialize count of prime factors to 0 and a working copy n = a.\n        // Branch structure:\n        // 2. If a < 2, return false (cannot be a product of primes).\n        // Loop structure:\n        // 3. For i from 2 up to sqrt(n), repeatedly divide n by i while divisible, incrementing count.\n        // 4. After the loop, if n > 1, it contributes one prime factor; increment count.\n        // Branch structure:\n        // 5. Return true if count == 3, else false.\n\n        if (a < 2) {\n            return false;\n        }\n        int n = a;\n        int count = 0;\n\n        for (int i = 2; i * i <= n; i++) {\n            while (n % i == 0) {\n                count++;\n                if (count > 3) {\n                    return false; // early exit if more than 3 prime factors\n                }\n                n /= i;\n            }\n        }\n\n        if (n > 1) {\n            count++;\n        }\n\n        return count == 3;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isMultiplyPrime(int a) {\n        if (a < 2) {\n            return false;\n        }\n        \n        int count = 0;\n        int n = a;\n\n        for (int i = 2; i * i <= n; i++) {\n            while (n % i == 0) {\n                count++;\n                n /= i;\n                if (count > 3) {\n                    return false;\n                }\n            }\n        }\n\n        return count + (n > 1 ? 1 : 0) == 3;\n    }\n}","nanoTime":"1902415300"}
{"taskId":"Java/76","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isSimplePower(1, 4),\n                s.isSimplePower(2, 2),\n                s.isSimplePower(8, 2),\n                !s.isSimplePower(3, 2),\n                !s.isSimplePower(3, 1),\n                !s.isSimplePower(5, 3),\n                s.isSimplePower(16, 2),\n                !s.isSimplePower(143214, 16),\n                s.isSimplePower(4, 2),\n                s.isSimplePower(9, 3),\n                s.isSimplePower(16, 4),\n                !s.isSimplePower(24, 2),\n                !s.isSimplePower(128, 4),\n                !s.isSimplePower(12, 6),\n                s.isSimplePower(1, 1),\n                s.isSimplePower(1, 12)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    isSimplePower(1, 4) => true\n    isSimplePower(2, 2) => true\n    isSimplePower(8, 2) => true\n    isSimplePower(3, 2) => false\n    isSimplePower(3, 1) => false\n    isSimplePower(5, 3) => false\n     */\n    public boolean isSimplePower(int x, int n) {\n        // Let's think step by step\n        // Input: x and n as integers\n        // Output: true if exists integer k >= 0 such that n^k == x, else false\n        // Sequential structure:\n        // 1) Handle straightforward edge cases for n and x (0, 1, -1).\n        // 2) For the general case, iteratively reduce x by dividing by n.\n        // Branch structure:\n        // - If x == 1 -> true (n^0 = 1)\n        // - If n == 1 -> true only when x == 1\n        // - If n == 0 -> true only when x == 0 (since 0^k = 0 for k>=1)\n        // - If n == -1 -> true when x is 1 or -1\n        // - If x == 0 and n != 0 -> false\n        // - If x < 0 and n > 0 -> false (no positive base power yields negative)\n        // Loop structure:\n        // - While x is divisible by n, divide x by n.\n        // - After the loop, if x reduced to 1, then it is a simple power.\n\n        // Edge cases\n        if (x == 1) return true;\n        if (n == 1) return x == 1;\n        if (n == 0) return x == 0;\n        if (n == -1) return x == 1 || x == -1;\n        if (x == 0) return false;\n        if (x < 0 && n > 0) return false;\n\n        // Iteratively divide x by n\n        while (x % n == 0) {\n            x /= n;\n            if (x == 1) return true;\n        }\n        return x == 1;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isSimplePower(int x, int n) {\n        if (isEdgeCase(x, n)) return handleEdgeCases(x, n);\n        return checkSimplePower(x, n);\n    }\n\n    private boolean isEdgeCase(int x, int n) {\n        return x == 1 || n == 1 || n == 0 || n == -1 || x == 0 || (x < 0 && n > 0);\n    }\n\n    private boolean handleEdgeCases(int x, int n) {\n        if (x == 1) return true;\n        if (n == 1) return x == 1;\n        if (n == 0) return x == 0;\n        if (n == -1) return x == 1 || x == -1;\n        if (x == 0) return false;\n        return false;\n    }\n\n    private boolean checkSimplePower(int x, int n) {\n        while (x % n == 0) {\n            x /= n;\n        }\n        return x == 1;\n    }\n}","nanoTime":"4698464500"}
{"taskId":"Java/77","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.iscube(1),\n                !s.iscube(2),\n                s.iscube(-1),\n                s.iscube(64),\n                !s.iscube(180),\n                s.iscube(1000),\n                s.iscube(0),\n                !s.iscube(1729)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an integer a and returns true\n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> true\n    iscube(2) ==> false\n    iscube(-1) ==> true\n    iscube(64) ==> true\n    iscube(0) ==> true\n    iscube(180) ==> false\n     */\n    public boolean iscube(int a) {\n        // Let's think step by step\n        // Input: a, an integer\n        // Output: true if a is a perfect cube of some integer, else false\n        // Sequential structure:\n        // 1. Set search bounds to cover all possible 32-bit integer cube roots: [-1291, 1291].\n        // Loop structure:\n        // 2. Use binary search within these bounds to find an integer whose cube equals a.\n        // Branch structure:\n        // 3. If mid^3 == a, return true; if mid^3 < a, move left bound; else move right bound.\n        // 4. If loop finishes without finding an exact match, return false.\n\n        int left = -1291;\n        int right = 1291;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            long cube = (long) mid * mid * mid;\n\n            if (cube == a) {\n                return true;\n            } else if (cube < a) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean iscube(int a) {\n        if (a < 0) {\n            a = -a;\n        }\n        int left = 0;\n        int right = (int) Math.cbrt(a) + 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            long cube = (long) mid * mid * mid;\n\n            if (cube == a) {\n                return true;\n            } else if (cube < a) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n}","nanoTime":"3324957600"}
{"taskId":"Java/78","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.hexKey(\"AB\") == 1,\n                s.hexKey(\"1077E\") == 2,\n                s.hexKey(\"ABED1A33\") == 4,\n                s.hexKey(\"2020\") == 2,\n                s.hexKey(\"123456789ABCDEF0\") == 6,\n                s.hexKey(\"112233445566778899AABBCCDDEEFF00\") == 12,\n                s.hexKey(\"\") == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You have been tasked to write a function that receives\n    a hexadecimal number as a string and counts the number of hexadecimal\n    digits that are primes (prime number, or a prime, is a natural number\n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7,\n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string,\n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n     */\n    public int hexKey(String num) {\n        // Let's think step by step\n        // Input: num, a hexadecimal string (possibly empty)\n        // Output: count, number of prime hex digits\n        // Sequential structure:\n        // 1) Initialize counter to 0.\n        // 2) Define which hex digits are prime: 2, 3, 5, 7, B, D.\n        // Loop structure:\n        // 3) For each character in the string:\n        // Branch structure:\n        //    a) If the character is one of the prime hex digits, increment counter.\n        // 4) Return the counter.\n\n        if (num == null || num.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        for (int i = 0; i < num.length(); i++) {\n            char c = num.charAt(i);\n            if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n                count++;\n            }\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int hexKey(String num) {\n        if (num == null || num.isEmpty()) {\n            return 0;\n        }\n\n        Set<Character> primeHexDigits = new HashSet<>(Set.of('2', '3', '5', '7', 'B', 'D'));\n        int count = 0;\n\n        for (char c : num.toCharArray()) {\n            if (primeHexDigits.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","nanoTime":"1799126800"}
{"taskId":"Java/79","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.decimalToBinary(0), \"db0db\"),\n                Objects.equals(s.decimalToBinary(32), \"db100000db\"),\n                Objects.equals(s.decimalToBinary(103), \"db1100111db\"),\n                Objects.equals(s.decimalToBinary(15), \"db1111db\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimalToBinary(15)   // returns \"db1111db\"\n    decimalToBinary(32)   // returns \"db100000db\"\n     */\n    public String decimalToBinary(int decimal) {\n        // Let's think step by step\n        // Input: decimal, an integer\n        // Output: a string \"db\" + binary_representation + \"db\"\n        // Sequential structure:\n        // 1. If decimal is 0, return \"db0db\".\n        // 2. Otherwise, build the binary representation.\n        // Branch structure:\n        // - If decimal == 0 -> return \"db0db\".\n        // - Else if decimal > 0 -> compute binary by repeated division by 2.\n        // - Else (decimal < 0) -> use two's complement representation via library.\n        // Loop structure:\n        // - While n > 0: append (n % 2) as '0' or '1', then divide n by 2; finally reverse the bits.\n        \n        if (decimal == 0) {\n            return \"db0db\";\n        }\n\n        String body;\n        if (decimal > 0) {\n            StringBuilder bits = new StringBuilder();\n            int n = decimal;\n            while (n > 0) {\n                bits.append((n & 1) == 1 ? '1' : '0');\n                n >>>= 1; // shift right; for positive numbers acts as division by 2\n            }\n            body = bits.reverse().toString();\n        } else {\n            // For negative numbers, use two's complement binary string\n            body = Integer.toBinaryString(decimal);\n        }\n\n        return \"db\" + body + \"db\";\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String decimalToBinary(int decimal) {\n        if (decimal == 0) {\n            return \"db0db\";\n        }\n\n        String body = (decimal > 0) ? convertPositiveToBinary(decimal) : convertNegativeToBinary(decimal);\n        return \"db\" + body + \"db\";\n    }\n\n    private String convertPositiveToBinary(int decimal) {\n        StringBuilder bits = new StringBuilder();\n        while (decimal > 0) {\n            bits.append((decimal & 1) == 1 ? '1' : '0');\n            decimal >>>= 1;\n        }\n        return bits.reverse().toString();\n    }\n\n    private String convertNegativeToBinary(int decimal) {\n        return Integer.toBinaryString(decimal);\n    }\n}","nanoTime":"3478813400"}
{"taskId":"Java/80","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isHappy(\"a\"),\n                !s.isHappy(\"aa\"),\n                s.isHappy(\"abcd\"),\n                !s.isHappy(\"aabb\"),\n                s.isHappy(\"adb\"),\n                !s.isHappy(\"xyy\"),\n                s.isHappy(\"iopaxpoi\"),\n                !s.isHappy(\"iopaxioi\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    isHappy(a) => false\n    isHappy(aa) => false\n    isHappy(abcd) => true\n    isHappy(aabb) => false\n    isHappy(adb) => true\n    isHappy(xyy) => false\n     */\n    public boolean isHappy(String s) {\n        // Let's think step by step\n        // Input: s, a string\n        // Output: boolean indicating if s is \"happy\"\n        // Sequential:\n        // 1) Validate input length must be at least 3.\n        // 2) Iterate over all windows of size 3.\n        // Branch:\n        // - If s is null or length < 3, return false.\n        // - For each window of 3 chars, if any two are equal, return false immediately.\n        // Loop:\n        // - For i from 0 to n - 3, check characters at i, i+1, i+2.\n        // - If the loop finishes without finding duplicates, return true.\n\n        // 1) Validate input\n        if (s == null || s.length() < 3) {\n            return false;\n        }\n\n        int n = s.length();\n        // 2) Check every consecutive triplet\n        for (int i = 0; i <= n - 3; i++) {\n            char a = s.charAt(i);\n            char b = s.charAt(i + 1);\n            char c = s.charAt(i + 2);\n            if (a == b || b == c || a == c) {\n                return false;\n            }\n        }\n\n        // All triplets are distinct\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isHappy(String s) {\n        if (s == null || s.length() < 3) {\n            return false;\n        }\n\n        for (int i = 0; i <= s.length() - 3; i++) {\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i) == s.charAt(i + 2)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","nanoTime":"2534643500"}
{"taskId":"Java/81","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.numericalLetterGrade(new ArrayList<>(Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5))).equals(Arrays.asList(\"A+\", \"B\", \"C-\", \"C\", \"A-\")),\n                s.numericalLetterGrade(new ArrayList<>(List.of(1.2))).equals(List.of(\"D+\")),\n                s.numericalLetterGrade(new ArrayList<>(List.of(0.5))).equals(List.of(\"D-\")),\n                s.numericalLetterGrade(new ArrayList<>(List.of(0.0))).equals(List.of(\"E\")),\n                s.numericalLetterGrade(new ArrayList<>(Arrays.asList(1.0, 0.3, 1.5, 2.8, 3.3))).equals(Arrays.asList(\"D\", \"D-\", \"C-\", \"B\", \"B+\")),\n                s.numericalLetterGrade(new ArrayList<>(Arrays.asList(0.0, 0.7))).equals(Arrays.asList(\"E\", \"D-\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A\n            > 3.3                A-\n            > 3.0                B+\n            > 2.7                B\n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+\n            > 0.7                D\n            > 0.0                D-\n              0.0                E\n\n\n    Example:\n    numericalLetterGrade(Arrays.asList(4.0, 3, 1.7, 2, 3.5)) ==> [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n     */\n    public List<String> numericalLetterGrade(List<Double> grades) {\n        // Let's think step by step\n        // Input: grades, a list of Double GPAs\n        // Output: a list of corresponding letter grades (List<String>)\n        // Sequential:\n        // 1) Initialize an output list to hold letter grades.\n        // Loop:\n        // 2) For each GPA in the input list, determine its letter via conditional checks.\n        // Branch:\n        // 3) Use an if-else chain following the table:\n        //    - exactly 4.0 -> \"A+\"\n        //    - else if > 3.7 -> \"A\"\n        //    - else if > 3.3 -> \"A-\"\n        //    - else if > 3.0 -> \"B+\"\n        //    - else if > 2.7 -> \"B\"\n        //    - else if > 2.3 -> \"B-\"\n        //    - else if > 2.0 -> \"C+\"\n        //    - else if > 1.7 -> \"C\"\n        //    - else if > 1.3 -> \"C-\"\n        //    - else if > 1.0 -> \"D+\"\n        //    - else if > 0.7 -> \"D\"\n        //    - else if > 0.0 -> \"D-\"\n        //    - else (0.0 or less) -> \"E\"\n        // 4) Append each determined letter to the output list.\n        // 5) Return the output list.\n\n        List<String> result = new ArrayList<>();\n        for (Double gObj : grades) {\n            double g = gObj; // unbox\n            String letter;\n            if (g == 4.0) {\n                letter = \"A+\";\n            } else if (g > 3.7) {\n                letter = \"A\";\n            } else if (g > 3.3) {\n                letter = \"A-\";\n            } else if (g > 3.0) {\n                letter = \"B+\";\n            } else if (g > 2.7) {\n                letter = \"B\";\n            } else if (g > 2.3) {\n                letter = \"B-\";\n            } else if (g > 2.0) {\n                letter = \"C+\";\n            } else if (g > 1.7) {\n                letter = \"C\";\n            } else if (g > 1.3) {\n                letter = \"C-\";\n            } else if (g > 1.0) {\n                letter = \"D+\";\n            } else if (g > 0.7) {\n                letter = \"D\";\n            } else if (g > 0.0) {\n                letter = \"D-\";\n            } else {\n                letter = \"E\";\n            }\n            result.add(letter);\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> numericalLetterGrade(List<Double> grades) {\n        List<String> result = new ArrayList<>();\n        for (Double g : grades) {\n            result.add(getLetterGrade(g));\n        }\n        return result;\n    }\n\n    private String getLetterGrade(double g) {\n        if (g == 4.0) return \"A+\";\n        if (g > 3.7) return \"A\";\n        if (g > 3.3) return \"A-\";\n        if (g > 3.0) return \"B+\";\n        if (g > 2.7) return \"B\";\n        if (g > 2.3) return \"B-\";\n        if (g > 2.0) return \"C+\";\n        if (g > 1.7) return \"C\";\n        if (g > 1.3) return \"C-\";\n        if (g > 1.0) return \"D+\";\n        if (g > 0.7) return \"D\";\n        if (g > 0.0) return \"D-\";\n        return \"E\";\n    }\n}","nanoTime":"6249768400"}
{"taskId":"Java/82","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.primeLength(\"Hello\") == true,\n                s.primeLength(\"abcdcba\") == true,\n                s.primeLength(\"kittens\") == true,\n                s.primeLength(\"orange\") == false,\n                s.primeLength(\"wow\") == true,\n                s.primeLength(\"world\") == true,\n                s.primeLength(\"MadaM\") == true,\n                s.primeLength(\"Wow\") == true,\n                s.primeLength(\"\") == false,\n                s.primeLength(\"HI\") == true,\n                s.primeLength(\"go\") == true,\n                s.primeLength(\"gogo\") == false,\n                s.primeLength(\"aaaaaaaaaaaaaaa\") == false,\n                s.primeLength(\"Madam\") == true,\n                s.primeLength(\"M\") == false,\n                s.primeLength(\"0\") == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    primeLength(\"Hello\") == true\n    primeLength(\"abcdcba\") == true\n    primeLength(\"kittens\") == true\n    primeLength(\"orange\") == false\n     */\n    public boolean primeLength(String string) {\n        // Let's think step by step\n        // Input: string, a String\n        // Output: boolean indicating if the length of the string is a prime number\n        // Sequential structure:\n        // 1. Validate input and get the length n of the string.\n        // Branch structure:\n        // 2. If n < 2, it's not prime -> return false.\n        // Loop structure:\n        // 3. Check divisibility from 2 up to sqrt(n):\n        //    - If any divisor is found, return false.\n        // 4. If no divisors found, return true.\n\n        // Sequential: handle null and compute length\n        if (string == null) { // Branch\n            return false;\n        }\n        int n = string.length(); // Sequential\n\n        // Branch: lengths less than 2 are not prime\n        if (n < 2) {\n            return false;\n        }\n\n        // Loop: test divisors up to sqrt(n)\n        for (int i = 2; i * i <= n; i++) {\n            // Branch: if divisible by i, not prime\n            if (n % i == 0) {\n                return false;\n            }\n        }\n\n        // If no divisors were found, n is prime\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean primeLength(String string) {\n        if (string == null) {\n            return false;\n        }\n        int length = string.length();\n        if (length < 2) {\n            return false;\n        }\n        for (int i = 2; i * i <= length; i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","nanoTime":"2469569700"}
{"taskId":"Java/83","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.startsOneEnds(1) == 1,\n                s.startsOneEnds(2) == 18,\n                s.startsOneEnds(3) == 180,\n                s.startsOneEnds(4) == 1800,\n                s.startsOneEnds(5) == 18000\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n     */\n    public int startsOneEnds(int n) {\n        // Let's think step by step\n        // Input: n, a positive integer\n        // Output: count, an integer representing how many n-digit numbers start or end with 1\n        // 1) Sequential structure: set up variables and plan to compute powers of 10.\n        // 2) Branch structure: handle the base case n == 1 separately; otherwise use inclusion-exclusion.\n        // 3) Loop structure: compute powers of 10 using a loop (avoid Math.pow to explicitly use a loop).\n        //\n        // Inclusion-Exclusion:\n        // count(start with 1) = 10^(n-1)\n        // count(end with 1)   = 9 * 10^(n-2) for n >= 2; for n == 1 it's 1\n        // count(both)         = 10^(n-2) for n >= 2; for n == 1 it's 1\n        // Total               = start + end - both\n\n        // Branch: invalid input guard (not required by problem, but safe)\n        if (n <= 0) {\n            return 0;\n        }\n\n        // Branch: base case n == 1\n        if (n == 1) {\n            // Only the single-digit number 1 satisfies both start/end with 1\n            return 1;\n        }\n\n        // Loop: compute 10^(n-2)\n        long pow10_n_2 = 1; // will become 10^(n-2)\n        for (int i = 0; i < n - 2; i++) {\n            pow10_n_2 *= 10;\n        }\n\n        // Sequential: derive 10^(n-1) from 10^(n-2)\n        long pow10_n_1 = pow10_n_2 * 10;\n\n        // Sequential: apply inclusion-exclusion\n        long startWith1 = pow10_n_1;          // 10^(n-1)\n        long endWith1 = 9L * pow10_n_2;       // 9 * 10^(n-2)\n        long bothStartEnd1 = pow10_n_2;       // 10^(n-2)\n\n        long result = startWith1 + endWith1 - bothStartEnd1; // equals 18 * 10^(n-2)\n\n        return (int) result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int startsOneEnds(int n) {\n        if (n <= 0) {\n            return 0;\n        }\n\n        if (n == 1) {\n            return 1;\n        }\n\n        long pow10_n_2 = 1;\n        for (int i = 0; i < n - 2; i++) {\n            pow10_n_2 *= 10;\n        }\n\n        long result = 10 * pow10_n_2 + 9 * pow10_n_2 - pow10_n_2;\n        return (int) result;\n    }\n}","nanoTime":"2282086500"}
{"taskId":"Java/84","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.solve(1000), \"1\"),\n                Objects.equals(s.solve(150), \"110\"),\n                Objects.equals(s.solve(147), \"1100\"),\n                Objects.equals(s.solve(333), \"1001\"),\n                Objects.equals(s.solve(963), \"10010\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer N, return the total sum of its digits in binary.\n\n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n             Constraints: 0 <= N <= 10000.\n    Output:\n         a string of binary number\n     */\n    public String solve(int N) {\n        // Let's think step by step\n        // Input: N, an integer\n        // Output: a binary string representing the sum of digits\n\n        // Sequential structure:\n        // 1) Initialize variables to accumulate digit sum.\n        int sum = 0;\n        int temp = N;\n\n        // Branch structure:\n        // 2) If N is 0, return \"0\" directly since sum of digits is 0.\n        if (temp == 0) {\n            return \"0\";\n        }\n\n        // Loop structure:\n        // 3) While temp > 0, extract last digit and add to sum, then remove the digit.\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n\n        // Sequential structure:\n        // 4) Convert the computed sum to a binary string and return it.\n        return Integer.toBinaryString(sum);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer N, return the total sum of its digits in binary.\n\n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\n    Variables:\n        @N integer\n             Constraints: 0 <= N <= 10000.\n    Output:\n         a string of binary number\n     */\n    public String solve(int N) {\n        if (N == 0) {\n            return \"0\";\n        }\n\n        int sum = 0;\n        while (N > 0) {\n            sum += N % 10;\n            N /= 10;\n        }\n\n        return Integer.toBinaryString(sum);\n    }\n}","nanoTime":"4055533700"}
{"taskId":"Java/85","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.add(new ArrayList<>(Arrays.asList(4, 88))) == 88,\n                s.add(new ArrayList<>(Arrays.asList(4, 5, 6, 7, 2, 122))) == 122,\n                s.add(new ArrayList<>(Arrays.asList(4, 0, 6, 7))) == 0,\n                s.add(new ArrayList<>(Arrays.asList(4, 4, 6, 8))) == 12\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a non-empty list of integers\n        // Output: sum of even elements at odd indices\n        // Sequential structure:\n        // 1. Initialize a variable \"sum\" to 0.\n        // 2. Iterate through the list indices.\n        // 3. Return the computed \"sum\".\n        // Branch structure:\n        // - For each index, check if the index is odd (i % 2 == 1).\n        // - If so, check if the element at that index is even (value % 2 == 0).\n        // - If both conditions hold, add the element to \"sum\".\n        // Loop structure:\n        // - Use a for loop to traverse indices (start at 1 and step by 2 to visit odd indices).\n        // Write your code here\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) {\n            int val = lst.get(i);\n            if (val % 2 == 0) {\n                sum += val;\n            }\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add(Arrays.asList(4, 2, 6, 7)) ==> 2\n     */\n    public int add(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 1; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 == 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}","nanoTime":"5652881800"}
{"taskId":"Java/86","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.antiShuffle(\"Hi\"), \"Hi\"),\n                Objects.equals(s.antiShuffle(\"hello\"), \"ehllo\"),\n                Objects.equals(s.antiShuffle(\"number\"), \"bemnru\"),\n                Objects.equals(s.antiShuffle(\"abcd\"), \"abcd\"),\n                Objects.equals(s.antiShuffle(\"Hello World!!!\"), \"Hello !!!Wdlor\"),\n                Objects.equals(s.antiShuffle(\"\"), \"\"),\n                Objects.equals(s.antiShuffle(\"Hi. My name is Mister Robot. How are you?\"), \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    antiShuffle(\"Hi\") returns \"Hi\"\n    antiShuffle(\"hello\") returns \"ehllo\"\n    antiShuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n     */\n    public String antiShuffle(String s) {\n        // Let's think step by step\n        // Input: s, a string\n        // Output: a string where each space-separated word has its characters sorted ascending by ASCII; spaces preserved.\n        // 1. Initialize a StringBuilder \"res\" to build the result. (sequential)\n        // 2. Iterate over the characters of the input string from left to right. (loop)\n        // 3. For each position:\n        // 4.   If the current character is a space, append it as-is to \"res\". (branch)\n        // 5.   Else, collect the contiguous non-space segment (a word). (loop)\n        // 6.     Convert this segment to a char array and sort it ascending with Arrays.sort. (sequential)\n        // 7.     Append the sorted characters to \"res\". (sequential)\n        // 8. Continue until the end and return res.toString(). (sequential)\n        // Write your code here\n        if (s == null || s.length() == 0) return s;\n\n        StringBuilder res = new StringBuilder(s.length());\n        int n = s.length();\n        int i = 0;\n\n        while (i < n) {\n            char ch = s.charAt(i);\n            if (ch == ' ') {\n                res.append(ch);\n                i++;\n            } else {\n                int j = i;\n                while (j < n && s.charAt(j) != ' ') {\n                    j++;\n                }\n                char[] chars = s.substring(i, j).toCharArray();\n                Arrays.sort(chars);\n                res.append(chars);\n                i = j;\n            }\n        }\n\n        return res.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String antiShuffle(String s) {\n        if (s == null || s.isEmpty()) return s;\n\n        StringBuilder res = new StringBuilder();\n        String[] words = s.split(\"(?<= )|(?= )\");\n\n        for (String word : words) {\n            if (word.trim().isEmpty()) {\n                res.append(word);\n            } else {\n                char[] chars = word.toCharArray();\n                Arrays.sort(chars);\n                res.append(chars);\n            }\n        }\n\n        return res.toString();\n    }\n}","nanoTime":"2116387200"}
{"taskId":"Java/87","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 1, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 1)\n                ), 1).equals(Arrays.asList(Arrays.asList(0, 0), Arrays.asList(1, 4), Arrays.asList(1, 0), Arrays.asList(2, 5), Arrays.asList(2, 0))),\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6)\n                ), 2).equals(Arrays.asList(Arrays.asList(0, 1), Arrays.asList(1, 1), Arrays.asList(2, 1), Arrays.asList(3, 1), Arrays.asList(4, 1), Arrays.asList(5, 1))),\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 1, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 1, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 1, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 1, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 1)\n                ), 1).equals(Arrays.asList(Arrays.asList(0, 0), Arrays.asList(1, 0), Arrays.asList(2, 1), Arrays.asList(2, 0), Arrays.asList(3, 2), Arrays.asList(3, 0), Arrays.asList(4, 3), Arrays.asList(4, 0), Arrays.asList(5, 4), Arrays.asList(5, 0), Arrays.asList(6, 5), Arrays.asList(6, 0))),\n                s.getRow(List.of(), 1).equals(List.of()),\n                s.getRow(List.of(List.of(1)), 2).equals(List.of()),\n                s.getRow(Arrays.asList(List.of(), List.of(1), Arrays.asList(1, 2, 3)), 3).equals(List.of(Arrays.asList(2, 2)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of lists, [[x1, y1], [x2, y2] ...] such that\n    each list is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    getRow([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n    getRow([], 1) == []\n    getRow([[], [1], [1, 2, 3]], 3) == [[2, 2]]\n     */\n    public List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n        // Let's think step by step\n        // Input: lst (List<List<Integer>>), x (int)\n        // Output: List<List<Integer>> of coordinates [row, col]\n        // Sequential:\n        // 1) Initialize an empty result list to store coordinates.\n        // Loop:\n        // 2) For each row index i from 0 to lst.size()-1:\n        //    2a) For each column index j from 0 to lst.get(i).size()-1:\n        // Branch:\n        //    2b) If the element at (i, j) equals x, add [i, j] to result.\n        // Sequential:\n        // 3) Sort result by row ascending, and within the same row by column descending.\n        // 4) Return the result.\n\n        List<List<Integer>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) {\n            return result;\n        }\n\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            if (row == null) continue;\n            for (int j = 0; j < row.size(); j++) {\n                Integer val = row.get(j);\n                if (val != null && val == x) {\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        Collections.sort(result, (a, b) -> {\n            int ra = a.get(0), rb = b.get(0);\n            if (ra != rb) return Integer.compare(ra, rb);\n            return Integer.compare(b.get(1), a.get(1));\n        });\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (lst == null || lst.isEmpty()) {\n            return result;\n        }\n\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            if (row == null) continue;\n            for (int j = 0; j < row.size(); j++) {\n                if (Objects.equals(row.get(j), x)) {\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        result.sort((a, b) -> {\n            int rowComparison = Integer.compare(a.get(0), b.get(0));\n            return rowComparison != 0 ? rowComparison : Integer.compare(b.get(1), a.get(1));\n        });\n\n        return result;\n    }\n}","nanoTime":"2982312800"}
{"taskId":"Java/88","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sortArray(new ArrayList<>(List.of())).equals(List.of()),\n                s.sortArray(new ArrayList<>(List.of(5))).equals(List.of(5)),\n                s.sortArray(new ArrayList<>(Arrays.asList(2, 4, 3, 0, 1, 5))).equals(Arrays.asList(0, 1, 2, 3, 4, 5)),\n                s.sortArray(new ArrayList<>(Arrays.asList(2, 4, 3, 0, 1, 5, 6))).equals(Arrays.asList(6, 5, 4, 3, 2, 1, 0)),\n                s.sortArray(new ArrayList<>(Arrays.asList(2, 1))).equals(Arrays.asList(1, 2)),\n                s.sortArray(new ArrayList<>(Arrays.asList(15, 42, 87, 32 ,11, 0))).equals(Arrays.asList(0, 11, 15, 32, 42, 87)),\n                s.sortArray(new ArrayList<>(Arrays.asList(21, 14, 23, 11))).equals(Arrays.asList(23, 21, 14, 11))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sortArray(Arrays.asList()) => []\n    * sortArray(Arrays.asList(5)) => [5]\n    * sortArray(Arrays.asList(2, 4, 3, 0, 1, 5)) => [0, 1, 2, 3, 4, 5]\n    * sortArray(Arrays.asList(2, 4, 3, 0, 1, 5, 6)) => [6, 5, 4, 3, 2, 1, 0]\n     */\n    public List<Integer> sortArray(List<Integer> array) {\n        // Let's think step by step\n        // Input: array, a List<Integer> of non-negative integers\n        // Output: a new List<Integer> sorted per rule without modifying the original list\n        // Sequential:\n        // 1. If the input list is empty, return a new empty list.\n        // 2. Create a new list \"copy\" and copy all elements from \"array\" using a loop (to avoid modifying the original).\n        // 3. If the list has size 0 or 1, return the copy as-is.\n        // Branch:\n        // 4. Read the first and last values of the original list.\n        // 5. Determine if the sum is odd by comparing parity bits (avoids overflow): odd iff one is odd and the other is even.\n        // 6. If odd, sort ascending; else, sort descending.\n        // Loop:\n        // - Use a for-each loop to copy elements from the input list into the new list.\n        // 7. Return the sorted copy.\n\n        if (array == null || array.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> copy = new ArrayList<>(array.size());\n        for (Integer v : array) { // loop structure for copying\n            copy.add(v);\n        }\n\n        if (copy.size() <= 1) { // branch for trivial sizes\n            return copy;\n        }\n\n        int first = array.get(0);\n        int last = array.get(array.size() - 1);\n\n        // sum is odd iff the parity of first and last differs\n        boolean oddSum = ((first & 1) != (last & 1));\n\n        if (oddSum) { // branch: ascending if odd\n            Collections.sort(copy);\n        } else { // descending if even\n            copy.sort(Collections.reverseOrder());\n        }\n\n        return copy;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sortArray(List<Integer> array) {\n        if (array == null || array.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> copy = new ArrayList<>(array);\n        if (copy.size() <= 1) {\n            return copy;\n        }\n\n        int first = array.get(0);\n        int last = array.get(array.size() - 1);\n        boolean oddSum = ((first & 1) != (last & 1));\n\n        if (oddSum) {\n            Collections.sort(copy);\n        } else {\n            copy.sort(Collections.reverseOrder());\n        }\n\n        return copy;\n    }\n}","nanoTime":"2180226800"}
{"taskId":"Java/89","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.encrypt(\"hi\"), \"lm\"),\n                Objects.equals(s.encrypt(\"asdfghjkl\"), \"ewhjklnop\"),\n                Objects.equals(s.encrypt(\"gf\"), \"kj\"),\n                Objects.equals(s.encrypt(\"et\"), \"ix\"),\n                Objects.equals(s.encrypt(\"faewfawefaewg\"), \"jeiajeaijeiak\"),\n                Objects.equals(s.encrypt(\"hellomyfriend\"), \"lippsqcjvmirh\"),\n                Objects.equals(s.encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"),\n                Objects.equals(s.encrypt(\"a\"), \"e\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt(\"hi\") returns \"lm\"\n    encrypt(\"asdfghjkl\") returns \"ewhjklnop\"\n    encrypt(\"gf\") returns \"kj\"\n    encrypt(\"et\") returns \"ix\"\n     */\n    public String encrypt(String s) {\n        // Let's think step by step\n        // Input: s, a string\n        // Output: encrypted string where each alphabet letter is shifted by 2*2 = 4 positions\n        // Sequential:\n        // 1) Define shift = 4 (since \"two multiplied to two places\" -> 2 * 2).\n        // 2) Create a StringBuilder to build the result.\n        // Loop:\n        // 3) For each character c in the input string:\n        //    Branch:\n        //    - If c is a lowercase letter, rotate within 'a'..'z' by shift and append.\n        //    - Else if c is an uppercase letter, rotate within 'A'..'Z' by shift and append.\n        //    - Else append the character as-is.\n        // Sequential:\n        // 4) Return the built encrypted string.\n\n        if (s == null) return null;\n\n        final int shift = 4;\n        StringBuilder sb = new StringBuilder(s.length());\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c >= 'a' && c <= 'z') {\n                int pos = c - 'a';\n                char enc = (char) ('a' + (pos + shift) % 26);\n                sb.append(enc);\n            } else if (c >= 'A' && c <= 'Z') {\n                int pos = c - 'A';\n                char enc = (char) ('A' + (pos + shift) % 26);\n                sb.append(enc);\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encrypt(String s) {\n        if (s == null) return null;\n\n        final int shift = 4;\n        StringBuilder sb = new StringBuilder(s.length());\n\n        for (char c : s.toCharArray()) {\n            sb.append(rotateCharacter(c, shift));\n        }\n\n        return sb.toString();\n    }\n\n    private char rotateCharacter(char c, int shift) {\n        if (Character.isLowerCase(c)) {\n            return (char) ('a' + (c - 'a' + shift) % 26);\n        } else if (Character.isUpperCase(c)) {\n            return (char) ('A' + (c - 'A' + shift) % 26);\n        }\n        return c;\n    }\n}","nanoTime":"3331367000"}
{"taskId":"Java/90","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.nextSmallest(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5))).get() == 2,\n                s.nextSmallest(new ArrayList<>(Arrays.asList(5, 1, 4, 3, 2))).get() == 2,\n                s.nextSmallest(new ArrayList<>(List.of())).isEmpty(),\n                s.nextSmallest(new ArrayList<>(Arrays.asList(1, 1))).isEmpty(),\n                s.nextSmallest(new ArrayList<>(Arrays.asList(1, 1, 1, 1, 0))).get() == 1,\n                s.nextSmallest(new ArrayList<>(Arrays.asList(1, (int) Math.pow(0.0, 0.0)))).isEmpty(),\n                s.nextSmallest(new ArrayList<>(Arrays.asList(-35, 34, 12, -45))).get() == -35\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of integers.\n    Write a function nextSmallest() that returns the 2nd smallest element of the list.\n    Return null if there is no such element.\n    <p>\n    nextSmallest(Arrays.asList(1, 2, 3, 4, 5)) == Optional[2]\n    nextSmallest(Arrays.asList(5, 1, 4, 3, 2)) == Optional[2]\n    nextSmallest(Arrays.asList()) == Optional.empty\n    nextSmallest(Arrays.asList(1, 1)) == Optional.empty\n     */\n    public Optional<Integer> nextSmallest(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a list of integers (may be empty)\n        // Output: Optional<Integer> containing the 2nd smallest distinct element, or Optional.empty if none\n        // Problem-solving process using sequential, branch, and loop structures:\n        // Sequential:\n        // 1. Initialize two variables to track the smallest (min1) and second smallest (min2) distinct values.\n        // Branch:\n        // 2. If the input list is null or empty, return Optional.empty immediately.\n        // Loop:\n        // 3. For each number in the list:\n        //    3.1 If the number is null, continue to next (skip).\n        //    3.2 If min1 is not set or number < min1, shift current min1 to min2 and set min1 to number.\n        //    3.3 Else if number > min1 and (min2 is not set or number < min2), set min2 to number.\n        // Sequential:\n        // 4. After the loop, if min2 is set, return Optional.of(min2); otherwise return Optional.empty().\n        // Write your code here\n        if (lst == null || lst.isEmpty()) {\n            return Optional.empty();\n        }\n        Integer min1 = null;\n        Integer min2 = null;\n        for (Integer x : lst) {\n            if (x == null) continue;\n            if (min1 == null || x < min1) {\n                if (min1 == null) {\n                    min1 = x;\n                } else {\n                    min2 = min1;\n                    min1 = x;\n                }\n            } else if (x > min1 && (min2 == null || x < min2)) {\n                min2 = x;\n            }\n        }\n        return (min2 != null) ? Optional.of(min2) : Optional.empty();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> nextSmallest(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return Optional.empty();\n        }\n\n        Set<Integer> distinctNumbers = new TreeSet<>(lst);\n        Iterator<Integer> iterator = distinctNumbers.iterator();\n\n        if (iterator.hasNext()) {\n            iterator.next(); // Skip the smallest\n            if (iterator.hasNext()) {\n                return Optional.of(iterator.next()); // Return the second smallest\n            }\n        }\n        \n        return Optional.empty();\n    }\n}","nanoTime":"1961978800"}
{"taskId":"Java/91","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isBored(\"Hello world\") == 0,\n                s.isBored(\"Is the sky blue?\") == 0,\n                s.isBored(\"I love It !\") == 1,\n                s.isBored(\"bIt\") == 0,\n                s.isBored(\"I feel good today. I will be productive. will kill It\") == 2,\n                s.isBored(\"You and I are going for a walk\") == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> isBored(\"Hello world\")\n    0\n    >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n     */\n    public int isBored(String S) {\n        // Let's think step by step\n        // Input: S, a string\n        // Output: count, an integer\n        // 1. Sequential: Handle null/empty input and split S into sentence fragments using '.', '?', and '!' as delimiters.\n        // 2. Loop: Iterate over each fragment.\n        // 3.   Sequential: Trim whitespace from the fragment.\n        // 4.   Branch: If the fragment is empty, continue to the next fragment.\n        // 5.   Sequential: Extract the first word (from start until first whitespace).\n        // 6.   Branch: If the first word equals \"I\", increment the counter.\n        // 7. Sequential: Return the counter.\n        if (S == null || S.length() == 0) return 0;\n\n        String[] parts = S.split(\"[.?!]\");\n        int count = 0;\n\n        for (String part : parts) {\n            if (part == null) continue;\n            String trimmed = part.trim();\n            if (trimmed.length() == 0) continue;\n\n            int i = 0;\n            int n = trimmed.length();\n            // skip leading whitespace (already trimmed, but safe)\n            while (i < n && Character.isWhitespace(trimmed.charAt(i))) i++;\n            int j = i;\n            while (j < n && !Character.isWhitespace(trimmed.charAt(j))) j++;\n            String firstWord = (i < n) ? trimmed.substring(i, j) : \"\";\n\n            if (firstWord.equals(\"I\")) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int isBored(String S) {\n        if (S == null || S.isEmpty()) return 0;\n\n        String[] sentences = S.split(\"[.?!]\");\n        int boredomCount = 0;\n\n        for (String sentence : sentences) {\n            String trimmedSentence = sentence.trim();\n            if (!trimmedSentence.isEmpty() && trimmedSentence.startsWith(\"I \")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n}","nanoTime":"2200433100"}
{"taskId":"Java/92","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.anyInt(2, 3, 1) == true,\n                s.anyInt(2.5, 2, 3) == false,\n                s.anyInt(1.5, 5, 3.5) == false,\n                s.anyInt(2, 6, 2) == false,\n                s.anyInt(4, 2, 2) == true,\n                s.anyInt(2.2, 2.2, 2.2) == false,\n                s.anyInt(-4, 6, 2) == true,\n                s.anyInt(2, 1, 1) == true,\n                s.anyInt(3, 4, 7) == true,\n                s.anyInt(3.0, 4, 7) == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n\n    Examples\n    anyInt(5, 2, 7) -> true\n\n    anyInt(3, 2, 2) -> false\n\n    anyInt(3, -2, 1) -> true\n\n    anyInt(3.6, -2.2, 2) -> false\n     */\n    public boolean anyInt(Object x, Object y, Object z) {\n        // Let's think step by step\n        // Input: x, y, z - Objects representing numbers\n        // Output: boolean - true if all are integers and one equals the sum of the other two, else false\n        // Sequential steps:\n        // 1) Put inputs into an array for uniform handling.\n        // 2) Prepare a flag to verify that all three are integer number types.\n        // Loop structure:\n        // 3) Iterate through the inputs to check: non-null and integer types (Byte, Short, Integer, Long).\n        // Branch structure:\n        // 4) If any check fails, return false.\n        // 5) Convert to long and check if any one equals the sum of the other two. Return the result.\n        \n        Object[] arr = new Object[] { x, y, z };\n        boolean allIntegers = true;\n        for (Object o : arr) {\n            if (o == null || !(o instanceof Byte || o instanceof Short || o instanceof Integer || o instanceof Long)) {\n                allIntegers = false;\n                break;\n            }\n        }\n        if (!allIntegers) {\n            return false;\n        }\n        long a = ((Number) x).longValue();\n        long b = ((Number) y).longValue();\n        long c = ((Number) z).longValue();\n        return a == b + c || b == a + c || c == a + b;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean anyInt(Number x, Number y, Number z) {\n        if (x == null || y == null || z == null) {\n            return false;\n        }\n        \n        long a = x.longValue();\n        long b = y.longValue();\n        long c = z.longValue();\n        \n        return a == b + c || b == a + c || c == a + b;\n    }\n}","nanoTime":"2048413800"}
{"taskId":"Java/93","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.encode(\"TEST\"), \"tgst\"),\n                Objects.equals(s.encode(\"Mudasir\"), \"mWDCSKR\"),\n                Objects.equals(s.encode(\"YES\"), \"ygs\"),\n                Objects.equals(s.encode(\"This is a message\"), \"tHKS KS C MGSSCGG\"),\n                Objects.equals(s.encode(\"I DoNt KnOw WhAt tO WrItE\"), \"k dQnT kNqW wHcT Tq wRkTg\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a message, and encodes in such a\n    way that it swaps case of all letters, replaces all vowels in\n    the message with the letter that appears 2 places ahead of that\n    vowel in the english alphabet.\n    Assume only letters.\n\n    Examples:\n    >>> encode(\"test\")\n    \"TGST\"\n    >>> encode(\"This is a message\")\n    \"tHKS KS C MGSSCGG\"\n     */\n    public String encode(String message) {\n        // Let's think step by step\n        // Input: message, a string\n        // Output: encoded, a string\n        // Sequential structure:\n        // 1) Initialize a StringBuilder to build the result.\n        // Loop structure:\n        // 2) For each character in the message (from left to right):\n        //    a) Swap its case.\n        //    Branch structure:\n        //    b) If the swapped character is a vowel (a, e, i, o, u in either case),\n        //       replace it with the letter 2 positions ahead in the alphabet (preserving case).\n        //    c) Append the (possibly modified) character to the result.\n        // 3) Return the built string.\n\n        StringBuilder sb = new StringBuilder();\n\n        for (int i = 0; i < message.length(); i++) {\n            char ch = message.charAt(i);\n\n            // Swap case\n            char swapped;\n            if (Character.isUpperCase(ch)) {\n                swapped = Character.toLowerCase(ch);\n            } else if (Character.isLowerCase(ch)) {\n                swapped = Character.toUpperCase(ch);\n            } else {\n                // Non-letter (e.g., space), keep as is\n                swapped = ch;\n            }\n\n            // If swapped char is a vowel, shift it by 2 positions ahead\n            if (isVowel(swapped)) {\n                swapped = shiftByTwo(swapped);\n            }\n\n            sb.append(swapped);\n        }\n\n        return sb.toString();\n    }\n\n    private boolean isVowel(char c) {\n        switch (c) {\n            case 'a': case 'e': case 'i': case 'o': case 'u':\n            case 'A': case 'E': case 'I': case 'O': case 'U':\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    private char shiftByTwo(char c) {\n        if (Character.isUpperCase(c)) {\n            int pos = c - 'A';\n            pos = (pos + 2) % 26;\n            return (char) ('A' + pos);\n        } else if (Character.isLowerCase(c)) {\n            int pos = c - 'a';\n            pos = (pos + 2) % 26;\n            return (char) ('a' + pos);\n        } else {\n            return c;\n        }\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String encode(String message) {\n        StringBuilder sb = new StringBuilder();\n\n        for (char ch : message.toCharArray()) {\n            char swapped = swapCase(ch);\n            sb.append(isVowel(swapped) ? shiftByTwo(swapped) : swapped);\n        }\n\n        return sb.toString();\n    }\n\n    private char swapCase(char c) {\n        return Character.isUpperCase(c) ? Character.toLowerCase(c) : \n               Character.isLowerCase(c) ? Character.toUpperCase(c) : c;\n    }\n\n    private boolean isVowel(char c) {\n        return \"aeiouAEIOU\".indexOf(c) != -1;\n    }\n\n    private char shiftByTwo(char c) {\n        int base = Character.isUpperCase(c) ? 'A' : 'a';\n        return (char) ((c - base + 2) % 26 + base);\n    }\n}","nanoTime":"2612454100"}
{"taskId":"Java/94","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.skjkasdkd(Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)) == 10,\n                s.skjkasdkd(Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)) == 25,\n                s.skjkasdkd(Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)) == 13,\n                s.skjkasdkd(Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)) == 11,\n                s.skjkasdkd(Arrays.asList(0, 81, 12, 3, 1, 21)) == 3,\n                s.skjkasdkd(Arrays.asList(0, 8, 1, 2, 1, 7)) == 7,\n                s.skjkasdkd(List.of(8191)) == 19,\n                s.skjkasdkd(Arrays.asList(8191, 123456, 127, 7)) == 19,\n                s.skjkasdkd(Arrays.asList(127, 97, 8192)) == 10\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n     */\n    public int skjkasdkd(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a list of integers\n        // Output: an integer representing the sum of digits of the largest prime in lst\n        // Sequential structure:\n        // 1. Initialize maxPrime to -1 (no prime found yet).\n        // Loop structure:\n        // 2. For each number in lst:\n        //    - Branch structure:\n        //      a) If number is prime and greater than maxPrime, update maxPrime.\n        // Sequential structure:\n        // 3. If maxPrime is still -1, return 0 (no primes). Otherwise, compute and return sum of digits of maxPrime.\n        int maxPrime = -1;\n        for (int x : lst) {\n            if (isPrime(x) && x > maxPrime) {\n                maxPrime = x;\n            }\n        }\n        if (maxPrime == -1) return 0;\n        return digitSum(maxPrime);\n    }\n\n    private boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n == 2) return true;\n        if ((n & 1) == 0) return false;\n        for (int i = 3; (long) i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    private int digitSum(int n) {\n        int sum = 0;\n        n = Math.abs(n);\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int findLargestPrimeDigitSum(List<Integer> numbers) {\n        int largestPrime = -1;\n        for (int number : numbers) {\n            if (isPrime(number) && number > largestPrime) {\n                largestPrime = number;\n            }\n        }\n        return (largestPrime == -1) ? 0 : calculateDigitSum(largestPrime);\n    }\n\n    private boolean isPrime(int number) {\n        if (number < 2) return false;\n        if (number == 2) return true;\n        if (number % 2 == 0) return false;\n        for (int i = 3; i * i <= number; i += 2) {\n            if (number % i == 0) return false;\n        }\n        return true;\n    }\n\n    private int calculateDigitSum(int number) {\n        int sum = 0;\n        number = Math.abs(number);\n        while (number > 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        return sum;\n    }\n}","nanoTime":"3029903300"}
{"taskId":"Java/95","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Map<Object, Object> map1 = new HashMap<>();\n        map1.put(\"p\", \"pineapple\");\n        map1.put(\"b\", \"banana\");\n        Map<Object, Object> map2 = new HashMap<>();\n        map2.put(\"p\", \"pineapple\");\n        map2.put(\"A\", \"banana\");\n        map2.put(\"B\", \"banana\");\n        Map<Object, Object> map3 = new HashMap<>();\n        map3.put(\"p\", \"pineapple\");\n        map3.put(5, \"banana\");\n        map3.put(\"a\", \"banana\");\n        Map<Object, Object> map4 = new HashMap<>();\n        map4.put(\"Name\", \"John\");\n        map4.put(\"Age\", \"36\");\n        map4.put(\"City\", \"Houston\");\n        Map<Object, Object> map5 = new HashMap<>();\n        map5.put(\"STATE\", \"NC\");\n        map5.put(\"ZIP\", \"12345\");\n        Map<Object, Object> map6 = new HashMap<>();\n        map6.put(\"fruit\", \"Orange\");\n        map6.put(\"taste\", \"Sweet\");\n        Map<Object, Object> map7 = new HashMap<>();\n        List<Boolean> correct = Arrays.asList(\n                s.checkDictCase(map1),\n                !s.checkDictCase(map2),\n                !s.checkDictCase(map3),\n                !s.checkDictCase(map4),\n                s.checkDictCase(map5),\n                s.checkDictCase(map6),\n                !s.checkDictCase(map7)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a map, return True if all keys are strings in lower\n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given map is empty.\n    Examples:\n    checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n     */\n    public boolean checkDictCase(Map<Object, Object> dict) {\n        // Let's think step by step\n        // Input: dict, a map with keys of type Object\n        // Output: boolean indicating if all keys are strings and either all lower-case or all upper-case\n        // Sequential structure:\n        // 1. If the map is null or empty, return False immediately.\n        // 2. Initialize two flags: allLower = true and allUpper = true.\n        // Loop structure:\n        // 3. For each key in the map:\n        // 4.   Branch: if the key is not a String, return False.\n        // 5.   Compare the key with its lower-case and upper-case forms.\n        // 6.   If key != lower-case version, set allLower = false.\n        // 7.   If key != upper-case version, set allUpper = false.\n        // 8.   If both flags become false, break early.\n        // Branch structure:\n        // 9. After the loop, return True if either allLower or allUpper is true; otherwise, return False.\n        // Write your code here\n        if (dict == null || dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLower = true;\n        boolean allUpper = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String s = (String) key;\n            String lower = s.toLowerCase(Locale.ROOT);\n            String upper = s.toUpperCase(Locale.ROOT);\n\n            if (!s.equals(lower)) {\n                allLower = false;\n            }\n            if (!s.equals(upper)) {\n                allUpper = false;\n            }\n            if (!allLower && !allUpper) {\n                break;\n            }\n        }\n\n        return allLower || allUpper;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean checkDictCase(Map<Object, Object> dict) {\n        if (dict == null || dict.isEmpty()) {\n            return false;\n        }\n\n        boolean allLower = true;\n        boolean allUpper = true;\n\n        for (Object key : dict.keySet()) {\n            if (!(key instanceof String)) {\n                return false;\n            }\n            String s = (String) key;\n            allLower &= s.equals(s.toLowerCase(Locale.ROOT));\n            allUpper &= s.equals(s.toUpperCase(Locale.ROOT));\n\n            if (!allLower && !allUpper) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","nanoTime":"2749410000"}
{"taskId":"Java/96","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countUpTo(5).equals(Arrays.asList(2, 3)),\n                s.countUpTo(6).equals(Arrays.asList(2, 3, 5)),\n                s.countUpTo(7).equals(Arrays.asList(2, 3, 5)),\n                s.countUpTo(10).equals(Arrays.asList(2, 3, 5, 7)),\n                s.countUpTo(0).equals(List.of()),\n                s.countUpTo(22).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19)),\n                s.countUpTo(1).equals(List.of()),\n                s.countUpTo(18).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17)),\n                s.countUpTo(47).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43)),\n                s.countUpTo(101).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    countUpTo(5) => [2,3]\n    countUpTo(11) => [2,3,5,7]\n    countUpTo(0) => []\n    countUpTo(20) => [2,3,5,7,11,13,17,19]\n    countUpTo(1) => []\n    countUpTo(18) => [2,3,5,7,11,13,17]\n     */\n    public List<Integer> countUpTo(int n) {\n        // Let's think step by step\n        // Input: n, a non-negative integer\n        // Output: a list of all prime numbers less than n\n        // Sequential structure:\n        // 1) If n <= 2, return empty list (there are no primes less than 2).\n        // 2) Initialize a boolean array isPrime of length n and set all entries to true,\n        //    then set indices 0 and 1 to false because 0 and 1 are not primes.\n        // Loop structure:\n        // 3) For each p from 2 up to sqrt(n), if isPrime[p] is true, mark all multiples\n        //    of p starting from p*p as non-prime (false).\n        // Branch structure:\n        // 4) After sieving, iterate through indices 2..n-1; if isPrime[i] is true,\n        //    add i to the result list.\n        // 5) Return the result list.\n\n        List<Integer> result = new ArrayList<>();\n        if (n <= 2) {\n            return result;\n        }\n\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = false;\n        if (n > 1) {\n            isPrime[1] = false;\n        }\n\n        for (int p = 2; p * p < n; p++) {\n            if (isPrime[p]) {\n                for (int multiple = p * p; multiple < n; multiple += p) {\n                    isPrime[multiple] = false;\n                }\n            }\n        }\n\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> countUpTo(int n) {\n        List<Integer> result = new ArrayList<>();\n        if (n <= 2) {\n            return result;\n        }\n\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = false;\n        isPrime[1] = false;\n\n        for (int p = 2; p * p < n; p++) {\n            if (isPrime[p]) {\n                for (int multiple = p * p; multiple < n; multiple += p) {\n                    isPrime[multiple] = false;\n                }\n            }\n        }\n\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n}","nanoTime":"2320839700"}
{"taskId":"Java/97","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.multiply(148, 412) == 16,\n                s.multiply(19, 28) == 72,\n                s.multiply(2020, 1851) == 0,\n                s.multiply(14,-15) == 20,\n                s.multiply(76, 67) == 42,\n                s.multiply(17, 27) == 49,\n                s.multiply(0, 1) == 0,\n                s.multiply(0, 0) == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Complete the function that takes two integers and returns\n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n     */\n    public int multiply(int a, int b) {\n        // Let's think step by step\n        // Input: two integers a and b\n        // Output: an integer equal to the product of their unit digits\n        // Sequential structure:\n        // 1) Prepare a container to process both inputs and a place to store their unit digits.\n        // Loop structure:\n        // 2) For each number, take its absolute value and compute the unit digit with % 10.\n        // Branch structure:\n        // 3) If any unit digit is 0, the product is 0; return 0 early.\n        // 4) Otherwise, multiply the two unit digits and return the result.\n        // Write your code here\n        int[] nums = {a, b};\n        int[] units = new int[2];\n        for (int i = 0; i < 2; i++) {\n            units[i] = Math.abs(nums[i]) % 10;\n        }\n        if (units[0] == 0 || units[1] == 0) {\n            return 0;\n        }\n        return units[0] * units[1];\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int multiply(int a, int b) {\n        int unitA = Math.abs(a) % 10;\n        int unitB = Math.abs(b) % 10;\n        return (unitA == 0 || unitB == 0) ? 0 : unitA * unitB;\n    }\n}","nanoTime":"2297227200"}
{"taskId":"Java/98","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countUpper(\"aBCdEf\")  == 1,\n                s.countUpper(\"abcdefg\") == 0,\n                s.countUpper(\"dBBE\") == 0,\n                s.countUpper(\"B\")  == 0,\n                s.countUpper(\"U\")  == 1,\n                s.countUpper(\"\") == 0,\n                s.countUpper(\"EEEE\") == 2\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    countUpper(\"aBCdEf\") returns 1\n    countUpper(\"abcdefg\") returns 0\n    countUpper(\"dBBE\") returns 0\n     */    \n    public int countUpper(String s) {\n        // Let's think step by step\n        // Input: s, a string\n        // Output: count, an integer\n        // Sequential:\n        // 1. Initialize a counter to 0.\n        // Loop:\n        // 2. Iterate through the string over even indices (i = 0, 2, 4, ...).\n        // Branch:\n        // 3. At each even index, check if the character is an uppercase vowel (A, E, I, O, U).\n        // 4. If it is, increment the counter.\n        // 5. Return the counter.\n        // Write your code here\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    countUpper(\"aBCdEf\") returns 1\n    countUpper(\"abcdefg\") returns 0\n    countUpper(\"dBBE\") returns 0\n    */    \n    public int countUpper(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            char ch = s.charAt(i);\n            if (isUppercaseVowel(ch)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isUppercaseVowel(char ch) {\n        return \"AEIOU\".indexOf(ch) >= 0;\n    }\n}","nanoTime":"2365571900"}
{"taskId":"Java/99","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countUpper(\"10\") == 10,\n                s.countUpper(\"14.5\") == 15,\n                s.countUpper(\"-15.5\") == -16,\n                s.countUpper(\"15.3\") == 15,\n                s.countUpper(\"0\") == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\nclass Solution {\n    /**\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n     */\n    public int countUpper(String value) {\n        // Let's think step by step\n        // Input: value, a string representing a number\n        // Output: the closest integer with ties rounded away from zero\n\n        // Sequential structure:\n        // 1) Trim the input string.\n        // 2) Ensure it contains at least one digit (basic validation).\n        // 3) Convert to BigDecimal for precise rounding.\n        // 4) Round to 0 decimal places with HALF_UP (ties away from zero).\n        // 5) Return as int.\n\n        // Branch structure:\n        // - If value is null or has no digits, handle accordingly.\n        // - Rounding behavior: ties handled by HALF_UP away from zero.\n\n        // Loop structure:\n        // - Iterate over characters to check if the input has at least one digit.\n\n        if (value == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n        String s = value.trim();\n\n        boolean hasDigit = false;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch >= '0' && ch <= '9') {\n                hasDigit = true;\n                break;\n            }\n        }\n        if (!hasDigit) {\n            throw new IllegalArgumentException(\"Input must contain at least one digit\");\n        }\n\n        BigDecimal bd = new BigDecimal(s);\n        bd = bd.setScale(0, RoundingMode.HALF_UP);\n        return bd.intValue();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\nclass Solution {\n    public int closestInteger(String value) {\n        validateInput(value);\n        BigDecimal bd = new BigDecimal(value.trim());\n        bd = bd.setScale(0, RoundingMode.HALF_UP);\n        return bd.intValue();\n    }\n\n    private void validateInput(String value) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n        if (!value.matches(\".*\\\\d.*\")) {\n            throw new IllegalArgumentException(\"Input must contain at least one digit\");\n        }\n    }\n}","nanoTime":"2277869800"}
{"taskId":"Java/100","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.makeAPile(3).equals(Arrays.asList(3, 5, 7)),\n                s.makeAPile(4).equals(Arrays.asList(4, 6, 8, 10)),\n                s.makeAPile(5).equals(Arrays.asList(5, 7, 9, 11, 13)),\n                s.makeAPile(6).equals(Arrays.asList(6, 8, 10, 12, 14, 16)),\n                s.makeAPile(8).equals(Arrays.asList(8, 10, 12, 14, 16, 18, 20, 22))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> makeAPile(3)\n    [3, 5, 7]\n     */\n    public List<Integer> makeAPile(int n) {\n        // Let's think step by step\n        // Input: n, a positive integer\n        // Output: List<Integer> of length n with the number of stones per level\n        // Sequential structure:\n        // 1. Initialize an empty result list.\n        // 2. Initialize the starting number for the first level.\n        // Branch structure:\n        // 3. If n is odd, start with n and continue with next odd numbers.\n        //    Else, start with n and continue with next even numbers.\n        // Loop structure:\n        // 4. For i from 0 to n-1, add current to result and move to next by adding 2.\n        // 5. Return the result list.\n        // Write your code here\n        List<Integer> result = new ArrayList<>();\n        if (n <= 0) {\n            return result;\n        }\n\n        int current;\n        if ((n & 1) == 1) { // n is odd\n            current = n; // start at this odd number\n        } else {          // n is even\n            current = n; // start at this even number\n        }\n\n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            current += 2;\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> makeAPile(3)\n    [3, 5, 7]\n     */\n    public List<Integer> makeAPile(int n) {\n        List<Integer> result = new ArrayList<>(n);\n        if (n <= 0) {\n            return result;\n        }\n\n        int current = n;\n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            current += 2;\n        }\n\n        return result;\n    }\n}","nanoTime":"3369340800"}
{"taskId":"Java/101","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.wordStrings(\"Hi, my name is John\" ).equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\" )),\n                s.wordStrings(\"One, two, three, four, five, six\" ).equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\" )),\n                s.wordStrings(\"Hi, my name\" ).equals(Arrays.asList(\"Hi\", \"my\", \"name\" )),\n                s.wordStrings(\"One,, two, three, four, five, six,\" ).equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\" )),\n                s.wordStrings(\"\" ).equals(List.of()),\n                s.wordStrings(\"ahmed     , gamal\" ).equals(Arrays.asList(\"ahmed\", \"gamal\" ))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\").equals(Arrays.asList(\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\").equals(Arrays.asList(\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     */\n    public List<String> wordStrings(String s) {\n        // Let's think step by step\n        // Input: s, a string containing words separated by commas and/or spaces\n        // Output: List<String> containing the words in order\n        // Sequential structure:\n        // 1. If s is null, treat it as an empty string.\n        // 2. Trim leading and trailing whitespace.\n        // 3. Define a regex \"[,\\\\s]+\" to split on one or more commas or whitespace characters.\n        // Branch structure:\n        // - If the trimmed string is empty, return an empty list.\n        // Loop structure:\n        // - Iterate over the split tokens and add non-empty tokens to the result list.\n        // Write your code here\n        if (s == null) {\n            return new ArrayList<>();\n        }\n        String trimmed = s.trim();\n        if (trimmed.isEmpty()) {\n            return new ArrayList<>();\n        }\n        String[] parts = trimmed.split(\"[,\\\\s]+\");\n        List<String> result = new ArrayList<>(parts.length);\n        for (String part : parts) {\n            if (!part.isEmpty()) {\n                result.add(part);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> wordStrings(String s) {\n        if (s == null || s.trim().isEmpty()) {\n            return new ArrayList<>();\n        }\n        String[] parts = s.trim().split(\"[,\\\\s]+\");\n        List<String> result = new ArrayList<>();\n        for (String part : parts) {\n            if (!part.isEmpty()) {\n                result.add(part);\n            }\n        }\n        return result;\n    }\n}","nanoTime":"1501254700"}
{"taskId":"Java/102","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.chooseNum(12, 15) == 14,\n                s.chooseNum(13, 12) == -1,\n                s.chooseNum(33, 12354) == 12354,\n                s.chooseNum(5234, 5233) == -1,\n                s.chooseNum(6, 29) == 28,\n                s.chooseNum(27, 10) == -1,\n                s.chooseNum(7, 7) == -1,\n                s.chooseNum(546, 546) == 546\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    chooseNum(12, 15) = 14\n    chooseNum(13, 12) = -1\n     */\n    public int chooseNum(int x, int y) {\n        // Let's think step by step\n        // Input: x, y (positive integers)\n        // Output: largest even integer in [x, y] or -1\n        // Sequential:\n        // 1. Initialize candidate with y.\n        // Branch:\n        // 2. If x > y, return -1 (empty range).\n        // 3. If candidate is odd, decrement it by 1 to make it even.\n        // Loop:\n        // 4. While candidate is within the range [x, y]:\n        //    - If candidate is even, return it (largest even from the top).\n        //    - Otherwise, decrement candidate by 2 and continue.\n        // 5. If loop ends without finding, return -1.\n        if (x > y) {\n            return -1;\n        }\n        int candidate = y;\n        if ((candidate & 1) == 1) {\n            candidate -= 1;\n        }\n        while (candidate >= x) {\n            if ((candidate & 1) == 0) {\n                return candidate;\n            }\n            candidate -= 2;\n        }\n        return -1;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If\n    there's no such number, then the function should return -1.\n    \n    For example:\n    chooseNum(12, 15) = 14\n    chooseNum(13, 12) = -1\n     */\n    public int chooseNum(int x, int y) {\n        if (x > y) {\n            return -1;\n        }\n        int candidate = (y % 2 == 0) ? y : y - 1;\n        return (candidate >= x) ? candidate : -1;\n    }\n}","nanoTime":"2885589800"}
{"taskId":"Java/103","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals((String) s.roundedAvg(1, 5), \"11\" ),\n                Objects.equals((String) s.roundedAvg(7, 13), \"1010\" ),\n                Objects.equals((String) s.roundedAvg(964, 977), \"1111001011\" ),\n                Objects.equals((String) s.roundedAvg(996, 997), \"1111100101\" ),\n                Objects.equals((String) s.roundedAvg(560, 851), \"1011000010\" ),\n                Objects.equals((String) s.roundedAvg(185, 546), \"101101110\" ),\n                Objects.equals((String) s.roundedAvg(362, 496), \"110101101\" ),\n                Objects.equals((String) s.roundedAvg(350, 902), \"1001110010\" ),\n                Objects.equals((String) s.roundedAvg(197, 233), \"11010111\" ),\n                (int) s.roundedAvg(7, 5) == -1,\n                (int) s.roundedAvg(5, 1) == -1,\n                Objects.equals((String) s.roundedAvg(5, 5), \"101\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m).\n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    roundedAvg(1, 5) => \"11\"\n    roundedAvg(7, 5) => -1\n    roundedAvg(10, 20) => \"1111\"\n    roundedAvg(20, 33) => \"11011\"\n     */\n    public Object roundedAvg(int n, int m) {\n        // Let's think step by step\n        // Input: n, m positive integers\n        // Output: If n > m, return -1 (Integer). Else return a binary string of the rounded average of integers from n through m.\n        // 1. Sequential: Compute the sum of endpoints using long to avoid overflow.\n        // 2. Branch: If n > m, return -1 immediately.\n        // 3. Sequential: The average of consecutive integers n..m is (n + m) / 2; for rounding to nearest integer, use (n + m + 1) / 2.\n        // 4. Loop: Convert the rounded average to binary by repeatedly dividing by 2 and collecting remainders.\n        // 5. Sequential: Return the resulting binary string.\n\n        // Write your code here\n        if (n > m) {\n            return -1;\n        }\n\n        long sumNM = (long) n + (long) m;\n        long rounded = (sumNM + 1L) / 2L;\n\n        // Convert to binary using a loop\n        if (rounded == 0L) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        long val = rounded;\n        while (val > 0) {\n            sb.append((val & 1L) == 1L ? '1' : '0');\n            val >>= 1;\n        }\n        sb.reverse();\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object roundedAvg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n\n        long rounded = (n + m + 1L) / 2L;\n        return Long.toBinaryString(rounded);\n    }\n}","nanoTime":"2112754900"}
{"taskId":"Java/104","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.uniqueDigits(Arrays.asList(15, 33, 1422, 1)).equals(Arrays.asList(1, 15, 33)),\n                s.uniqueDigits(Arrays.asList(152, 323, 1422, 10)).equals(List.of()),\n                s.uniqueDigits(Arrays.asList(12345, 2033, 111, 151)).equals(Arrays.asList(111, 151)),\n                s.uniqueDigits(Arrays.asList(135, 103, 31)).equals(Arrays.asList(31, 135))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of positive integers x. return a sorted list of all\n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> uniqueDigits(Arrays.asList(15, 33, 1422, 1))\n    [1, 15, 33]\n    >>> uniqueDigits(Arrays.asList(152, 323, 1422, 10))\n    []\n     */\n    public List<Integer> uniqueDigits(List<Integer> x) {\n        // Let's think step by step\n        // Input: x, a list of positive integers\n        // Output: a sorted list of integers that contain no even digits\n        // Sequential steps:\n        // 1. Initialize an empty result list.\n        // 2. For each number in x (loop structure):\n        //    a. Check each digit of the number using a loop.\n        //    b. If any digit is even (branch structure), mark and skip adding this number.\n        //    c. Otherwise, add the number to the result list.\n        // 3. Sort the result list in increasing order.\n        // 4. Return the result list.\n\n        List<Integer> result = new ArrayList<>();\n        for (int num : x) { // loop over all numbers\n            boolean hasEvenDigit = false;\n            int n = num;\n            // Check digits of n\n            while (n > 0) { // loop over digits\n                int d = n % 10;\n                if (d % 2 == 0) { // branch: found an even digit\n                    hasEvenDigit = true;\n                    break;\n                }\n                n /= 10;\n            }\n            if (!hasEvenDigit) { // branch: all digits are odd\n                result.add(num);\n            }\n        }\n        Collections.sort(result); // sequential: sort the collected numbers\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> uniqueDigits(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int number : numbers) {\n            if (hasOnlyOddDigits(number)) {\n                result.add(number);\n            }\n        }\n        \n        Collections.sort(result);\n        return result;\n    }\n\n    private boolean hasOnlyOddDigits(int number) {\n        while (number > 0) {\n            if ((number % 10) % 2 == 0) {\n                return false;\n            }\n            number /= 10;\n        }\n        return true;\n    }\n}","nanoTime":"3092096900"}
{"taskId":"Java/105","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.byLength(new ArrayList<>(Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3))).equals(Arrays.asList(\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\" )),\n                s.byLength(new ArrayList<>(List.of())).equals(List.of()),\n                s.byLength(new ArrayList<>(Arrays.asList(1, -1, 55))).equals(List.of(\"One\" )),\n                s.byLength(new ArrayList<>(Arrays.asList(1, -1, 3, 2))).equals(Arrays.asList(\"Three\", \"Two\", \"One\" )),\n                s.byLength(new ArrayList<>(Arrays.asList(9, 4, 8))).equals(Arrays.asList(\"Nine\", \"Eight\", \"Four\" ))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]\n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n      If the array is empty, return an empty array:\n      arr = []\n      return []\n\n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55]\n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = [\"One\"]\n     */\n    public List<String> byLength(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of integers\n        // Output: a list of strings with names of digits 1..9 in descending order\n        // Sequential: Prepare mapping of digits to names and containers for results.\n        // Branch: Handle null or empty input quickly.\n        // Loop + Branch: Traverse the input to filter only numbers in [1, 9].\n        // Sequential: Sort the filtered numbers ascending.\n        // Sequential: Reverse to get descending order.\n        // Loop: Map each digit to its corresponding name and build the result.\n        // Sequential: Return the result list.\n\n        // Prepare name mapping\n        String[] names = new String[] {\n            \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n        };\n\n        // Handle null or empty input\n        if (arr == null || arr.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        // Filter numbers in the range [1, 9]\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) { // Loop\n            if (num != null && num >= 1 && num <= 9) { // Branch\n                filtered.add(num);\n            }\n        }\n\n        // Sort ascending then reverse to get descending\n        Collections.sort(filtered);\n        Collections.reverse(filtered);\n\n        // Map digits to names\n        List<String> result = new ArrayList<>(filtered.size());\n        for (int num : filtered) { // Loop\n            result.add(names[num]);\n        }\n\n        // Return the final list\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> byLength(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        String[] names = {\n            \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n        };\n\n        List<Integer> filtered = new ArrayList<>();\n        for (Integer num : arr) {\n            if (num != null && num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        Collections.sort(filtered, Collections.reverseOrder());\n\n        List<String> result = new ArrayList<>(filtered.size());\n        for (int num : filtered) {\n            result.add(names[num]);\n        }\n\n        return result;\n    }\n}","nanoTime":"2624001300"}
{"taskId":"Java/106","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.f(5).equals(Arrays.asList(1, 2, 6, 24, 15)),\n                s.f(7).equals(Arrays.asList(1, 2, 6, 24, 15, 720, 28)),\n                s.f(1).equals(List.of(1)),\n                s.f(3).equals(Arrays.asList(1, 2, 6))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n        // Let's think step by step\n        // Input: n (size of the list, i from 1 to n)\n        // Output: List<Integer> of size n\n        // Sequential:\n        // 1) Initialize result list, runningSum = 0, runningFact = 1.\n        // Loop:\n        // 2) For i from 1 to n:\n        //    - Update runningSum += i\n        //    - Update runningFact *= i\n        // Branch:\n        //    - If i is even, use runningFact; else use runningSum.\n        // 3) Add the selected value to the list.\n        // 4) Return the result list.\n\n        List<Integer> result = new ArrayList<>();\n        if (n <= 0) return result;\n\n        int runningSum = 0;\n        int runningFact = 1;\n\n        for (int i = 1; i <= n; i++) {\n            runningSum += i;\n            runningFact *= i;\n\n            if (i % 2 == 0) {\n                result.add(runningFact);\n            } else {\n                result.add(runningSum);\n            }\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        if (n <= 0) return result;\n\n        int runningSum = 0;\n        int runningFact = 1;\n\n        for (int i = 1; i <= n; i++) {\n            runningSum += i;\n            runningFact *= i;\n\n            result.add(i % 2 == 0 ? runningFact : runningSum);\n        }\n\n        return result;\n    }\n}","nanoTime":"2182764600"}
{"taskId":"Java/107","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.evenOddPalindrome(123).equals(Arrays.asList(8, 13)),\n                s.evenOddPalindrome(12).equals(Arrays.asList(4, 6)),\n                s.evenOddPalindrome(3).equals(Arrays.asList(1, 2)),\n                s.evenOddPalindrome(63).equals(Arrays.asList(6, 8)),\n                s.evenOddPalindrome(25).equals(Arrays.asList(5, 6)),\n                s.evenOddPalindrome(19).equals(Arrays.asList(4, 6)),\n                s.evenOddPalindrome(9).equals(Arrays.asList(4, 5)),\n                s.evenOddPalindrome(1).equals(Arrays.asList(0, 1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n     */\n    public List<Integer> evenOddPalindrome(int n) {\n        // Let's think step by step\n        // Input: n, a positive integer\n        // Output: List<Integer> -> [evenCount, oddCount]\n        // Sequential:\n        // 1. Initialize counters for even and odd palindromic numbers.\n        // Loop:\n        // 2. For i from 1 to n (inclusive), check if i is a palindrome.\n        // Branch:\n        // 3. If i is a palindrome, then:\n        //    - If i is even, increment evenCount.\n        //    - Else, increment oddCount.\n        // 4. After the loop, construct and return the list [evenCount, oddCount].\n\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n\n    private boolean isPalindrome(int x) {\n        int original = x;\n        int reversed = 0;\n        while (x > 0) {\n            reversed = reversed * 10 + (x % 10);\n            x /= 10;\n        }\n        return reversed == original;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> evenOddPalindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n\n        return List.of(evenCount, oddCount);\n    }\n\n    private boolean isPalindrome(int x) {\n        int original = x;\n        int reversed = 0;\n        while (x > 0) {\n            reversed = reversed * 10 + (x % 10);\n            x /= 10;\n        }\n        return reversed == original;\n    }\n}","nanoTime":"2893350000"}
{"taskId":"Java/108","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countNums(List.of()) == 0,\n                s.countNums(Arrays.asList(-1, -2, 0)) == 0,\n                s.countNums(Arrays.asList(1, 1, 2, -2, 3, 4, 5)) == 6,\n                s.countNums(Arrays.asList(1, 6, 9, -6, 0, 1, 5)) == 5,\n                s.countNums(Arrays.asList(1, 100, 98, -7, 1, -1)) == 4,\n                s.countNums(Arrays.asList(12, 23, 34, -45, -56, 0)) == 5,\n                s.countNums(Arrays.asList(-0, (int) Math.pow(1, 0))) == 1,\n                s.countNums(List.of(1)) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function countNums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> countNums(Arrays.asList()) == 0\n    >>> countNums(Arrays.asList(-1, 11, -11)) == 1\n    >>> countNums(Arrays.asList(1, 1, 2)) == 3\n     */\n    public int countNums(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of integers\n        // Output: count, an integer\n        // Sequential structure:\n        // 1. Initialize a counter to 0.\n        // 2. Traverse each number in the list.\n        // Loop structure:\n        // 3. For each number, compute the sum of its digits:\n        //    - Work in long to safely handle Integer.MIN_VALUE.\n        //    - Get absolute value to extract digits.\n        //    - Accumulate the sum of digits and capture the most significant digit.\n        // Branch structure:\n        // 4. If the original number is negative, make the most significant digit negative\n        //    by subtracting it twice from the total digit sum.\n        // 5. If the resulting signed-digit sum > 0, increment the counter.\n        // 6. Return the counter.\n        int count = 0;\n        for (int x : arr) {\n            long v = x;\n            boolean neg = v < 0;\n            long abs = neg ? -v : v; // safe absolute using long to avoid overflow on Integer.MIN_VALUE\n            long signedSum;\n            if (abs == 0) {\n                signedSum = 0;\n            } else {\n                long temp = abs;\n                long sumPos = 0;\n                long msd = 0;\n                while (temp >= 10) {\n                    sumPos += (temp % 10);\n                    temp /= 10;\n                }\n                msd = temp;        // most significant digit\n                sumPos += msd;     // complete sum of digits of |x|\n                signedSum = neg ? (sumPos - 2 * msd) : sumPos; // apply sign to the first digit\n            }\n            if (signedSum > 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int countNums(List<Integer> arr) {\n        int count = 0;\n        for (int number : arr) {\n            if (isSumOfDigitsPositive(number)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isSumOfDigitsPositive(int number) {\n        long absValue = Math.abs((long) number);\n        long sumOfDigits = calculateSumOfDigits(absValue);\n        return number < 0 ? sumOfDigits - 2 * getMostSignificantDigit(absValue) > 0 : sumOfDigits > 0;\n    }\n\n    private long calculateSumOfDigits(long number) {\n        long sum = 0;\n        while (number > 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        return sum;\n    }\n\n    private long getMostSignificantDigit(long number) {\n        while (number >= 10) {\n            number /= 10;\n        }\n        return number;\n    }\n}","nanoTime":"2991476300"}
{"taskId":"Java/109","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 4, 5, 1, 2))) == true,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 5, 10, 1, 2))) == true,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(4, 3, 1, 2))) == false,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 5, 4, 1, 2))) == false,\n                s.moveOneBall(new ArrayList<>(Arrays.asList())) == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing\n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n\n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index.\n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return False.\n    If the given array is empty then return true.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\n    moveOneBall(Arrays.asList(3, 4, 5, 1, 2))==>true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    moveOneBall(Arrays.asList(3, 5, 4, 1, 2))==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n     */\n    public boolean moveOneBall(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of unique integers (may be empty)\n        // Output: boolean indicating if non-decreasing order can be achieved by right shifts\n        //\n        // Sequential structure:\n        // 1) If arr is null or empty, return true.\n        // 2) Initialize variables: n = arr.size(), drops = 0.\n        //\n        // Loop structure:\n        // 3) For i from 0 to n-1:\n        //    a) curr = arr.get(i)\n        //    b) next = arr.get((i + 1) % n)  // wrap-around comparison\n        //    c) If curr > next, increment drops.\n        //    d) Branch early: if drops > 1, return false.\n        //\n        // Branch structure:\n        // 4) After the loop, if drops <= 1 return true; otherwise false.\n        //    (In this implementation, early return covers drops > 1.)\n        if (arr == null || arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        if (n == 1) {\n            return true;\n        }\n\n        int drops = 0;\n        for (int i = 0; i < n; i++) {\n            int curr = arr.get(i);\n            int next = arr.get((i + 1) % n);\n            if (curr > next) {\n                drops++;\n                if (drops > 1) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean moveOneBall(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) {\n            return true;\n        }\n\n        int n = arr.size();\n        int drops = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (arr.get(i) > arr.get((i + 1) % n)) {\n                drops++;\n                if (drops > 1) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}","nanoTime":"1775386800"}
{"taskId":"Java/110","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)), \"YES\" ),\n                Objects.equals(s.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)), \"NO\" ),\n                Objects.equals(s.exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(2, 1, 4, 3)), \"YES\" ),\n                Objects.equals(s.exchange(Arrays.asList(5, 7, 3), Arrays.asList(2, 6, 4)), \"YES\" ),\n                Objects.equals(s.exchange(Arrays.asList(5, 7, 3), Arrays.asList(2, 6, 3)), \"NO\" ),\n                Objects.equals(s.exchange(Arrays.asList(3, 2, 6, 1, 8, 9), Arrays.asList(3, 5, 5, 1, 1, 1)), \"NO\" ),\n                Objects.equals(s.exchange(Arrays.asList(100, 200), Arrays.asList(200, 200)), \"YES\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4)) => \"YES\"\n    exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4)) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n     */\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Let's think step by step\n        // Input: lst1, lst2 - lists of integers\n        // Output: \"YES\" if we can make all elements in lst1 even via exchanges, else \"NO\"\n        // Plan using sequential, branch, and loop structures:\n        // 1. Sequential: Initialize variables for size of lst1 and total count of even numbers.\n        // 2. Loop: Count even numbers in lst1 and lst2.\n        // 3. Branch: If total even numbers across both lists >= size of lst1, return \"YES\"; else \"NO\".\n        // Rationale: We can swap any number of times; the best we can do is fill lst1 with available evens from both lists.\n        //            This is possible iff the union has at least lst1.size() even numbers.\n\n        // Sequential initialization\n        int n1 = lst1.size();\n        int totalEven = 0;\n\n        // Loop over lst1 and count evens (uses branch inside loop)\n        for (int x : lst1) {\n            if (x % 2 == 0) {\n                totalEven++;\n            }\n        }\n\n        // Loop over lst2 and count evens (uses branch inside loop)\n        for (int x : lst2) {\n            if (x % 2 == 0) {\n                totalEven++;\n            }\n        }\n\n        // Branch to decide feasibility\n        if (totalEven >= n1) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int totalEven = countEvens(lst1) + countEvens(lst2);\n        return totalEven >= lst1.size() ? \"YES\" : \"NO\";\n    }\n\n    private int countEvens(List<Integer> list) {\n        int count = 0;\n        for (int number : list) {\n            if (number % 2 == 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","nanoTime":"3026182700"}
{"taskId":"Java/111","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Map<String, Integer> map1 = new HashMap<>();\n        map1.put(\"a\", 2);\n        map1.put(\"b\", 2);\n        Map<String, Integer> map2 = new HashMap<>();\n        map2.put(\"a\", 2);\n        map2.put(\"b\", 2);\n        Map<String, Integer> map3 = new HashMap<>();\n        map3.put(\"a\", 1);\n        map3.put(\"b\", 1);\n        map3.put(\"c\", 1);\n        map3.put(\"d\", 1);\n        map3.put(\"g\", 1);\n        Map<String, Integer> map4 = new HashMap<>();\n        map4.put(\"r\", 1);\n        map4.put(\"t\", 1);\n        map4.put(\"g\", 1);\n        Map<String, Integer> map5 = new HashMap<>();\n        map5.put(\"b\", 4);\n        Map<String, Integer> map6 = new HashMap<>();\n        map6.put(\"r\", 1);\n        map6.put(\"t\", 1);\n        map6.put(\"g\", 1);\n        Map<String, Integer> map7 = new HashMap<>();\n        Map<String, Integer> map8 = new HashMap<>();\n        map8.put(\"a\", 1);\n        List<Boolean> correct = Arrays.asList(\n                s.histogram(\"a b b a\" ).equals(map1),\n                s.histogram(\"a b c a b\" ).equals(map2),\n                s.histogram(\"a b c d g\" ).equals(map3),\n                s.histogram(\"r t g\" ).equals(map4),\n                s.histogram(\"b b b b a\" ).equals(map5),\n                s.histogram(\"r t g\" ).equals(map6),\n                s.histogram(\"\" ).equals(map7),\n                s.histogram(\"a\" ).equals(map8)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Example:\n    histogram(\"a b c\") == {\"a\": 1, \"b\": 1, \"c\": 1}\n    histogram(\"a b b a\") == {\"a\": 2, \"b\": 2}\n    histogram(\"a b c a b\") == {\"a\": 2, \"b\": 2}\n    histogram(\"b b b b a\") == {\"b\": 4}\n    histogram(\"\") == {}\n     */\n    public Map<String, Integer> histogram(String test) {\n        // Let's think step by step\n        // Input: test, a string of space-separated lowercase letters\n        // Output: a map of the letter(s) with the highest count mapped to that count\n        // 1) Sequential structure:\n        //    - Initialize an empty result map.\n        //    - Trim the input and split it by whitespace to get tokens.\n        //    - Count occurrences for each token.\n        //    - Find the maximum frequency.\n        //    - Build the result map containing only letters with the maximum frequency.\n        // 2) Branch structure:\n        //    - If the input is null or empty after trimming, return an empty map.\n        //    - Skip empty tokens if any.\n        //    - When assembling the result, include a key only if its count equals the max.\n        // 3) Loop structure:\n        //    - Loop over tokens to count frequencies.\n        //    - Loop over counts to determine the maximum.\n        //    - Loop over keys to collect those matching the maximum.\n\n        // Write your code here\n        Map<String, Integer> result = new LinkedHashMap<>();\n\n        if (test == null) {\n            return result;\n        }\n        String trimmed = test.trim();\n        if (trimmed.isEmpty()) {\n            return result;\n        }\n\n        String[] tokens = trimmed.split(\"\\\\s+\");\n        Map<String, Integer> counts = new HashMap<>();\n        for (String token : tokens) {\n            if (token == null || token.isEmpty()) {\n                continue;\n            }\n            counts.put(token, counts.getOrDefault(token, 0) + 1);\n        }\n\n        if (counts.isEmpty()) {\n            return result;\n        }\n\n        int max = 0;\n        for (int c : counts.values()) {\n            if (c > max) {\n                max = c;\n            }\n        }\n\n        // To provide deterministic output order (e.g., alphabetical like in examples)\n        List<String> keys = new ArrayList<>(counts.keySet());\n        Collections.sort(keys);\n        for (String k : keys) {\n            int c = counts.get(k);\n            if (c == max) {\n                result.put(k, c);\n            }\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Map<String, Integer> histogram(String test) {\n        Map<String, Integer> result = new LinkedHashMap<>();\n        if (test == null || test.trim().isEmpty()) {\n            return result;\n        }\n\n        String[] tokens = test.trim().split(\"\\\\s+\");\n        Map<String, Integer> counts = new HashMap<>();\n        for (String token : tokens) {\n            counts.put(token, counts.getOrDefault(token, 0) + 1);\n        }\n\n        int maxCount = Collections.max(counts.values());\n        counts.forEach((key, count) -> {\n            if (count == maxCount) {\n                result.put(key, count);\n            }\n        });\n\n        return result;\n    }\n}","nanoTime":"2760157800"}
{"taskId":"Java/112","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.reverseDelete(\"abcde\", \"ae\" ).equals(Arrays.asList(\"bcd\", false)),\n                s.reverseDelete(\"abcdef\", \"b\" ).equals(Arrays.asList(\"acdef\", false)),\n                s.reverseDelete(\"abcdedcba\", \"ab\" ).equals(Arrays.asList(\"cdedc\", true)),\n                s.reverseDelete(\"dwik\", \"w\" ).equals(Arrays.asList(\"dik\", false)),\n                s.reverseDelete(\"a\", \"a\" ).equals(Arrays.asList(\"\", true)),\n                s.reverseDelete(\"abcdedcba\", \"\" ).equals(Arrays.asList(\"abcdedcba\", true)),\n                s.reverseDelete(\"abcdedcba\", \"v\" ).equals(Arrays.asList(\"abcdedcba\", true)),\n                s.reverseDelete(\"vabba\", \"v\" ).equals(Arrays.asList(\"abba\", true)),\n                s.reverseDelete(\"mamma\", \"mia\" ).equals(Arrays.asList(\"\", true))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and true/false for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be (\"bcd\",false)\n    For s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",false)\n    For s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",true)\n     */\n    public List<Object> reverseDelete(String s, String c) {\n        // Let's think step by step\n        // Input: s, c - strings\n        // Output: [filteredString, isPalindrome]\n        // Sequential steps:\n        // 1) Create a set of characters from c to delete.\n        // 2) Build the filtered string by scanning s.\n        // 3) Check if the filtered string is a palindrome.\n        // Branching:\n        // - If current character should be deleted, skip appending; else append.\n        // - While checking palindrome, if mismatch found, decide result as false.\n        // Looping:\n        // - Loop over characters of c to fill the set.\n        // - Loop over characters of s to build filtered string.\n        // - Loop with two pointers to verify palindrome.\n\n        // Write your code here\n        Set<Character> del = new HashSet<>();\n        for (int i = 0; i < c.length(); i++) {\n            del.add(c.charAt(i));\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (!del.contains(ch)) { // branch\n                sb.append(ch);\n            }\n        }\n\n        String filtered = sb.toString();\n\n        boolean isPal = true;\n        int l = 0, r = filtered.length() - 1;\n        while (l < r) { // loop\n            if (filtered.charAt(l) != filtered.charAt(r)) { // branch\n                isPal = false;\n                break;\n            }\n            l++;\n            r--;\n        }\n\n        List<Object> res = new ArrayList<>();\n        res.add(filtered);\n        res.add(isPal);\n        return res;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Object> reverseDelete(String s, String c) {\n        Set<Character> del = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            del.add(ch);\n        }\n\n        StringBuilder filteredString = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (!del.contains(ch)) {\n                filteredString.append(ch);\n            }\n        }\n\n        String result = filteredString.toString();\n        boolean isPalindrome = isPalindrome(result);\n\n        return Arrays.asList(result, isPalindrome);\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}","nanoTime":"3013443600"}
{"taskId":"Java/113","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.oddCount(List.of(\"1234567\" )).equals(List.of(\"the number of odd elements 4n the str4ng 4 of the 4nput.\" )),\n                s.oddCount(Arrays.asList(\"3\", \"11111111\" )).equals(Arrays.asList(\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\" )),\n                s.oddCount(Arrays.asList(\"271\", \"137\", \"314\" )).equals(Arrays.asList(\n                        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n                        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n                        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n                ))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i\"th string of the input.\n\n    >>> oddCount(Arrays.asList(\"1234567\"))\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> oddCount(Arrays.asList(\"3\",\"11111111\"))\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n     */\n    public List<String> oddCount(List<String> lst) {\n        // Let's think step by step\n        // Input: lst, a list of digit-only strings\n        // Output: a list of sentences with 'i' replaced by the count of odd digits in each string\n        // Sequential structure:\n        // 1. Define the template sentence.\n        // 2. Prepare an output list.\n        // Loop structure:\n        // 3. For each string s in lst:\n        //    a. Initialize a counter for odd digits.\n        //    b. Loop over characters in s to count odd digits.\n        // Branch structure:\n        //    c. If a character is an odd digit, increment the counter.\n        // 4. Replace every 'i' in the template with the counted number.\n        // 5. Add the result to the output list and continue for all inputs.\n        // 6. Return the output list.\n\n        String template = \"the number of odd elements in the string i of the input.\";\n        List<String> result = new ArrayList<>();\n\n        for (String s : lst) {\n            int count = 0;\n            for (int idx = 0; idx < s.length(); idx++) {\n                char ch = s.charAt(idx);\n                if ((ch - '0') % 2 != 0) {\n                    count++;\n                }\n            }\n            String sentence = template.replace(\"i\", Integer.toString(count));\n            result.add(sentence);\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> oddCount(List<String> lst) {\n        String template = \"the number of odd elements in the string %d of the input.\";\n        List<String> result = new ArrayList<>();\n\n        for (String s : lst) {\n            int count = countOddDigits(s);\n            result.add(String.format(template, count));\n        }\n\n        return result;\n    }\n\n    private int countOddDigits(String s) {\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if ((ch - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","nanoTime":"2720995200"}
{"taskId":"Java/114","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1,\n                s.minSubArraySum(Arrays.asList(-1, -2, -3)) == -6,\n                s.minSubArraySum(Arrays.asList(-1, -2, -3, 2, -10)) == -14,\n                s.minSubArraySum(List.of(-999999999)) == -999999999,\n                s.minSubArraySum(Arrays.asList(0, 10, 20, 1000000)) == 0,\n                s.minSubArraySum(Arrays.asList(-1, -2, -3, 10, -5)) == -6,\n                s.minSubArraySum(Arrays.asList(100, -1, -2, -3, 10, -5)) == -6,\n                s.minSubArraySum(Arrays.asList(10, 11, 13, 8, 3, 4)) == 3,\n                s.minSubArraySum(Arrays.asList(100, -33, 32, -1, 0, -2)) == -33,\n                s.minSubArraySum(List.of(-10)) == -10,\n                s.minSubArraySum(List.of(7)) == 7,\n                s.minSubArraySum(Arrays.asList(1, -1)) == -1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum(Arrays.asList(2, 3, 4, 1, 2, 4)) == 1\n    minSubArraySum(Arrays.asList(-1, -2, -3)) == -6\n     */\n    public int minSubArraySum(List<Integer> nums) {\n        // Let's think step by step\n        // Input: nums, a list of integers\n        // Output: minSum, an integer\n        // 1. Sequential: Initialize variables to track the minimum sum ending at the current index and the global minimum.\n        // 2. Loop: Iterate through the array from the second element to the end.\n        // 3. Branch: At each step, decide whether to start a new subarray at the current element or extend the previous one to minimize the sum.\n        // 4. Branch: Update the global minimum if the current minimum ending here is smaller.\n        // 5. Sequential: Return the global minimum sum.\n        // Write your code here\n\n        if (nums == null || nums.isEmpty()) {\n            return 0;\n        }\n\n        int minEndingHere = nums.get(0);\n        int minSoFar = nums.get(0);\n\n        for (int i = 1; i < nums.size(); i++) {\n            int x = nums.get(i);\n\n            if (minEndingHere + x < x) {\n                minEndingHere = minEndingHere + x;\n            } else {\n                minEndingHere = x;\n            }\n\n            if (minEndingHere < minSoFar) {\n                minSoFar = minEndingHere;\n            }\n        }\n\n        return minSoFar;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int minSubArraySum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            return 0;\n        }\n\n        int minEndingHere = nums.get(0);\n        int minSoFar = minEndingHere;\n\n        for (int i = 1; i < nums.size(); i++) {\n            int current = nums.get(i);\n            minEndingHere = Math.min(minEndingHere + current, current);\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n\n        return minSoFar;\n    }\n}","nanoTime":"2761874400"}
{"taskId":"Java/115","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.maxFill(Arrays.asList(Arrays.asList(0, 0, 1, 0), Arrays.asList(0, 1, 0, 0), Arrays.asList(1, 1, 1, 1)), 1) == 6,\n                s.maxFill(Arrays.asList(Arrays.asList(0, 0, 1, 1), Arrays.asList(0, 0, 0, 0), Arrays.asList(1, 1, 1, 1), Arrays.asList(0, 1, 1, 1)), 2) == 5,\n                s.maxFill(Arrays.asList(Arrays.asList(0, 0, 0), Arrays.asList(0, 0, 0)), 5) == 0,\n                s.maxFill(Arrays.asList(Arrays.asList(1, 1, 1, 1), Arrays.asList(1, 1, 1, 1)), 2) == 4,\n                s.maxFill(Arrays.asList(Arrays.asList(1, 1, 1, 1), Arrays.asList(1, 1, 1, 1)), 9) == 2\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it,\n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input:\n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input:\n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n\n    Example 3:\n        Input:\n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n     */\n    public int maxFill(List<List<Integer>> grid, int capacity) {\n        // Let's think step by step\n        // Input: grid (list of rows/wells with 0/1 cells), capacity (bucket capacity per well)\n        // Output: total number of times buckets are lowered across all wells\n\n        // Sequential structure:\n        // 1) Initialize a counter for total lowerings.\n        // 2) For each well (row), count the number of water units.\n        // 3) Compute the number of lowerings for that well as ceil(waterUnits / capacity).\n        // 4) Accumulate into the total and return it.\n\n        // Branch structure:\n        // - While counting, if a cell is 1, increment the water count, else skip.\n        // - If a well has 0 water units, it contributes 0 lowerings.\n\n        // Loop structure:\n        // - Loop over all rows (wells).\n        // - Nested loop over all cells in each row.\n\n        int totalLowerings = 0;\n\n        for (int i = 0; i < grid.size(); i++) {\n            List<Integer> row = grid.get(i);\n            int waterUnits = 0;\n\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == 1) { // branch\n                    waterUnits++;\n                }\n            }\n\n            if (waterUnits > 0) { // branch\n                int lowers = (waterUnits + capacity - 1) / capacity; // ceil division\n                totalLowerings += lowers;\n            }\n        }\n\n        return totalLowerings;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int maxFill(List<List<Integer>> grid, int capacity) {\n        int totalLowerings = 0;\n\n        for (List<Integer> row : grid) {\n            int waterUnits = 0;\n\n            for (int cell : row) {\n                waterUnits += cell; // Directly sum the water units\n            }\n\n            totalLowerings += (waterUnits + capacity - 1) / capacity; // Accumulate lowerings\n        }\n\n        return totalLowerings;\n    }\n}","nanoTime":"3113385300"}
{"taskId":"Java/117","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.selectWords(\"Mary had a little lamb\", 4).equals(List.of(\"little\" )),\n                s.selectWords(\"Mary had a little lamb\", 3).equals(Arrays.asList(\"Mary\", \"lamb\")),\n                s.selectWords(\"simple white space\", 2).equals(List.of()),\n                s.selectWords(\"Hello world\", 4).equals(List.of(\"world\" )),\n                s.selectWords(\"Uncle sam\", 3).equals(List.of(\"Uncle\" )),\n                s.selectWords(\"\", 4).equals(List.of()),\n                s.selectWords(\"a b c d e f\", 1).equals(Arrays.asList(\"b\", \"c\", \"d\", \"f\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string s and a natural number n, you have been tasked to implement\n    a function that returns a list of all words from string s that contain exactly\n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    selectWords(\"simple white space\", 2) ==> []\n    selectWords(\"Hello world\", 4) ==> [\"world\"]\n    selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     */\n    public List<String> selectWords(String s, int n) {\n        // Let's think step by step\n        // Input: s (string containing only letters and spaces), n (natural number)\n        // Output: list of words with exactly n consonants, preserving order\n        // Sequential: prepare result container\n        List<String> result = new ArrayList<>();\n\n        // Branch: handle null or empty string\n        if (s == null) {\n            return result;\n        }\n        String trimmed = s.trim();\n        if (trimmed.isEmpty()) {\n            return result;\n        }\n\n        // Sequential: split the string into words (handle multiple spaces)\n        String[] words = trimmed.split(\"\\\\s+\");\n\n        // Loop: iterate over each word\n        for (String word : words) {\n            int consonants = 0;\n\n            // Loop: iterate over characters of the word to count consonants\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                char lc = Character.toLowerCase(c);\n\n                // Branch: count if the character is a consonant (a letter that is not a, e, i, o, u)\n                if (lc >= 'a' && lc <= 'z') {\n                    if (!(lc == 'a' || lc == 'e' || lc == 'i' || lc == 'o' || lc == 'u')) {\n                        consonants++;\n                    }\n                }\n            }\n\n            // Branch: if the word has exactly n consonants, add to result\n            if (consonants == n) {\n                result.add(word);\n            }\n        }\n\n        // Sequential: return the result\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> selectWords(String s, int n) {\n        List<String> result = new ArrayList<>();\n        if (s == null || s.trim().isEmpty()) {\n            return result;\n        }\n\n        String[] words = s.trim().split(\"\\\\s+\");\n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n\n    private int countConsonants(String word) {\n        int consonants = 0;\n        for (char c : word.toLowerCase().toCharArray()) {\n            if (Character.isLetter(c) && !isVowel(c)) {\n                consonants++;\n            }\n        }\n        return consonants;\n    }\n\n    private boolean isVowel(char c) {\n        return \"aeiou\".indexOf(c) >= 0;\n    }\n}","nanoTime":"2915762200"}
{"taskId":"Java/118","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getClosestVowel(\"yogurt\").equals(\"u\"),\n                s.getClosestVowel(\"full\").equals(\"u\"),\n                s.getClosestVowel(\"easy\").equals(\"\"),\n                s.getClosestVowel(\"eAsy\").equals(\"\"),\n                s.getClosestVowel(\"ali\").equals(\"\"),\n                s.getClosestVowel(\"bad\").equals(\"a\"),\n                s.getClosestVowel(\"most\").equals(\"o\"),\n                s.getClosestVowel(\"ab\").equals(\"\"),\n                s.getClosestVowel(\"ba\").equals(\"\"),\n                s.getClosestVowel(\"quick\").equals(\"\"),\n                s.getClosestVowel(\"anime\").equals(\"i\"),\n                s.getClosestVowel(\"Asia\").equals(\"\"),\n                s.getClosestVowel(\"Above\").equals(\"o\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a word. Your task is to find the closest vowel that stands between\n    two consonants from the right side of the word (case sensitive).\n\n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition.\n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    getClosestVowel(\"yogurt\") ==> \"u\"\n    getClosestVowel(\"FULL\") ==> \"U\"\n    getClosestVowel(\"quick\") ==> \"\"\n    getClosestVowel(\"ab\") ==> \"\"\n     */\n    public String getClosestVowel(String word) {\n        // Let's think step by step\n        // Input: word, a string of English letters\n        // Output: a string containing the closest vowel from the right that is between two consonants, or \"\" if none\n        // Sequential:\n        // 1. If the length of the word is less than 3, return \"\" (no char can be between two others).\n        // 2. Define what vowels are (case-sensitive: aeiou and AEIOU).\n        // Loop:\n        // 3. Iterate from the second-to-last character down to the second character (right to left).\n        // Branch:\n        // 4. For each position i, if word[i] is a vowel AND word[i-1] is a consonant AND word[i+1] is a consonant, return that vowel.\n        // 5. If the loop finishes without finding such a vowel, return \"\".\n\n        if (word == null || word.length() < 3) {\n            return \"\";\n        }\n\n        for (int i = word.length() - 2; i >= 1; i--) {\n            char c = word.charAt(i);\n            if (isVowel(c)) {\n                char left = word.charAt(i - 1);\n                char right = word.charAt(i + 1);\n                if (!isVowel(left) && !isVowel(right)) {\n                    return String.valueOf(c);\n                }\n            }\n        }\n\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n            || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String getClosestVowel(String word) {\n        if (word == null || word.length() < 3) {\n            return \"\";\n        }\n\n        for (int i = word.length() - 2; i >= 1; i--) {\n            char currentChar = word.charAt(i);\n            if (isVowel(currentChar) && isConsonant(word.charAt(i - 1)) && isConsonant(word.charAt(i + 1))) {\n                return String.valueOf(currentChar);\n            }\n        }\n\n        return \"\";\n    }\n\n    private boolean isVowel(char c) {\n        return \"aeiouAEIOU\".indexOf(c) != -1;\n    }\n\n    private boolean isConsonant(char c) {\n        return Character.isLetter(c) && !isVowel(c);\n    }\n}","nanoTime":"3553211400"}
{"taskId":"Java/119","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.matchParens(Arrays.asList(\"()(\", \")\")).equals(\"Yes\"),\n                s.matchParens(Arrays.asList(\")\", \")\")).equals(\"No\"),\n                s.matchParens(Arrays.asList(\"(()(())\", \"())())\")).equals(\"No\"),\n                s.matchParens(Arrays.asList(\")())\", \"(()()(\")).equals(\"Yes\"),\n                s.matchParens(Arrays.asList(\"(())))\", \"(()())((\")).equals(\"Yes\"),\n                s.matchParens(Arrays.asList(\"()\", \"())\")).equals(\"No\"),\n                s.matchParens(Arrays.asList(\"(()(\", \"()))()\")).equals(\"Yes\"),\n                s.matchParens(Arrays.asList(\"((((\", \"((())\")).equals(\"No\"),\n                s.matchParens(Arrays.asList(\")(()\", \"(()(\")).equals(\"No\"),\n                s.matchParens(Arrays.asList(\")(\", \")(\")).equals(\"No\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of two strings, both strings consist of open\n    parentheses \"(\" or close parentheses \")\" only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string \"(())()\" is good, while the string\n    \"())\" is not.\n    Return \"Yes\" if there\"s a way to make a good string, and return \"No\" otherwise.\n\n    Examples:\n    matchParens(Arrays.asList(\"()(\", \")\")) == \"Yes\"\n    matchParens(Arrays.asList(\")\", \")\")) == \"No\"\n     */\n    public String matchParens(List<String> lst) {\n        // Let's think step by step\n        // Input: lst, a list containing exactly two strings consisting of '(' and ')'\n        // Output: \"Yes\" if there exists an order of concatenation producing a balanced string, else \"No\"\n        //\n        // Sequential structure:\n        // 1) Extract the two strings s1 and s2 from the list.\n        // 2) Define a helper to check if a string of parentheses is balanced (good).\n        //\n        // Branch structure:\n        // 3) If isGood(s1 + s2) OR isGood(s2 + s1) is true, return \"Yes\"; otherwise return \"No\".\n        //\n        // Loop structure (inside helper):\n        // 4) Iterate over characters, maintain a running balance; if it goes negative at any point, it's not balanced.\n        // 5) After the loop, it's balanced iff the final balance is zero.\n\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n\n        if (isGood(s1 + s2) || isGood(s2 + s1)) {\n            return \"Yes\";\n        }\n        return \"No\";\n    }\n\n    private boolean isGood(String s) {\n        int bal = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                bal++;\n            } else {\n                bal--;\n            }\n            if (bal < 0) {\n                return false;\n            }\n        }\n        return bal == 0;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String matchParens(List<String> lst) {\n        String s1 = lst.get(0);\n        String s2 = lst.get(1);\n\n        return (isGood(s1 + s2) || isGood(s2 + s1)) ? \"Yes\" : \"No\";\n    }\n\n    private boolean isGood(String s) {\n        int balance = 0;\n        for (char c : s.toCharArray()) {\n            balance += (c == '(') ? 1 : -1;\n            if (balance < 0) {\n                return false;\n            }\n        }\n        return balance == 0;\n    }\n}","nanoTime":"2350410600"}
{"taskId":"Java/120","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.maximum(new ArrayList<>(Arrays.asList(-3, -4, 5)), 3).equals(Arrays.asList(-4, -3, 5)),\n                s.maximum(new ArrayList<>(Arrays.asList(4, -4, 4)), 2).equals(Arrays.asList(4, 4)),\n                s.maximum(new ArrayList<>(Arrays.asList(-3, 2, 1, 2, -1, -2, 1)), 1).equals(List.of(2)),\n                s.maximum(new ArrayList<>(Arrays.asList(123, -123, 20, 0 , 1, 2, -3)), 3).equals(Arrays.asList(2, 20, 123)),\n                s.maximum(new ArrayList<>(Arrays.asList(-123, 20, 0 , 1, 2, -3)), 4).equals(Arrays.asList(0, 1, 2, 20)),\n                s.maximum(new ArrayList<>(Arrays.asList(5, 15, 0, 3, -13, -8, 0)), 7).equals(Arrays.asList(-13, -8, 0, 0, 3, 5, 15)),\n                s.maximum(new ArrayList<>(Arrays.asList(-1, 0, 2, 5, 3, -10)), 2).equals(Arrays.asList(3, 5)),\n                s.maximum(new ArrayList<>(Arrays.asList(1, 0, 5, -7)), 1).equals(List.of(5)),\n                s.maximum(new ArrayList<>(Arrays.asList(4, -4)), 2).equals(Arrays.asList(-4, 4)),\n                s.maximum(new ArrayList<>(Arrays.asList(-10, 10)), 2).equals(Arrays.asList(-10, 10))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array arr of integers and a positive integer k, return a sorted list\n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n     */\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        // Let's think step by step\n        // Input: arr (List<Integer>), k (int)\n        // Output: a sorted List<Integer> of length k containing the k largest numbers from arr\n        // Sequential structure:\n        // 1) Determine n = arr.size().\n        // 2) Create a copy of arr and sort it in non-decreasing order.\n        // Branch structure:\n        // - If k == 0, return an empty list.\n        // - If k >= n, return the entire sorted copy.\n        // Loop structure:\n        // - Iterate from index n - k to n - 1 and collect elements into the result list.\n        // Write your code here\n\n        int n = arr.size();\n\n        // Branch: handle k == 0\n        if (k == 0) {\n            return new ArrayList<>();\n        }\n\n        // Sequential: copy and sort the array ascending\n        List<Integer> copy = new ArrayList<>(arr);\n        Collections.sort(copy);\n\n        // Branch: if k >= n, return the whole sorted list\n        if (k >= n) {\n            return new ArrayList<>(copy);\n        }\n\n        // Loop: collect the last k (largest) elements; they remain sorted ascending\n        List<Integer> result = new ArrayList<>(k);\n        for (int i = n - k; i < n; i++) {\n            result.add(copy.get(i));\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> maximum(List<Integer> arr, int k) {\n        if (k == 0) {\n            return Collections.emptyList();\n        }\n\n        List<Integer> sortedList = new ArrayList<>(arr);\n        Collections.sort(sortedList);\n\n        int size = sortedList.size();\n        if (k >= size) {\n            return new ArrayList<>(sortedList);\n        }\n\n        return new ArrayList<>(sortedList.subList(size - k, size));\n    }\n}","nanoTime":"2286487200"}
{"taskId":"Java/121","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.solution(Arrays.asList(5, 8, 7, 1)) == 12,\n                s.solution(Arrays.asList(3, 3, 3, 3, 3)) == 9,\n                s.solution(Arrays.asList(30, 13, 24, 321)) == 0,\n                s.solution(Arrays.asList(5, 9)) == 5,\n                s.solution(Arrays.asList(2, 4, 8)) == 0,\n                s.solution(Arrays.asList(30, 13, 23, 32)) == 23,\n                s.solution(Arrays.asList(3, 13, 2, 9)) == 3\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution(Arrays.asList(5, 8, 7, 1)) ==> 12\n    solution(Arrays.asList(3, 3, 3, 3, 3)) ==> 9\n    solution(Arrays.asList(30, 13, 24, 321)) ==>0\n     */\n    public int solution(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a non-empty list of integers\n        // Output: sum, the sum of odd elements at even indices (0-based)\n        // Sequential: Initialize an accumulator variable \"sum\" to 0.\n        // Loop: Traverse the list at even indices i = 0, 2, 4, ... using a for-loop with step 2.\n        // Branch: For each visited element, check if it is odd; if so, add it to \"sum\".\n        // Return the accumulated \"sum\".\n        int sum = 0; // sequential\n        for (int i = 0; i < lst.size(); i += 2) { // loop\n            int val = lst.get(i);\n            if (val % 2 != 0) { // branch\n                sum += val;\n            }\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int solution(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i += 2) {\n            if (lst.get(i) % 2 != 0) {\n                sum += lst.get(i);\n            }\n        }\n        return sum;\n    }\n}","nanoTime":"1417462600"}
{"taskId":"Java/122","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.addElements(Arrays.asList(1, -2, -3, 41, 57, 76, 87, 88, 99), 3) == -4,\n                s.addElements(Arrays.asList(111, 121, 3, 4000, 5, 6), 2) == 0,\n                s.addElements(Arrays.asList(11, 21, 3, 90, 5, 6, 7, 8, 9), 4) == 125,\n                s.addElements(Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4) == 24,\n                s.addElements(Arrays.asList(1), 1) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n     */\n    public int addElements(List<Integer> arr, int k) {\n        // Let's think step by step\n        // Input: arr (List<Integer>), k (int)\n        // Output: sum (int)\n        // Sequential structure:\n        // 1. Initialize a running sum to 0.\n        // Loop structure:\n        // 2. Iterate i from 0 to k - 1 over the first k elements.\n        // Sequential within loop:\n        //    a. Read current value and compute its absolute value safely.\n        // Branch structure:\n        //    b. If absolute value has at most two digits (<= 99), add it to sum.\n        // Loop continues until i reaches k.\n        // Sequential:\n        // 3. Return the computed sum.\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            int val = arr.get(i);\n            long absVal = Math.abs((long) val); // avoid overflow for Integer.MIN_VALUE\n            if (absVal <= 99) {\n                sum += val;\n            }\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int addElements(List<Integer> arr, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            int val = arr.get(i);\n            if (Math.abs(val) <= 99) {\n                sum += val;\n            }\n        }\n        return sum;\n    }\n}","nanoTime":"2233493300"}
{"taskId":"Java/123","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getOddCollatz(14).equals(Arrays.asList(1, 5, 7, 11, 13, 17)),\n                s.getOddCollatz(5).equals(Arrays.asList(1, 5)),\n                s.getOddCollatz(12).equals(Arrays.asList(1, 3, 5)),\n                s.getOddCollatz(1).equals(List.of(1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the\n    previous term as follows: if the previous term is even, the next term is one half of\n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n     */\n    public List<Integer> getOddCollatz(int n) {\n        // Let's think step by step\n        // Input: n, a positive integer\n        // Output: a sorted list of odd numbers appearing in the Collatz sequence starting at n\n        // Sequential structure:\n        // 1) Initialize a sorted set to collect unique odd numbers.\n        // 2) Initialize a variable \"curr\" with n.\n        // Loop structure:\n        // 3) While true, process the current number in the sequence:\n        // Branch structure:\n        //    a) If \"curr\" is odd, add it to the set.\n        //    b) If \"curr\" is 1, break out of the loop (sequence ends).\n        //    c) Else, update \"curr\": if even -> curr = curr / 2; else -> curr = 3 * curr + 1.\n        // 4) After the loop, convert the sorted set to a list and return it.\n        TreeSet<Integer> odds = new TreeSet<>();\n        long curr = n; // use long to reduce overflow risk during 3*curr+1\n        while (true) {\n            if ((curr & 1L) == 1L) {\n                odds.add((int) curr);\n            }\n            if (curr == 1L) {\n                break;\n            }\n            if ((curr & 1L) == 0L) {\n                curr = curr / 2L;\n            } else {\n                curr = 3L * curr + 1L;\n            }\n        }\n        return new ArrayList<>(odds);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> getOddCollatz(int n) {\n        Set<Integer> odds = new TreeSet<>();\n        long curr = n;\n\n        while (curr != 1) {\n            if ((curr & 1) == 1) {\n                odds.add((int) curr);\n            }\n            curr = (curr & 1) == 0 ? curr / 2 : 3 * curr + 1;\n        }\n        odds.add(1); // Add 1 explicitly since the loop ends when curr is 1\n        return new ArrayList<>(odds);\n    }\n}","nanoTime":"4763154000"}
{"taskId":"Java/124","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.validDate(\"03-11-2000\" ) == true,\n                s.validDate(\"15-01-2012\" ) == false,\n                s.validDate(\"04-0-2040\" ) == false,\n                s.validDate(\"06-04-2020\" ) == true,\n                s.validDate(\"01-01-2007\" ) == true,\n                s.validDate(\"03-32-2011\" ) == false,\n                s.validDate(\"\" ) == false,\n                s.validDate(\"04-31-3000\" ) == false,\n                s.validDate(\"06-06-2005\" ) == true,\n                s.validDate(\"21-31-2000\" ) == false,\n                s.validDate(\"04-12-2003\" ) == true,\n                s.validDate(\"04122003\" ) == false,\n                s.validDate(\"20030412\" ) == false,\n                s.validDate(\"2003-04\" ) == false,\n                s.validDate(\"2003-04-12\" ) == false,\n                s.validDate(\"04-2003\" ) == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You have to write a function which validates a given date string and\n    returns true if the date is valid otherwise false.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example:\n    validDate(\"03-11-2000\") => true\n    validDate(\"15-01-2012\") => false\n    validDate(\"04-0-2040\") => false\n    validDate(\"06-04-2020\") => true\n    validDate(\"06/04/2020\") => false\n     */\n    public boolean validDate(String date) {\n        // Let's think step by step\n        // Input: date, a string\n        // Output: boolean indicating validity\n        // 1. Sequential: Check for null or empty string.\n        // 2. Sequential: Verify exact length (10) and '-' at positions 2 and 5 (mm-dd-yyyy).\n        // 3. Loop: Ensure all other characters are digits.\n        // 4. Sequential: Parse month, day, year from substrings.\n        // 5. Branch: Validate month is between 1 and 12.\n        // 6. Branch: Determine max days for the given month (Feb up to 29 as per problem).\n        // 7. Branch: Validate day range [1..maxDays].\n        // 8. Sequential: Return true if all checks pass, otherwise false.\n\n        if (date == null || date.isEmpty()) {\n            return false;\n        }\n        if (date.length() != 10) {\n            return false;\n        }\n        if (date.charAt(2) != '-' || date.charAt(5) != '-') {\n            return false;\n        }\n\n        for (int i = 0; i < date.length(); i++) {\n            if (i == 2 || i == 5) continue;\n            char c = date.charAt(i);\n            if (!Character.isDigit(c)) {\n                return false;\n            }\n        }\n\n        int month = Integer.parseInt(date.substring(0, 2));\n        int day = Integer.parseInt(date.substring(3, 5));\n        int year = Integer.parseInt(date.substring(6, 10)); // year can be any 4-digit number\n\n        if (month < 1 || month > 12) {\n            return false;\n        }\n\n        int maxDays;\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            maxDays = 31;\n        } else if (month == 2) {\n            maxDays = 29; // As per problem statement, allow up to 29 days in February\n        } else {\n            maxDays = 30;\n        }\n\n        if (day < 1 || day > maxDays) {\n            return false;\n        }\n\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean validDate(String date) {\n        if (isInvalidDate(date)) {\n            return false;\n        }\n\n        int month = Integer.parseInt(date.substring(0, 2));\n        int day = Integer.parseInt(date.substring(3, 5));\n\n        return isValidMonth(month) && isValidDay(month, day);\n    }\n\n    private boolean isInvalidDate(String date) {\n        return date == null || date.isEmpty() || date.length() != 10 || date.charAt(2) != '-' || date.charAt(5) != '-' || !areAllDigits(date);\n    }\n\n    private boolean areAllDigits(String date) {\n        for (int i = 0; i < date.length(); i++) {\n            if (i == 2 || i == 5) continue;\n            if (!Character.isDigit(date.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isValidMonth(int month) {\n        return month >= 1 && month <= 12;\n    }\n\n    private boolean isValidDay(int month, int day) {\n        int maxDays = getMaxDaysInMonth(month);\n        return day >= 1 && day <= maxDays;\n    }\n\n    private int getMaxDaysInMonth(int month) {\n        switch (month) {\n            case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n                return 31;\n            case 2:\n                return 29;\n            case 4: case 6: case 9: case 11:\n                return 30;\n            default:\n                return 0;\n        }\n    }\n}","nanoTime":"4463548400"}
{"taskId":"Java/125","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.splitWords(\"Hello world!\" ), Arrays.asList(\"Hello\", \"world!\" )),\n                Objects.equals(s.splitWords(\"Hello,world!\" ), Arrays.asList(\"Hello\", \"world!\" )),\n                Objects.equals(s.splitWords(\"Hello world,!\" ), Arrays.asList(\"Hello\", \"world,!\" )),\n                Objects.equals(s.splitWords(\"Hello,Hello,world !\" ), Arrays.asList(\"Hello,Hello,world\", \"!\" )),\n                Objects.equals(s.splitWords(\"abcdef\" ), 3),\n                Objects.equals(s.splitWords(\"aaabb\" ), 2),\n                Objects.equals(s.splitWords(\"aaaBb\" ), 1),\n                Objects.equals(s.splitWords(\"\" ), 0)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    splitWords(\"Hello world!\") == [\"Hello\", \"world!\"]\n    splitWords(\"Hello,world!\") == [\"Hello\", \"world!\"]\n    splitWords(\"abcdef\") == 3\n     */\n    public Object splitWords(String txt) {\n        // Let's think step by step\n        // Input: txt, a String\n        // Output: either a List<String> or an Integer\n        // Sequential steps:\n        // 1) Determine whether the text contains any whitespace characters.\n        // 2) If whitespace exists (branch), split on whitespace and return the list.\n        // 3) Else, determine whether the text contains any commas (branch).\n        // 4) If commas exist (branch), split on commas and return the list.\n        // 5) Else, loop through characters and count lowercase letters with odd alphabetical index; return the count.\n\n        // Check for whitespace using a loop (loop + branch)\n        boolean hasWhitespace = false;\n        for (int i = 0; i < txt.length(); i++) {\n            if (Character.isWhitespace(txt.charAt(i))) {\n                hasWhitespace = true;\n                break;\n            }\n        }\n\n        // Branch: Split on whitespace if present\n        if (hasWhitespace) {\n            String[] parts = txt.trim().split(\"\\\\s+\");\n            return Arrays.asList(parts);\n        }\n\n        // Check for commas\n        boolean hasComma = txt.indexOf(',') >= 0;\n\n        // Branch: Split on commas if present\n        if (hasComma) {\n            String[] parts = txt.split(\",+\");\n            return Arrays.asList(parts);\n        }\n\n        // Loop: Count lowercase letters with odd order (a=0, b=1, ..., z=25)\n        int count = 0;\n        for (int i = 0; i < txt.length(); i++) {\n            char c = txt.charAt(i);\n            if (c >= 'a' && c <= 'z') {\n                int idx = c - 'a';\n                if ((idx & 1) == 1) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Object splitWords(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return 0;\n        }\n\n        if (txt.contains(\" \")) {\n            return Arrays.asList(txt.trim().split(\"\\\\s+\"));\n        }\n\n        if (txt.contains(\",\")) {\n            return Arrays.asList(txt.split(\",\\\\s*\"));\n        }\n\n        return countOddLowerCaseLetters(txt);\n    }\n\n    private int countOddLowerCaseLetters(String txt) {\n        int count = 0;\n        for (char c : txt.toCharArray()) {\n            if (Character.isLowerCase(c) && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}","nanoTime":"2231303500"}
{"taskId":"Java/126","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isSorted(new ArrayList<>(List.of(5))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 3, 2, 4, 5))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 3, 2, 4, 5, 6, 7))) == false,\n                s.isSorted(new ArrayList<>(List.of())) == true,\n                s.isSorted(new ArrayList<>(List.of(1))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(3, 2, 1))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 2, 2, 3, 4))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 3, 3, 4))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 2, 3, 3, 4))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4))) == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return false. Assume no negative numbers and only integers.\n\n    Examples\n    isSorted(Arrays.asList(5)) -> true\n    isSorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n    isSorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n    isSorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n    isSorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n    isSorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n    isSorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n    isSorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean isSorted(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a list of non-negative integers\n        // Output: boolean indicating if lst is non-decreasing and no number appears more than twice\n        // Plan (using sequential, branch, and loop structures):\n        // 1. Sequential: Handle trivial cases (null or size <= 1) -> return true.\n        // 2. Sequential: Initialize variables: prev = first element, runCount = 1.\n        // 3. Loop: For each element from index 1 to end:\n        //    - Branch: If current < prev -> not sorted -> return false.\n        //    - Branch: Else if current == prev -> increment runCount; if runCount > 2 -> return false.\n        //    - Branch: Else (current > prev) -> reset runCount to 1 and update prev.\n        // 4. Sequential: If loop completes, return true.\n\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int prev = lst.get(0);\n        int runCount = 1;\n\n        for (int i = 1; i < lst.size(); i++) {\n            int curr = lst.get(i);\n\n            if (curr < prev) {\n                return false; // not ascending\n            } else if (curr == prev) {\n                runCount++;\n                if (runCount > 2) {\n                    return false; // more than one duplicate (i.e., appears 3+ times)\n                }\n            } else { // curr > prev\n                prev = curr;\n                runCount = 1;\n            }\n        }\n\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isSorted(List<Integer> lst) {\n        if (lst == null || lst.size() <= 1) {\n            return true;\n        }\n\n        int prev = lst.get(0);\n        int runCount = 1;\n\n        for (int i = 1; i < lst.size(); i++) {\n            int curr = lst.get(i);\n\n            if (curr < prev || (curr == prev && ++runCount > 2)) {\n                return false;\n            }\n\n            if (curr > prev) {\n                prev = curr;\n                runCount = 1;\n            }\n        }\n\n        return true;\n    }\n}","nanoTime":"2154792200"}
{"taskId":"Java/127","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5)), \"YES\" ),\n                Objects.equals(s.intersection(Arrays.asList(-2, 2), Arrays.asList(-4, 0)), \"YES\" ),\n                Objects.equals(s.intersection(Arrays.asList(-11, 2), Arrays.asList(-1, -1)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(3, 5)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(1, 2)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-2, -2), Arrays.asList(-3, -2)), \"NO\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two\n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        // Let's think step by step\n        // Input: interval1 = [s1, e1], interval2 = [s2, e2]\n        // Output: \"YES\" if the length of their intersection is a prime number, else \"NO\"\n        // Sequential structure:\n        // 1. Extract s1, e1, s2, e2.\n        // 2. Compute interStart = max(s1, s2) and interEnd = min(e1, e2).\n        // Branch structure:\n        // 3. If interStart > interEnd, there is no intersection -> return \"NO\".\n        // 4. Else, compute length = interEnd - interStart.\n        // 5. If length is prime -> return \"YES\", else -> \"NO\".\n        // Loop structure:\n        // - In primality test, loop through possible divisors up to sqrt(length).\n\n        int s1 = interval1.get(0);\n        int e1 = interval1.get(1);\n        int s2 = interval2.get(0);\n        int e2 = interval2.get(1);\n\n        int interStart = Math.max(s1, s2);\n        int interEnd = Math.min(e1, e2);\n\n        if (interStart > interEnd) {\n            return \"NO\";\n        }\n\n        int length = interEnd - interStart;\n\n        return isPrime(length) ? \"YES\" : \"NO\";\n    }\n\n    private boolean isPrime(int n) {\n        // Sequential checks\n        if (n <= 1) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n\n        // Loop through odd divisors up to sqrt(n)\n        for (int i = 3; (long) i * i <= n; i += 2) {\n            if (n % i == 0) return false; // Branch: found a divisor\n        }\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        int intersectionStart = Math.max(start1, start2);\n        int intersectionEnd = Math.min(end1, end2);\n\n        if (intersectionStart > intersectionEnd) {\n            return \"NO\";\n        }\n\n        int length = intersectionEnd - intersectionStart;\n        return isPrime(length) ? \"YES\" : \"NO\";\n    }\n\n    private boolean isPrime(int number) {\n        if (number <= 1) return false;\n        if (number == 2) return true;\n        if (number % 2 == 0) return false;\n\n        for (int i = 3; i * i <= number; i += 2) {\n            if (number % i == 0) return false;\n        }\n        return true;\n    }\n}","nanoTime":"2984786300"}
{"taskId":"Java/128","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.prodSigns(Arrays.asList(1, 2, 2, -4)).get() == -9,\n                s.prodSigns(Arrays.asList(0, 1)).get() == 0,\n                s.prodSigns(Arrays.asList(1, 1, 1, 2, 3, -1, 1)).get() == -10,\n                s.prodSigns(List.of()).isEmpty(),\n                s.prodSigns(Arrays.asList(2, 4,1, 2, -1, -1, 9)).get() == 20,\n                s.prodSigns(Arrays.asList(-1, 1, -1, 1)).get() == 4,\n                s.prodSigns(Arrays.asList(-1, 1, 1, 1)).get() == -4,\n                s.prodSigns(Arrays.asList(-1, 1, 1, 0)).get() == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prodSigns(Arrays.asList(1, 2, 2, -4)) == -9\n    >>> prodSigns(Arrays.asList(0, 1)) == 0\n    >>> prodSigns(Arrays.asList()) == None\n     */\n    public Optional<Integer> prodSigns(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of integers\n        // Output: Optional<Integer> result\n        // Sequential:\n        // 1. Initialize sumAbs = 0 and signProd = 1.\n        // Branch:\n        // 2. If arr is null or empty, return Optional.empty().\n        // Loop:\n        // 3. For each number x in arr:\n        //    a. Add absolute value of x to sumAbs.\n        //    b. Update signProd by multiplying with sign of x:\n        //       - if x == 0 => sign is 0\n        //       - else if x < 0 => sign is -1\n        //       - else => sign is 1\n        // Sequential:\n        // 4. Compute result = sumAbs * signProd.\n        // 5. Return Optional.of(result).\n\n        if (arr == null || arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumAbs = 0;\n        int signProd = 1;\n\n        for (Integer x : arr) {\n            // Assuming non-null elements as per typical constraints\n            sumAbs += Math.abs(x);\n            if (x == 0) {\n                signProd = 0;\n            } else if (x < 0) {\n                signProd *= -1;\n            } else {\n                // x > 0 => multiply by 1 (no change)\n            }\n        }\n\n        int result = sumAbs * signProd;\n        return Optional.of(result);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public Optional<Integer> prodSigns(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) {\n            return Optional.empty();\n        }\n\n        int sumAbs = 0;\n        int signProd = 1;\n\n        for (int x : arr) {\n            sumAbs += Math.abs(x);\n            if (x == 0) {\n                return Optional.of(0);\n            }\n            signProd *= (x < 0) ? -1 : 1;\n        }\n\n        return Optional.of(sumAbs * signProd);\n    }\n}","nanoTime":"3180992900"}
{"taskId":"Java/129","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.minPath(Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6), Arrays.asList(7, 8, 9)), 3).equals(Arrays.asList(1, 2, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(5, 9, 3), Arrays.asList(4, 1, 6), Arrays.asList(7, 8, 2)), 1).equals(List.of(1)),\n                s.minPath(Arrays.asList(Arrays.asList(1, 2, 3, 4), Arrays.asList(5, 6, 7, 8), Arrays.asList(9, 10, 11, 12), Arrays.asList(13, 14, 15, 16)), 4).equals(Arrays.asList(1, 2, 1, 2)),\n                s.minPath(Arrays.asList(Arrays.asList(6, 4, 13, 10), Arrays.asList(5, 7, 12, 1), Arrays.asList(3, 16, 11, 15), Arrays.asList(8, 14, 9, 2)), 7).equals(Arrays.asList(1, 10, 1, 10, 1, 10, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(8, 14, 9, 2), Arrays.asList(6, 4, 13, 15), Arrays.asList(5, 7, 1, 12), Arrays.asList(3, 10, 11, 16)), 5).equals(Arrays.asList(1, 7, 1, 7, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(11, 8, 7, 2), Arrays.asList(5, 16, 14, 4), Arrays.asList(9, 3, 15, 6), Arrays.asList(12, 13, 10, 1)), 9).equals(Arrays.asList(1, 6, 1, 6, 1, 6, 1, 6, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(12, 13, 10, 1), Arrays.asList(9, 3, 15, 6), Arrays.asList(5, 16, 14, 4), Arrays.asList(11, 8, 7, 2)), 12).equals(Arrays.asList(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6)),\n                s.minPath(Arrays.asList(Arrays.asList(2, 7, 4), Arrays.asList(3, 1, 5), Arrays.asList(6, 8, 9)), 8).equals(Arrays.asList(1, 3, 1, 3, 1, 3, 1, 3)),\n                s.minPath(Arrays.asList(Arrays.asList(6, 1, 5), Arrays.asList(3, 8, 9), Arrays.asList(2, 7, 4)), 8).equals(Arrays.asList(1, 5, 1, 5, 1, 5, 1, 5)),\n                s.minPath(Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4)), 10).equals(Arrays.asList(1, 2, 1, 2, 1, 2, 1, 2, 1, 2)),\n                s.minPath(Arrays.asList(Arrays.asList(1, 3), Arrays.asList(3, 2)), 10).equals(Arrays.asList(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n     */\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        // Let's think step by step\n        // Input: grid (N x N), k\n        // Output: List<Integer> of length k, the lexicographically smallest path values.\n        // Problem-solving process using three programming structures:\n        // Sequential structure:\n        // 1) Scan the entire grid to find the cell with the minimum value; this is the optimal starting cell.\n        // 2) Initialize the answer list and set the current position to that cell.\n        // Loop structure:\n        // 3) Repeat for each step from 1 to k:\n        //    - Add the current cell's value to the answer list.\n        //    - If we've added k values, stop.\n        //    - Otherwise, among all valid neighbors (up, down, left, right), choose the neighbor with the smallest value and move there.\n        // Branch structure:\n        // - While scanning neighbors, check bounds (if statements) and update the best neighbor when a smaller value is found.\n        // - The loop naturally handles k == 1 by not moving after the first addition.\n\n        int n = grid.size();\n\n        // 1) Find the position of the global minimum value in the grid.\n        int minVal = Integer.MAX_VALUE;\n        int startR = 0, startC = 0;\n        for (int r = 0; r < n; r++) {\n            List<Integer> row = grid.get(r);\n            for (int c = 0; c < n; c++) {\n                int v = row.get(c);\n                if (v < minVal) {\n                    minVal = v;\n                    startR = r;\n                    startC = c;\n                }\n            }\n        }\n\n        // 2) Initialize answer list and current position.\n        List<Integer> ans = new ArrayList<>(k);\n        int r = startR, c = startC;\n\n        // Neighbor direction vectors: up, down, left, right\n        int[] dr = {-1, 1, 0, 0};\n        int[] dc = {0, 0, -1, 1};\n\n        // 3) Build the path greedily.\n        for (int step = 0; step < k; step++) {\n            ans.add(grid.get(r).get(c));\n            if (step == k - 1) break;\n\n            // Find the neighbor with the smallest value.\n            int bestR = r, bestC = c;\n            int bestVal = Integer.MAX_VALUE;\n            for (int d = 0; d < 4; d++) {\n                int nr = r + dr[d];\n                int nc = c + dc[d];\n                // Branch: check bounds\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                    int nv = grid.get(nr).get(nc);\n                    if (nv < bestVal) {\n                        bestVal = nv;\n                        bestR = nr;\n                        bestC = nc;\n                    }\n                }\n            }\n            // Move to the best neighbor.\n            r = bestR;\n            c = bestC;\n        }\n\n        return ans;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int[] start = findMinPosition(grid, n);\n        List<Integer> ans = new ArrayList<>(k);\n        int r = start[0], c = start[1];\n\n        for (int step = 0; step < k; step++) {\n            ans.add(grid.get(r).get(c));\n            if (step < k - 1) {\n                int[] bestNeighbor = findBestNeighbor(grid, r, c, n);\n                r = bestNeighbor[0];\n                c = bestNeighbor[1];\n            }\n        }\n\n        return ans;\n    }\n\n    private int[] findMinPosition(List<List<Integer>> grid, int n) {\n        int minVal = Integer.MAX_VALUE;\n        int[] position = new int[2];\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                int v = grid.get(r).get(c);\n                if (v < minVal) {\n                    minVal = v;\n                    position[0] = r;\n                    position[1] = c;\n                }\n            }\n        }\n        return position;\n    }\n\n    private int[] findBestNeighbor(List<List<Integer>> grid, int r, int c, int n) {\n        int[] bestNeighbor = {r, c};\n        int bestVal = Integer.MAX_VALUE;\n        int[] dr = {-1, 1, 0, 0};\n        int[] dc = {0, 0, -1, 1};\n\n        for (int d = 0; d < 4; d++) {\n            int nr = r + dr[d];\n            int nc = c + dc[d];\n            if (isInBounds(nr, nc, n)) {\n                int nv = grid.get(nr).get(nc);\n                if (nv < bestVal) {\n                    bestVal = nv;\n                    bestNeighbor[0] = nr;\n                    bestNeighbor[1] = nc;\n                }\n            }\n        }\n        return bestNeighbor;\n    }\n\n    private boolean isInBounds(int r, int c, int n) {\n        return r >= 0 && r < n && c >= 0 && c < n;\n    }\n}","nanoTime":"5937019100"}
{"taskId":"Java/130","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.tri(3).equals(Arrays.asList(1, 3, 2, 8)),\n                s.tri(4).equals(Arrays.asList(1, 3, 2, 8, 3)),\n                s.tri(5).equals(Arrays.asList(1, 3, 2, 8, 3, 15)),\n                s.tri(6).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4)),\n                s.tri(7).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24)),\n                s.tri(8).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24, 5)),\n                s.tri(9).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24, 5, 35)),\n                s.tri(20).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11)),\n                s.tri(0).equals(List.of(1)),\n                s.tri(1).equals(Arrays.asList(1, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8\n    You are given a non-negative integer number n, you have to a return a list of the\n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n     */\n    public List<Integer> tri(int n) {\n        // Let's think step by step\n        // Input: n (non-negative integer)\n        // Output: List<Integer> containing first n + 1 Tribonacci numbers.\n        //\n        // Sequential structure:\n        // 1) Initialize an ArrayList 'res' to store results.\n        //\n        // Loop structure:\n        // 2) For i from 0 to n (inclusive):\n        //\n        // Branch structure:\n        //    - If i is even: tri(i) = 1 + i / 2\n        //    - Else if i == 1: tri(1) = 3 (base case)\n        //    - Else (i is odd and i >= 3):\n        //         tri(i) = tri(i - 1) + tri(i - 2) + tri(i + 1)\n        //         Note: tri(i + 1) is even, so tri(i + 1) = 1 + (i + 1) / 2\n        //\n        // 3) Append each computed tri(i) to 'res'.\n        // 4) Return 'res'.\n\n        List<Integer> res = new ArrayList<>(n + 1);\n\n        for (int i = 0; i <= n; i++) {\n            int val;\n            if (i % 2 == 0) {\n                // Even index: direct formula\n                val = 1 + (i / 2);\n            } else if (i == 1) {\n                // Base case for odd index 1\n                val = 3;\n            } else {\n                // Odd i >= 3: use recurrence with tri(i+1) computed via even formula\n                int prev1 = res.get(i - 1);\n                int prev2 = res.get(i - 2);\n                int nextEven = 1 + ((i + 1) / 2); // tri(i + 1), since i + 1 is even\n                val = prev1 + prev2 + nextEven;\n            }\n            res.add(val);\n        }\n\n        return res;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        List<Integer> res = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            res.add(calculateTribonacci(i));\n        }\n        return res;\n    }\n\n    private int calculateTribonacci(int i) {\n        if (i % 2 == 0) {\n            return 1 + (i / 2);\n        } else if (i == 1) {\n            return 3;\n        } else {\n            int prev1 = calculateTribonacci(i - 1);\n            int prev2 = calculateTribonacci(i - 2);\n            int nextEven = 1 + ((i + 1) / 2);\n            return prev1 + prev2 + nextEven;\n        }\n    }\n}","nanoTime":"2610407100"}
{"taskId":"Java/131","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.digits(5) == 5,\n                s.digits(54) == 5,\n                s.digits(120) == 1,\n                s.digits(5014) == 5,\n                s.digits(98765) == 315,\n                s.digits(5576543) == 2625\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        // Let's think step by step\n        // Input: n, a positive integer\n        // Output: product of its odd digits; if no odd digits, return 0\n        // Sequential:\n        // 1. Initialize product = 1 and foundOdd = false.\n        // Loop:\n        // 2. While n > 0:\n        //    a. Extract last digit d = n % 10.\n        //    b. Branch: If d is odd, multiply product by d and mark foundOdd = true.\n        //    c. Remove last digit by n /= 10.\n        // Branch:\n        // 3. If foundOdd is false, return 0; otherwise, return product.\n        // Write your code here\n        int product = 1;\n        boolean foundOdd = false;\n        while (n > 0) {\n            int d = n % 10;\n            if ((d & 1) == 1) {\n                product *= d;\n                foundOdd = true;\n            }\n            n /= 10;\n        }\n        if (!foundOdd) {\n            return 0;\n        }\n        return product;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n     */\n    public int digits(int n) {\n        int product = 1;\n        boolean hasOddDigit = false;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (isOdd(digit)) {\n                product *= digit;\n                hasOddDigit = true;\n            }\n            n /= 10;\n        }\n        \n        return hasOddDigit ? product : 0;\n    }\n\n    private boolean isOdd(int digit) {\n        return (digit & 1) == 1;\n    }\n}","nanoTime":"4394694400"}
{"taskId":"Java/132","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isNested(\"[[]]\" ),\n                !s.isNested(\"[]]]]]]][[[[[]\" ),\n                !s.isNested(\"[][]\" ),\n                !s.isNested(\"[]\" ),\n                s.isNested(\"[[[[]]]]\" ),\n                !s.isNested(\"[]]]]]]]]]]\" ),\n                s.isNested(\"[][][[]]\" ),\n                !s.isNested(\"[[]\" ),\n                !s.isNested(\"[]]\" ),\n                s.isNested(\"[[]][[\" ),\n                s.isNested(\"[[][]]\" ),\n                !s.isNested(\"\" ),\n                !s.isNested(\"[[[[[[[[\" ),\n                !s.isNested(\"]]]]]]]]\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets\n    where at least one bracket in the subsequence is nested.\n\n    isNested(\"[[]]\") -> true\n    isNested(\"[]]]]]]][[[[[]\") -> false\n    isNested(\"[][]\") -> false\n    isNested(\"[]\") -> false\n    isNested(\"[[][]]\") -> true\n    isNested(\"[[]][[\") -> true\n     */\n    public boolean isNested(String string) {\n        // Let's think step by step\n        // Input: string consisting only of '[' and ']'\n        // Output: boolean indicating whether there exists a valid nested subsequence\n        //\n        // Sequential structure:\n        // 1) If the string is null or length < 4, return false (need at least \"[[]]\").\n        // 2) Build a suffix count array where suffixClose[i] is the number of ']' from i to end.\n        //\n        // Loop structure:\n        // 3) Traverse the string from left to right, counting how many '[' we've seen (openSeen).\n        //\n        // Branch structure:\n        // 4) At each index i, if openSeen >= 2 and there are at least 2 ']' strictly after i\n        //    (i.e., suffixClose[i + 1] >= 2), then we can pick a subsequence \"[[...]]\" => return true.\n        // 5) If no such position is found, return false.\n\n        if (string == null || string.length() < 4) {\n            return false;\n        }\n\n        char[] s = string.toCharArray();\n        int n = s.length;\n\n        // Build suffix counts of ']' characters\n        int[] suffixClose = new int[n + 1];\n        for (int i = n - 1; i >= 0; i--) {\n            suffixClose[i] = suffixClose[i + 1] + (s[i] == ']' ? 1 : 0);\n        }\n\n        int openSeen = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '[') {\n                openSeen++;\n            }\n            // Check if we already have two '[' and at least two ']' remain after this position\n            if (openSeen >= 2 && suffixClose[i + 1] >= 2) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isNested(String string) {\n        if (string == null || string.length() < 4) {\n            return false;\n        }\n\n        int openCount = 0;\n        int closeCount = 0;\n\n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                openCount++;\n            } else if (ch == ']') {\n                closeCount++;\n            }\n            if (openCount >= 2 && closeCount >= 2) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","nanoTime":"3217189800"}
{"taskId":"Java/133","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumSquares(Arrays.asList(1., 2., 3.)) == 14,\n                s.sumSquares(Arrays.asList(1.0, 2., 3.)) == 14,\n                s.sumSquares(Arrays.asList(1., 3., 5., 7.)) == 84,\n                s.sumSquares(Arrays.asList(1.4, 4.2, 0.)) == 29,\n                s.sumSquares(Arrays.asList(-2.4, 1., 1.)) == 6,\n                s.sumSquares(Arrays.asList(100., 1., 15., 2.)) == 10230,\n                s.sumSquares(Arrays.asList(10000., 10000.)) == 200000000,\n                s.sumSquares(Arrays.asList(-1.4, 4.6, 6.3)) == 75,\n                s.sumSquares(Arrays.asList(-1.4, 17.9, 18.9, 19.9)) == 1086,\n                s.sumSquares(List.of(0.)) == 0,\n                s.sumSquares(List.of(-1.)) == 1,\n                s.sumSquares(Arrays.asList(-1., 1., 0.)) == 2\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n     */\n    public int sumSquares(List<Double> lst) {\n        // Let's think step by step\n        // Input: lst, a list of Double numbers\n        // Output: sum, an integer representing the sum of squares of ceiled elements\n        // Sequential structure:\n        // 1. Initialize an accumulator variable \"sum\" to 0.\n        // Branch structure:\n        // 2. If the input list is null or empty, return 0.\n        // Loop structure:\n        // 3. For each number x in the list:\n        //    3.1 Compute its ceiling value c = Math.ceil(x).\n        //    3.2 Convert c to int.\n        //    3.3 Square it and add to \"sum\".\n        // 4. Return \"sum\".\n        int sum = 0;\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n        for (Double x : lst) {\n            if (x == null) {\n                continue;\n            }\n            int c = (int) Math.ceil(x.doubleValue());\n            sum += c * c;\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumSquares(List<Double> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n        \n        return lst.stream()\n                  .filter(Objects::nonNull)\n                  .mapToInt(x -> (int) Math.ceil(x))\n                  .map(x -> x * x)\n                  .sum();\n    }\n}","nanoTime":"2028831400"}
{"taskId":"Java/134","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.checkIfLastCharIsALetter(\"apple\" ) == false,\n                s.checkIfLastCharIsALetter(\"apple pi e\" ) == true,\n                s.checkIfLastCharIsALetter(\"eeeee\" ) == false,\n                s.checkIfLastCharIsALetter(\"A\" ) == true,\n                s.checkIfLastCharIsALetter(\"Pumpkin pie \" ) == false,\n                s.checkIfLastCharIsALetter(\"Pumpkin pie 1\" ) == false,\n                s.checkIfLastCharIsALetter(\"\" ) == false,\n                s.checkIfLastCharIsALetter(\"eeeee e \" ) == false,\n                s.checkIfLastCharIsALetter(\"apple pie\" ) == false,\n                s.checkIfLastCharIsALetter(\"apple pi e \" ) == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns true if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and false otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    checkIfLastCharIsALetter(\"apple pie\") -> false\n    checkIfLastCharIsALetter(\"apple pi e\") -> true\n    checkIfLastCharIsALetter(\"apple pi e \") -> false\n    checkIfLastCharIsALetter(\"\") -> false\n     */\n    public boolean checkIfLastCharIsALetter(String txt) {\n        // Let's think step by step\n        // Input: txt, a string\n        // Output: boolean\n        // Sequential structure:\n        // 1) If txt is null or empty, return false.\n        // 2) Get the last character of txt.\n        // Branch structure:\n        // 3) If the last character is not a letter, return false.\n        // Loop structure:\n        // 4) Walk left from the character before the last, counting contiguous non-space characters.\n        // Branch structure:\n        // 5) If there are zero contiguous non-space characters before the last letter,\n        //    it is not part of a word -> return true; otherwise return false.\n\n        if (txt == null || txt.length() == 0) {\n            return false;\n        }\n\n        int n = txt.length();\n        char last = txt.charAt(n - 1);\n\n        if (!Character.isLetter(last)) {\n            return false;\n        }\n\n        int i = n - 2;\n        int countNonSpaceBefore = 0;\n        while (i >= 0 && txt.charAt(i) != ' ') {\n            countNonSpaceBefore++;\n            i--;\n        }\n\n        return countNonSpaceBefore == 0;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean checkIfLastCharIsALetter(String txt) {\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n\n        char last = txt.charAt(txt.length() - 1);\n        if (!Character.isLetter(last)) {\n            return false;\n        }\n\n        int lastIndex = txt.length() - 2;\n        while (lastIndex >= 0 && txt.charAt(lastIndex) == ' ') {\n            lastIndex--;\n        }\n\n        return lastIndex < 0 || txt.charAt(lastIndex) == ' ';\n    }\n}","nanoTime":"2490449500"}
{"taskId":"Java/135","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.canArrange(Arrays.asList(1, 2, 4, 3, 5)) == 3,\n                s.canArrange(Arrays.asList(1, 2, 4, 5)) == -1,\n                s.canArrange(Arrays.asList(1, 4, 2, 5, 6, 7, 8, 9, 10)) == 2,\n                s.canArrange(Arrays.asList(4, 8, 5, 7, 3)) == 4,\n                s.canArrange(List.of()) == -1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    canArrange(Arrays.asList(1,2,4,3,5)) = 3\n    canArrange(Arrays.asList(1,2,3)) = -1\n     */\n    public int canArrange(List<Integer> arr) {\n        // Let's think step by step\n        // Input: arr, a list of distinct integers\n        // Output: an integer index (0-based) or -1\n        // Sequential:\n        // 1. Let n be the size of arr.\n        // 2. If n < 2, return -1 since no preceding element exists.\n        // Loop:\n        // 3. Iterate i from n - 1 down to 1.\n        // Branch:\n        // 4. If arr[i] < arr[i - 1], return i (largest such index due to reverse scan).\n        // 5. If no such i is found after the loop, return -1.\n\n        int n = arr.size();\n        if (n < 2) return -1;\n\n        for (int i = n - 1; i >= 1; i--) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int canArrange(List<Integer> arr) {\n        int n = arr.size();\n        if (n < 2) return -1;\n\n        for (int i = n - 1; i > 0; i--) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}","nanoTime":"2073196800"}
{"taskId":"Java/136","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.largestSmallestIntegers(Arrays.asList(2, 4, 1, 3, 5, 7)).equals(Arrays.asList(Optional.empty(), Optional.of(1))),\n                s.largestSmallestIntegers(Arrays.asList(2, 4, 1, 3, 5, 7, 0)).equals(Arrays.asList(Optional.empty(), Optional.of(1))),\n                s.largestSmallestIntegers(Arrays.asList(1, 3, 2, 4, 5, 6, -2)).equals(Arrays.asList(Optional.of(-2), Optional.of(1))),\n                s.largestSmallestIntegers(Arrays.asList(4, 5, 3, 6, 2, 7, -7)).equals(Arrays.asList(Optional.of(-7), Optional.of(2))),\n                s.largestSmallestIntegers(Arrays.asList(7, 3, 8, 4, 9, 2, 5, -9)).equals(Arrays.asList(Optional.of(-9), Optional.of(2))),\n                s.largestSmallestIntegers(List.of()).equals(Arrays.asList(Optional.empty(), Optional.empty())),\n                s.largestSmallestIntegers(List.of(0)).equals(Arrays.asList(Optional.empty(), Optional.empty())),\n                s.largestSmallestIntegers(Arrays.asList(-1, -3, -5, -6)).equals(Arrays.asList(Optional.of(-1), Optional.empty())),\n                s.largestSmallestIntegers(Arrays.asList(-1, -3, -5, -6, 0)).equals(Arrays.asList(Optional.of(-1), Optional.empty())),\n                s.largestSmallestIntegers(Arrays.asList(-6, -4, -4, -3, 1)).equals(Arrays.asList(Optional.of(-3), Optional.of(1))),\n                s.largestSmallestIntegers(Arrays.asList(-6, -4, -4, -3, -100, 1)).equals(Arrays.asList(Optional.of(-3), Optional.of(1)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largestSmallestIntegers(Arrays.asList(2, 4, 1, 3, 5, 7)) == (Optional.empty(), Optional.of(1))\n    largestSmallestIntegers(Arrays.asList()) == (Optional.empty(), Optional.empty())\n    largestSmallestIntegers(Arrays.asList(0)) == (Optional.empty(), Optional.empty())\n     */\n    public List<Optional<Integer>> largestSmallestIntegers(List<Integer> lst){\n        // Let's think step by step\n        // Input: lst, a list of integers\n        // Output: a List of two Optionals: [largestNegative, smallestPositive]\n        // Sequential structure:\n        // 1) Initialize placeholders for the largest negative and smallest positive numbers.\n        // Loop structure:\n        // 2) Iterate over each number in the list.\n        // Branch structure inside loop:\n        //    - If the number is negative, update the largest negative if it's larger.\n        //    - Else if the number is positive, update the smallest positive if it's smaller.\n        //    - Else (number is zero), do nothing.\n        // Sequential structure:\n        // 3) Wrap the final values into Optional.\n        // 4) Return them as a list [largestNegative, smallestPositive].\n        \n        if (lst == null || lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Integer maxNeg = null; // largest negative\n        Integer minPos = null; // smallest positive\n\n        for (Integer x : lst) {\n            if (x == null) continue; // ignore nulls if present\n            if (x < 0) {\n                if (maxNeg == null || x > maxNeg) {\n                    maxNeg = x;\n                }\n            } else if (x > 0) {\n                if (minPos == null || x < minPos) {\n                    minPos = x;\n                }\n            } // x == 0 -> ignore\n        }\n\n        Optional<Integer> a = (maxNeg == null) ? Optional.empty() : Optional.of(maxNeg);\n        Optional<Integer> b = (minPos == null) ? Optional.empty() : Optional.of(minPos);\n\n        return Arrays.asList(a, b);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Optional<Integer>> largestSmallestIntegers(List<Integer> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return Arrays.asList(Optional.empty(), Optional.empty());\n        }\n\n        Integer maxNeg = null;\n        Integer minPos = null;\n\n        for (Integer x : lst) {\n            if (x == null) continue;\n            if (x < 0) {\n                maxNeg = (maxNeg == null) ? x : Math.max(maxNeg, x);\n            } else if (x > 0) {\n                minPos = (minPos == null) ? x : Math.min(minPos, x);\n            }\n        }\n\n        return Arrays.asList(Optional.ofNullable(maxNeg), Optional.ofNullable(minPos));\n    }\n}","nanoTime":"2329033000"}
{"taskId":"Java/137","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                (int) s.compareOne(1, 2).get() == 2,\n                (double) s.compareOne(1, 2.5).get() == 2.5,\n                (int) s.compareOne(2, 3).get() == 3,\n                (int) s.compareOne(5, 6).get() == 6,\n                (String) s.compareOne(1, \"2,3\").get() == \"2,3\",\n                (String) s.compareOne(\"5,1\", \"6\").get() == \"6\",\n                (String) s.compareOne(\"1\", \"2\").get() == \"2\",\n                s.compareOne(\"1\", 1).isEmpty()\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\nclass Solution {\n    /**\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compareOne(1, 2.5) -> Optional.of(2.5)\n    compareOne(1, \"2,3\") -> Optional.of(\"2,3\")\n    compareOne(\"5,1\", \"6\") -> Optional.of(\"6\")\n    compareOne(\"1\", 1) -> Optional.empty()\n     */\n    public Optional<Object> compareOne(Object a, Object b) {\n        // Let's think step by step\n        // Input: a, b can be Integer, Float/Double, or String representing a real number (with '.' or ',')\n        // Output: Optional<Object> - the larger original variable (preserving its original type), or Optional.empty() if equal\n        //\n        // Problem-solving process:\n        // - Sequential structure:\n        //   1) Normalize and parse both inputs into numeric values usable for comparison.\n        //   2) Use BigDecimal for safe comparison of decimal values.\n        // - Branch structure:\n        //   3) If input is a Number -> parse via its string form; if it's a String -> normalize decimal separator and parse.\n        //   4) After comparison: if a > b return a; else if b > a return b; else return Optional.empty().\n        // - Loop structure:\n        //   5) While normalizing strings, iterate over characters to remove whitespace and, when needed, remove thousands separators (commas).\n        //\n        // Write your code here\n\n        // Handle nulls defensively\n        if (a == null || b == null) {\n            return Optional.empty();\n        }\n\n        BigDecimal va = toBigDecimal(a);\n        BigDecimal vb = toBigDecimal(b);\n\n        int cmp = va.compareTo(vb);\n        if (cmp > 0) {\n            return Optional.of(a);\n        } else if (cmp < 0) {\n            return Optional.of(b);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    private BigDecimal toBigDecimal(Object o) {\n        if (o instanceof Number) {\n            // Use the string representation to avoid binary rounding artifacts\n            return new BigDecimal(o.toString());\n        } else if (o instanceof String) {\n            String normalized = normalizeStringNumber((String) o);\n            return new BigDecimal(normalized);\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + o.getClass());\n        }\n    }\n\n    private String normalizeStringNumber(String s) {\n        if (s == null) throw new NumberFormatException(\"null\");\n\n        // Remove all whitespace via a loop\n        StringBuilder cleaned = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (!Character.isWhitespace(c)) {\n                cleaned.append(c);\n            }\n        }\n\n        String str = cleaned.toString();\n        boolean hasDot = str.indexOf('.') >= 0;\n        boolean hasComma = str.indexOf(',') >= 0;\n\n        if (hasComma && !hasDot) {\n            // Treat comma as decimal separator\n            str = str.replace(',', '.');\n        } else if (hasComma && hasDot) {\n            // Assume commas are thousand separators; remove them using a loop\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < str.length(); i++) {\n                char c = str.charAt(i);\n                if (c != ',') sb.append(c);\n            }\n            str = sb.toString();\n        }\n        return str;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\nclass Solution {\n    public Optional<Object> compareOne(Object a, Object b) {\n        if (a == null || b == null) {\n            return Optional.empty();\n        }\n\n        BigDecimal va = toBigDecimal(a);\n        BigDecimal vb = toBigDecimal(b);\n\n        return compareValues(a, b, va, vb);\n    }\n\n    private Optional<Object> compareValues(Object a, Object b, BigDecimal va, BigDecimal vb) {\n        int cmp = va.compareTo(vb);\n        if (cmp > 0) {\n            return Optional.of(a);\n        } else if (cmp < 0) {\n            return Optional.of(b);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    private BigDecimal toBigDecimal(Object o) {\n        if (o instanceof Number) {\n            return new BigDecimal(o.toString());\n        } else if (o instanceof String) {\n            return new BigDecimal(normalizeStringNumber((String) o));\n        } else {\n            throw new IllegalArgumentException(\"Unsupported type: \" + o.getClass());\n        }\n    }\n\n    private String normalizeStringNumber(String s) {\n        if (s == null) throw new NumberFormatException(\"null\");\n\n        String cleaned = s.replaceAll(\"\\\\s+\", \"\");\n        cleaned = cleaned.replace(',', '.');\n\n        return cleaned.replaceAll(\"(?<=\\\\d),(?=\\\\d{3})\", \"\");\n    }\n}","nanoTime":"4445214400"}
{"taskId":"Java/138","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isEqualToSumEven(4) == false,\n                s.isEqualToSumEven(6) == false,\n                s.isEqualToSumEven(8) == true,\n                s.isEqualToSumEven(10) == true,\n                s.isEqualToSumEven(11) == false,\n                s.isEqualToSumEven(12) == true,\n                s.isEqualToSumEven(13) == false,\n                s.isEqualToSumEven(16) == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    isEqualToSumEven(4) == false\n    isEqualToSumEven(6) == false\n    isEqualToSumEven(8) == true\n     */\n    public boolean isEqualToSumEven(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: boolean indicating if n can be expressed as the sum of exactly 4 positive even numbers\n        // 1) Sequential: Note the minimum possible sum is 2 + 2 + 2 + 2 = 8.\n        // 2) Branch: If n < 8, return false. If n is odd, return false (sum of evens is always even).\n        // 3) Loop: Construct a valid decomposition by setting the first three addends to 2 in a loop,\n        //          then compute the last addend as n - 6 and check if it is a positive even number.\n        // 4) Branch: Return true if the constructed decomposition is valid; otherwise, return false.\n\n        if (n < 8) {\n            return false;\n        }\n        if ((n & 1) == 1) { // n is odd\n            return false;\n        }\n\n        // Loop structure: build the first three positive even numbers (all 2)\n        int[] parts = new int[4];\n        for (int i = 0; i < 3; i++) {\n            parts[i] = 2;\n        }\n        parts[3] = n - 6; // Remaining part\n\n        // Branch: Validate the remaining part is a positive even number\n        if (parts[3] >= 2 && (parts[3] % 2 == 0)) {\n            return true;\n        }\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    isEqualToSumEven(4) == false\n    isEqualToSumEven(6) == false\n    isEqualToSumEven(8) == true\n     */\n    public boolean isEqualToSumEven(int n) {\n        if (n < 8 || (n & 1) == 1) {\n            return false;\n        }\n        return (n - 6) >= 2 && ((n - 6) % 2 == 0);\n    }\n}","nanoTime":"2172378800"}
{"taskId":"Java/139","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.specialFactorial(4) == 288,\n                s.specialFactorial(5) == 34560,\n                s.specialFactorial(7) == 125411328000L,\n                s.specialFactorial(1) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> specialFactorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n     */\n    public long specialFactorial(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: the product of factorials from 1! to n!\n        // Sequential structure:\n        // 1) Initialize variables to hold the running factorial and the final result.\n        // Branch structure:\n        // 2) If n <= 0, return 1 (by convention, empty product equals 1).\n        // Loop structure:\n        // 3) For k from 1 to n:\n        //    - Update running factorial: fact = fact * k\n        //    - Multiply into result: result = result * fact\n        // 4) Return result.\n\n        long result = 1L;      // Holds the final brazilian factorial\n        if (n <= 0) {          // Branch: handle non-positive input safely\n            return 1L;\n        }\n\n        long fact = 1L;        // Running factorial k!\n        for (int k = 1; k <= n; k++) {   // Loop: accumulate factorials and multiply into result\n            fact *= k;         // Compute k!\n            result *= fact;    // Multiply current factorial into the final product\n        }\n\n        return result;         // Sequential: return the accumulated result\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public BigInteger specialFactorial(int n) {\n        if (n <= 0) {\n            return BigInteger.ONE;\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger fact = BigInteger.ONE;\n\n        for (int k = 1; k <= n; k++) {\n            fact = fact.multiply(BigInteger.valueOf(k));\n            result = result.multiply(fact);\n        }\n\n        return result;\n    }\n}","nanoTime":"1389448400"}
{"taskId":"Java/140","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.fixSpaces(\"Example\" ), \"Example\" ),\n                Objects.equals(s.fixSpaces(\"Mudasir Hanif \" ), \"Mudasir_Hanif_\" ),\n                Objects.equals(s.fixSpaces(\"Yellow Yellow  Dirty  Fellow\" ), \"Yellow_Yellow__Dirty__Fellow\" ),\n                Objects.equals(s.fixSpaces(\"Exa   mple\" ), \"Exa-mple\" ),\n                Objects.equals(s.fixSpaces(\"   Exa 1 2 2 mple\" ), \"-Exa_1_2_2_mple\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string text, replace all spaces in it with underscores,\n    and if a string has more than 2 consecutive spaces,\n    then replace all consecutive spaces with -\n\n    fixSpaces(\"Example\") == \"Example\"\n    fixSpaces(\"Example 1\") == \"Example_1\"\n    fixSpaces(\" Example 2\") == \"_Example_2\"\n    fixSpaces(\" Example   3\") == \"_Example-3\"\n     */\n    public String fixSpaces(String text) {\n        // Let's think step by step\n        // Input: text, a string possibly containing spaces\n        // Output: a new string with replacements applied\n        // Sequential (initialization):\n        // 1. Create a StringBuilder to build the result.\n        // 2. Initialize a counter to track consecutive spaces.\n        // Loop:\n        // 3. Iterate through each character in the input string.\n        // Branch:\n        // 4. If the character is a space, increment the space counter.\n        // 5. If the character is not a space:\n        //    5.1. Flush any pending spaces:\n        //         - If count == 1, append \"_\"\n        //         - If count == 2, append \"__\"\n        //         - If count > 2, append \"-\"\n        //    5.2. Append the current non-space character.\n        // 6. After the loop, flush any trailing spaces using the same rules.\n        // 7. Return the built string.\n\n        StringBuilder sb = new StringBuilder();\n        int spaceCount = 0;\n\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 0) {\n                    if (spaceCount == 1) {\n                        sb.append('_');\n                    } else if (spaceCount == 2) {\n                        sb.append(\"__\");\n                    } else {\n                        sb.append('-');\n                    }\n                    spaceCount = 0;\n                }\n                sb.append(c);\n            }\n        }\n\n        if (spaceCount > 0) {\n            if (spaceCount == 1) {\n                sb.append('_');\n            } else if (spaceCount == 2) {\n                sb.append(\"__\");\n            } else {\n                sb.append('-');\n            }\n        }\n\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fixSpaces(String text) {\n        StringBuilder sb = new StringBuilder();\n        int spaceCount = 0;\n\n        for (char c : text.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                appendSpaces(sb, spaceCount);\n                sb.append(c);\n                spaceCount = 0;\n            }\n        }\n        appendSpaces(sb, spaceCount);\n        return sb.toString();\n    }\n\n    private void appendSpaces(StringBuilder sb, int spaceCount) {\n        if (spaceCount > 0) {\n            if (spaceCount == 1) {\n                sb.append('_');\n            } else if (spaceCount == 2) {\n                sb.append(\"__\");\n            } else {\n                sb.append('-');\n            }\n        }\n    }\n}","nanoTime":"2354254500"}
{"taskId":"Java/141","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.filenameCheck(\"example.txt\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"1example.dll\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"s1sdf3.asd\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"K.dll\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"MY16FILE3.exe\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"His12FILE94.exe\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"_Y.txt\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"?aREYA.exe\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"/this_is_valid.dll\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"this_is_valid.wow\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"this_is_valid.txt\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"this_is_valid.txtexe\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"#this2_i4s_5valid.ten\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"@this1_is6_valid.exe\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"this_is_12valid.6exe4.txt\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"all.exe.txt\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"I563_No.exe\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"Is3youfault.txt\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"no_one#knows.dll\" ), \"Yes\" ),\n                Objects.equals(s.filenameCheck(\"1I563_Yes3.exe\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"I563_Yes3.txtt\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"final..txt\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"final132\" ), \"No\" ),\n                Objects.equals(s.filenameCheck(\"_f4indsartal132.\" ), \"No\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function which takes a string representing a file's name, and returns\n    \"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\n    A file's name is considered to be valid if and only if all the following conditions\n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from\n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: [\"txt\", \"exe\", \"dll\"]\n    Examples:\n    file_name_check(\"example.txt\") # => \"Yes\"\n    file_name_check(\"1example.dll\") # => \"No\" (the name should start with a latin alphapet letter)\n     */\n    public String filenameCheck(String file_name) {\n        // Let's think step by step\n        // Input: file_name, a string\n        // Output: \"Yes\" if valid, otherwise \"No\"\n        // Sequential structure:\n        // 1) Validate basic presence of the input string.\n        // 2) Initialize counters for dots and digits.\n        // Loop structure:\n        // 3) Iterate over each character in file_name:\n        //    - If it's a dot '.', increase dot counter.\n        //    - If it's a digit '0'..'9', increase digit counter.\n        // Branch structure:\n        // 4) If there is not exactly one dot or there are more than three digits, return \"No\".\n        // 5) Locate the dot and split into name and extension parts.\n        // 6) If the name part is empty or its first character is not a latin letter [A-Za-z], return \"No\".\n        // 7) If the extension is not one of {\"txt\", \"exe\", \"dll\"}, return \"No\".\n        // 8) Otherwise, return \"Yes\".\n        // Write your code here\n        if (file_name == null || file_name.isEmpty()) {\n            return \"No\";\n        }\n        int dotCount = 0;\n        int digitCount = 0;\n        for (int i = 0; i < file_name.length(); i++) {\n            char ch = file_name.charAt(i);\n            if (ch == '.') {\n                dotCount++;\n            } else if (ch >= '0' && ch <= '9') {\n                digitCount++;\n            }\n        }\n        if (dotCount != 1 || digitCount > 3) {\n            return \"No\";\n        }\n        int dotIndex = file_name.indexOf('.');\n        String name = file_name.substring(0, dotIndex);\n        String ext = file_name.substring(dotIndex + 1);\n        if (name.isEmpty()) {\n            return \"No\";\n        }\n        char first = name.charAt(0);\n        boolean isLatinLetter = (first >= 'a' && first <= 'z') || (first >= 'A' && first <= 'Z');\n        if (!isLatinLetter) {\n            return \"No\";\n        }\n        if (!(ext.equals(\"txt\") || ext.equals(\"exe\") || ext.equals(\"dll\"))) {\n            return \"No\";\n        }\n        return \"Yes\";\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    private static final Set<String> VALID_EXTENSIONS = Set.of(\"txt\", \"exe\", \"dll\");\n\n    public String filenameCheck(String fileName) {\n        if (fileName == null || fileName.isEmpty()) {\n            return \"No\";\n        }\n\n        int dotIndex = fileName.indexOf('.');\n        if (dotIndex <= 0 || dotIndex != fileName.lastIndexOf('.')) {\n            return \"No\";\n        }\n\n        String name = fileName.substring(0, dotIndex);\n        String extension = fileName.substring(dotIndex + 1);\n\n        if (!isValidName(name) || !VALID_EXTENSIONS.contains(extension)) {\n            return \"No\";\n        }\n\n        return \"Yes\";\n    }\n\n    private boolean isValidName(String name) {\n        if (name.isEmpty() || !Character.isLetter(name.charAt(0))) {\n            return false;\n        }\n\n        long digitCount = name.chars().filter(Character::isDigit).count();\n        return digitCount <= 3;\n    }\n}","nanoTime":"3781910200"}
{"taskId":"Java/142","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumSquares(Arrays.asList(1,2,3)) == 6,\n                s.sumSquares(Arrays.asList(1,4,9)) == 14,\n                s.sumSquares(List.of()) == 0,\n                s.sumSquares(Arrays.asList(1,1,1,1,1,1,1,1,1)) == 9,\n                s.sumSquares(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)) == -3,\n                s.sumSquares(List.of(0)) == 0,\n                s.sumSquares(Arrays.asList(-1,-5,2,-1,-5)) == -126,\n                s.sumSquares(Arrays.asList(-56,-99,1,0,-2)) == 3030,\n                s.sumSquares(Arrays.asList(-1,0,0,0,0,0,0,0,-1)) == 0,\n                s.sumSquares(Arrays.asList(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)) == -14196,\n                s.sumSquares(Arrays.asList(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)) == -1448\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sumSquares(List<Integer> lst) {\n        // Let's think step by step\n        // Input: lst, a List<Integer>\n        // Output: sum, an integer\n        // Problem-solving process using three programming structures:\n        // Sequential:\n        // 1. Initialize a variable \"sum\" to 0.\n        // Loop:\n        // 2. Iterate over the list indices i from 0 to lst.size() - 1.\n        // Branch:\n        // 3. For each index i:\n        //    - If i % 3 == 0, square the element at index i.\n        //    - Else if i % 4 == 0 (and not a multiple of 3), cube the element at index i.\n        //    - Else, keep the element unchanged.\n        // Sequential:\n        // 4. Add the (possibly transformed) value to \"sum\".\n        // 5. After the loop, return \"sum\".\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            int x = lst.get(i);\n            int transformed;\n            if (i % 3 == 0) {\n                transformed = x * x;\n            } else if (i % 4 == 0) {\n                transformed = x * x * x;\n            } else {\n                transformed = x;\n            }\n            sum += transformed;\n        }\n        return sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumSquares(List<Integer> lst) {\n        int sum = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            sum += transform(lst.get(i), i);\n        }\n        return sum;\n    }\n\n    private int transform(int value, int index) {\n        if (index % 3 == 0) {\n            return value * value;\n        } else if (index % 4 == 0) {\n            return value * value * value;\n        }\n        return value;\n    }\n}","nanoTime":"3601322400"}
{"taskId":"Java/143","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.wordsInSentence(\"This is a test\" ), \"is\" ),\n                Objects.equals(s.wordsInSentence(\"lets go for swimming\" ), \"go for\" ),\n                Objects.equals(s.wordsInSentence(\"there is no place available here\" ), \"there is no place\" ),\n                Objects.equals(s.wordsInSentence(\"Hi I am Hussein\" ), \"Hi am Hussein\" ),\n                Objects.equals(s.wordsInSentence(\"go for it\" ), \"go for it\" ),\n                Objects.equals(s.wordsInSentence(\"here\" ), \"\" ),\n                Objects.equals(s.wordsInSentence(\"here is\" ), \"is\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n     */\n    public String wordsInSentence(String sentence) {\n        // Let's think step by step\n        // Input: sentence, a string\n        // Output: result, a string with words whose lengths are prime\n        // 1. Split the sentence by spaces to get words. (sequential)\n        // 2. Initialize a StringBuilder to collect valid words. (sequential)\n        // 3. For each word in the list: (loop)\n        // 4.   Compute its length. (sequential)\n        // 5.   If the length is a prime number: (branch)\n        // 6.     Append the word to the result, managing spaces. (sequential)\n        // 7. Convert the StringBuilder to String and return it. (sequential)\n        // Write your code here\n        String[] words = sentence.split(\" \");\n        StringBuilder result = new StringBuilder();\n\n        for (String word : words) {\n            int len = word.length();\n            if (isPrime(len)) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n\n        return result.toString();\n    }\n\n    private boolean isPrime(int n) {\n        // Branch structure for quick eliminations\n        if (n < 2) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        // Loop to check divisibility up to sqrt(n)\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String wordsInSentence(String sentence) {\n        StringBuilder result = new StringBuilder();\n        for (String word : sentence.split(\" \")) {\n            if (isPrime(word.length())) {\n                if (result.length() > 0) {\n                    result.append(\" \");\n                }\n                result.append(word);\n            }\n        }\n        return result.toString();\n    }\n\n    private boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n == 2) return true;\n        if (n % 2 == 0) return false;\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n}","nanoTime":"3503226600"}
{"taskId":"Java/144","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.simplify(\"1/5\", \"5/1\") == true,\n                s.simplify(\"1/6\", \"2/1\") == false,\n                s.simplify(\"5/1\", \"3/1\") == true,\n                s.simplify(\"7/10\", \"10/2\") == false,\n                s.simplify(\"2/10\", \"50/10\") == true,\n                s.simplify(\"7/2\", \"4/2\") == true,\n                s.simplify(\"11/6\", \"6/1\") == true,\n                s.simplify(\"2/3\", \"5/2\") == false,\n                s.simplify(\"5/2\", \"3/5\") == false,\n                s.simplify(\"2/4\", \"8/4\") == true,\n                s.simplify(\"2/4\", \"4/2\") == true,\n                s.simplify(\"1/5\", \"5/1\") == true,\n                s.simplify(\"1/5\", \"1/5\") == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Your task is to implement a function that will simplify the expression\n    x * n. The function returns true if x * n evaluates to a whole number and false\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = true\n    simplify(\"1/6\", \"2/1\") = false\n    simplify(\"7/10\", \"10/2\") = false\n     */\n    public boolean simplify(String x, String n) {\n        // Let's think step by step\n        // Input: x and n as strings in the form \"numerator/denominator\"\n        // Output: boolean indicating whether (x * n) is a whole number\n        // Sequential structure:\n        // 1. Parse x and n into numerators and denominators: a/b and c/d.\n        // 2. Initialize working variables a1=a, b1=b, c1=c, d1=d as long.\n        // Loop structure:\n        // 3. Repeatedly cancel common factors between numerators and denominators using gcd:\n        //    - Cancel gcd(a1, b1), gcd(a1, d1), gcd(c1, b1), gcd(c1, d1) in a loop until no change.\n        // Branch structure:\n        // 4. After cancellation, if both denominators b1 and d1 are 1, return true; else return false.\n        String[] xs = x.split(\"/\");\n        String[] ns = n.split(\"/\");\n\n        long a = Long.parseLong(xs[0]);\n        long b = Long.parseLong(xs[1]);\n        long c = Long.parseLong(ns[0]);\n        long d = Long.parseLong(ns[1]);\n\n        long a1 = a, b1 = b, c1 = c, d1 = d;\n\n        // Loop to ensure all possible cancellations are performed\n        boolean changed;\n        do {\n            changed = false;\n\n            long g;\n\n            g = gcd(a1, b1);\n            if (g > 1) {\n                a1 /= g;\n                b1 /= g;\n                changed = true;\n            }\n\n            g = gcd(a1, d1);\n            if (g > 1) {\n                a1 /= g;\n                d1 /= g;\n                changed = true;\n            }\n\n            g = gcd(c1, b1);\n            if (g > 1) {\n                c1 /= g;\n                b1 /= g;\n                changed = true;\n            }\n\n            g = gcd(c1, d1);\n            if (g > 1) {\n                c1 /= g;\n                d1 /= g;\n                changed = true;\n            }\n        } while (changed);\n\n        // If both denominators reduce to 1, the product is an integer\n        return b1 == 1 && d1 == 1;\n    }\n\n    private long gcd(long a, long b) {\n        while (b != 0) {\n            long t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean simplify(String x, String n) {\n        long[] fractionX = parseFraction(x);\n        long[] fractionN = parseFraction(n);\n\n        long a1 = fractionX[0], b1 = fractionX[1];\n        long c1 = fractionN[0], d1 = fractionN[1];\n\n        cancelCommonFactors(a1, b1, c1, d1);\n\n        return b1 == 1 && d1 == 1;\n    }\n\n    private long[] parseFraction(String fraction) {\n        String[] parts = fraction.split(\"/\");\n        return new long[]{Long.parseLong(parts[0]), Long.parseLong(parts[1])};\n    }\n\n    private void cancelCommonFactors(long a1, long b1, long c1, long d1) {\n        boolean changed;\n        do {\n            changed = false;\n            changed |= cancel(a1, b1);\n            changed |= cancel(a1, d1);\n            changed |= cancel(c1, b1);\n            changed |= cancel(c1, d1);\n        } while (changed);\n    }\n\n    private boolean cancel(long numerator, long denominator) {\n        long g = gcd(numerator, denominator);\n        if (g > 1) {\n            numerator /= g;\n            denominator /= g;\n            return true;\n        }\n        return false;\n    }\n\n    private long gcd(long a, long b) {\n        while (b != 0) {\n            long t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n}","nanoTime":"4300115100"}
{"taskId":"Java/146","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.specialFilter(Arrays.asList(5, -2, 1, -5)) == 0,\n                s.specialFilter(Arrays.asList(15, -73, 14, -15)) == 1,\n                s.specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) == 2,\n                s.specialFilter(Arrays.asList(43, -12, 93, 125, 121, 109)) == 4,\n                s.specialFilter(Arrays.asList(71, -2, -33, 75, 21, 19)) == 3,\n                s.specialFilter(List.of(1)) == 0,\n                s.specialFilter(List.of()) == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes an array of numbers as input and returns\n    the number of elements in the array that are greater than 10 and both\n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter(Arrays.asList(15, -73, 14, -15)) => 1\n    specialFilter(Arrays.asList(33, -2, -3, 45, 21, 109)) => 2\n     */\n    public int specialFilter(List<Integer> nums) {\n        // Let's think step by step\n        // Input: nums, a list of integers\n        // Output: count, the number of elements satisfying the conditions\n        // Sequential: initialize count\n        int count = 0;\n        // Loop: iterate through each number\n        for (int n : nums) {\n            // Branch: only consider numbers greater than 10\n            if (n > 10) {\n                // Sequential: compute absolute value safely to handle Integer.MIN_VALUE\n                long val = Math.abs((long) n);\n                // Sequential: compute last digit\n                int lastDigit = (int) (val % 10);\n                // Loop: find first digit by dividing by 10 until one digit remains\n                while (val >= 10) {\n                    val /= 10;\n                }\n                int firstDigit = (int) val;\n                // Branch: check if both first and last digits are odd\n                if ((firstDigit % 2 != 0) && (lastDigit % 2 != 0)) {\n                    // Sequential: increment count\n                    count++;\n                }\n            }\n        }\n        // Sequential: return result\n        return count;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int specialFilter(List<Integer> nums) {\n        int count = 0;\n        for (int n : nums) {\n            if (isValid(n)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean isValid(int n) {\n        if (n <= 10) return false;\n        int firstDigit = getFirstDigit(n);\n        int lastDigit = getLastDigit(n);\n        return isOdd(firstDigit) && isOdd(lastDigit);\n    }\n\n    private int getFirstDigit(int n) {\n        while (n >= 10) {\n            n /= 10;\n        }\n        return n;\n    }\n\n    private int getLastDigit(int n) {\n        return Math.abs(n % 10);\n    }\n\n    private boolean isOdd(int digit) {\n        return digit % 2 != 0;\n    }\n}","nanoTime":"2649298900"}
{"taskId":"Java/147","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getMaxTriples(5) == 1,\n                s.getMaxTriples(6) == 4,\n                s.getMaxTriples(10) == 36,\n                s.getMaxTriples(100) == 53361\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation:\n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n     */\n    public int getMaxTriples(int n) {\n        // Let's think step by step\n        // Input: n, an integer\n        // Output: number of valid triples, an integer\n        //\n        // Problem-solving process using three programming structures:\n        // 1) Sequential structure:\n        //    - Note that a[i] = i^2 - i + 1 = i*(i-1) + 1.\n        //    - Evaluate modulo 3:\n        //        If i % 3 == 2, then a[i] % 3 == 0; otherwise, a[i] % 3 == 1.\n        //    - Let c0 be the count of indices with a[i] % 3 == 0, and c1 be the count with a[i] % 3 == 1.\n        //      We get c0 = floor((n + 1) / 3) and c1 = n - c0.\n        //    - A triple sums to a multiple of 3 iff the residues are (0,0,0) or (1,1,1).\n        //    - Therefore, answer = C(c0, 3) + C(c1, 3).\n        //\n        // 2) Branch structure:\n        //    - If n < 3, return 0 immediately since no triple exists.\n        //\n        // 3) Loop structure:\n        //    - Iterate across the residue classes to accumulate combinations C(c[r], 3).\n        //\n        // Implementation:\n        if (n < 3) return 0;\n\n        // Count of indices i in [1..n] with i % 3 == 2 -> a[i] % 3 == 0\n        long c0 = (n + 1L) / 3L;\n        long c1 = n - c0;\n\n        long[] cnt = new long[3];\n        cnt[0] = c0; // residue 0\n        cnt[1] = c1; // residue 1\n        cnt[2] = 0;  // residue 2 never occurs for a[i] % 3\n\n        long ans = 0L;\n        for (int r = 0; r < 3; r++) {\n            long m = cnt[r];\n            if (m >= 3) {\n                ans += m * (m - 1) * (m - 2) / 6;\n            }\n        }\n        return (int) ans;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int getMaxTriples(int n) {\n        if (n < 3) return 0;\n\n        long countDivisibleByThree = (n + 1L) / 3L;\n        long countRemainderOne = n - countDivisibleByThree;\n\n        long totalTriples = calculateCombinations(countDivisibleByThree) + calculateCombinations(countRemainderOne);\n        return (int) totalTriples;\n    }\n\n    private long calculateCombinations(long count) {\n        return count >= 3 ? count * (count - 1) * (count - 2) / 6 : 0;\n    }\n}","nanoTime":"2499637600"}
{"taskId":"Java/148","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.bf(\"Jupiter\", \"Neptune\").equals(Arrays.asList(\"Saturn\", \"Uranus\")),\n                s.bf(\"Earth\", \"Mercury\").equals(List.of(\"Venus\")),\n                s.bf(\"Mercury\", \"Uranus\").equals(Arrays.asList(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")),\n                s.bf(\"Neptune\", \"Venus\").equals(Arrays.asList(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")),\n                s.bf(\"Earth\", \"Earth\").equals(List.of()),\n                s.bf(\"Mars\", \"Earth\").equals(List.of()),\n                s.bf(\"Jupiter\", \"Makemake\").equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    There are eight planets in our solar system: the closerst to the Sun\n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2.\n    The function should return a tuple containing all planets whose orbits are\n    located between the orbit of planet1 and the orbit of planet2, sorted by\n    the proximity to the sun.\n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names.\n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> [\"Saturn\", \"Uranus\"]\n    bf(\"Earth\", \"Mercury\") ==> [\"Venus\"]\n    bf(\"Mercury\", \"Uranus\") ==> [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n     */\n    public List<String> bf(String planet1, String planet2) {\n        // Let's think step by step\n        // Input: planet1, planet2 (strings)\n        // Output: list of planet names strictly between their orbits, ordered by proximity to the Sun\n        // Sequential: define ordered planets list, build index map, compute bounds, collect results, return\n        // Branch: validate planet names; handle cases where indices are equal or adjacent\n        // Loop: build the map and collect planets between indices\n        // 1. Create an ordered list of planets from closest to farthest from the Sun.\n        // 2. Build a map from planet name to its index in the ordered list.\n        // 3. If either planet name is invalid, return an empty list.\n        // 4. Determine lower and upper indices between the two planets.\n        // 5. Loop through indices strictly between lower and upper, adding planets to the result.\n        // 6. Return the result list.\n\n        List<String> ordered = Arrays.asList(\n            \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n        );\n\n        Map<String, Integer> index = new HashMap<>();\n        for (int i = 0; i < ordered.size(); i++) {\n            index.put(ordered.get(i), i);\n        }\n\n        if (!index.containsKey(planet1) || !index.containsKey(planet2)) {\n            return new ArrayList<>();\n        }\n\n        int i1 = index.get(planet1);\n        int i2 = index.get(planet2);\n        int lo = Math.min(i1, i2);\n        int hi = Math.max(i1, i2);\n\n        List<String> result = new ArrayList<>();\n        for (int i = lo + 1; i < hi; i++) {\n            result.add(ordered.get(i));\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> bf(String planet1, String planet2) {\n        List<String> orderedPlanets = Arrays.asList(\n            \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n        );\n\n        Map<String, Integer> planetIndexMap = createPlanetIndexMap(orderedPlanets);\n\n        if (!isValidPlanets(planet1, planet2, planetIndexMap)) {\n            return Collections.emptyList();\n        }\n\n        return getPlanetsBetween(planet1, planet2, planetIndexMap, orderedPlanets);\n    }\n\n    private Map<String, Integer> createPlanetIndexMap(List<String> orderedPlanets) {\n        Map<String, Integer> indexMap = new HashMap<>();\n        for (int i = 0; i < orderedPlanets.size(); i++) {\n            indexMap.put(orderedPlanets.get(i), i);\n        }\n        return indexMap;\n    }\n\n    private boolean isValidPlanets(String planet1, String planet2, Map<String, Integer> planetIndexMap) {\n        return planetIndexMap.containsKey(planet1) && planetIndexMap.containsKey(planet2);\n    }\n\n    private List<String> getPlanetsBetween(String planet1, String planet2, Map<String, Integer> planetIndexMap, List<String> orderedPlanets) {\n        int index1 = planetIndexMap.get(planet1);\n        int index2 = planetIndexMap.get(planet2);\n        int lowerIndex = Math.min(index1, index2);\n        int upperIndex = Math.max(index1, index2);\n\n        List<String> result = new ArrayList<>();\n        for (int i = lowerIndex + 1; i < upperIndex; i++) {\n            result.add(orderedPlanets.get(i));\n        }\n\n        return result;\n    }\n}","nanoTime":"7163798700"}
{"taskId":"Java/149","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.listSort(new ArrayList<>(Arrays.asList(\"aa\", \"a\", \"aaa\"))).equals(List.of(\"aa\")),\n                s.listSort(new ArrayList<>(Arrays.asList(\"school\", \"AI\", \"asdf\", \"b\"))).equals(Arrays.asList(\"AI\", \"asdf\", \"school\")),\n                s.listSort(new ArrayList<>(Arrays.asList(\"d\", \"b\", \"c\", \"a\"))).equals(List.of()),\n                s.listSort(new ArrayList<>(Arrays.asList(\"d\", \"dcba\", \"abcd\", \"a\"))).equals(Arrays.asList(\"abcd\", \"dcba\")),\n                s.listSort(new ArrayList<>(Arrays.asList(\"AI\", \"ai\", \"au\"))).equals(Arrays.asList(\"AI\", \"ai\", \"au\")),\n                s.listSort(new ArrayList<>(Arrays.asList(\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"))).equals(List.of()),\n                s.listSort(new ArrayList<>(Arrays.asList(\"aaaa\", \"bbbb\", \"dd\", \"cc\"))).equals(Arrays.asList(\"cc\", \"dd\", \"aaaa\", \"bbbb\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert listSort(Arrays.asList(\"aa\", \"a\", \"aaa\")) => [\"aa\"]\n    assert listSort(Arrays.asList(\"ab\", \"a\", \"aaa\", \"cd\")) => [\"ab\", \"cd\"]\n     */\n    public List<String> listSort(List<String> lst) {\n        // Let's think step by step\n        // Input: lst, a list of strings\n        // Output: a list containing only even-length strings, sorted by length ascending then alphabetically\n        // 1. Sequential: Initialize a result list 'evens' to collect valid strings.\n        // 2. Loop: Iterate over each string 's' in the input list.\n        // 3. Branch: If 's' has even length, add it to 'evens'.\n        // 4. Sequential: Sort 'evens' by length ascending; if equal length, sort alphabetically.\n        // 5. Sequential: Return 'evens'.\n\n        if (lst == null) {\n            return new ArrayList<>();\n        }\n\n        List<String> evens = new ArrayList<>();\n        for (String s : lst) {\n            if (s != null && s.length() % 2 == 0) {\n                evens.add(s);\n            }\n        }\n\n        Collections.sort(evens, new Comparator<String>() {\n            @Override\n            public int compare(String a, String b) {\n                int la = a.length();\n                int lb = b.length();\n                if (la != lb) {\n                    return Integer.compare(la, lb);\n                }\n                return a.compareTo(b);\n            }\n        });\n\n        return evens;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> listSort(List<String> lst) {\n        if (lst == null) {\n            return Collections.emptyList();\n        }\n\n        List<String> evens = new ArrayList<>();\n        for (String s : lst) {\n            if (s != null && s.length() % 2 == 0) {\n                evens.add(s);\n            }\n        }\n\n        evens.sort(Comparator.comparingInt(String::length).thenComparing(String::compareTo));\n        return evens;\n    }\n}","nanoTime":"2620008500"}
{"taskId":"Java/150","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.xOrY(7, 34, 12) == 34,\n                s.xOrY(15, 8, 5) == 5,\n                s.xOrY(3, 33, 5212) == 33,\n                s.xOrY(1259, 3, 52) == 3,\n                s.xOrY(7919, -1, 12) == -1,\n                s.xOrY(3609, 1245, 583) == 583,\n                s.xOrY(91, 56, 129) == 129,\n                s.xOrY(6, 34, 1234) == 1234,\n                s.xOrY(1, 2, 0) == 0,\n                s.xOrY(2, 2, 0) == 2\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for xOrY(7, 34, 12) == 34\n    for xOrY(15, 8, 5) == 5\n     */\n    public int xOrY(int n, int x, int y) {\n        // Let's think step by step\n        // Input: n, x, y (integers)\n        // Output: return x if n is prime; otherwise return y\n        // 1) Sequential: plan to handle trivial cases and set up checks.\n        // 2) Branch: check base conditions (n <= 1 not prime, n == 2 prime, even numbers not prime).\n        // 3) Loop: check odd divisors from 3 up to sqrt(n); if any divides n, it's not prime.\n        // 4) Branch: if any divisor found -> return y; else -> return x.\n\n        // Branch: handle non-prime small values\n        if (n <= 1) return y;\n        // Branch: 2 is prime\n        if (n == 2) return x;\n        // Branch: even numbers greater than 2 are not prime\n        if (n % 2 == 0) return y;\n\n        // Loop: check for factors among odd numbers up to sqrt(n)\n        for (int d = 3; d <= n / d; d += 2) {\n            if (n % d == 0) {\n                return y; // Branch: found a divisor, not prime\n            }\n        }\n\n        // If no divisors found, n is prime\n        return x;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for xOrY(7, 34, 12) == 34\n    for xOrY(15, 8, 5) == 5\n     */\n    public int xOrY(int n, int x, int y) {\n        if (n <= 1) return y;\n        if (n == 2) return x;\n        if (n % 2 == 0) return y;\n\n        for (int d = 3; d * d <= n; d += 2) {\n            if (n % d == 0) {\n                return y;\n            }\n        }\n\n        return x;\n    }\n}","nanoTime":"3044538000"}
{"taskId":"Java/151","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.doubleTheDifference(List.of()) == 0,\n                s.doubleTheDifference(Arrays.asList(5, 4)) == 25,\n                s.doubleTheDifference(Arrays.asList(0.1, 0.2, 0.3)) == 0,\n                s.doubleTheDifference(Arrays.asList(-10, -20, -30)) == 0,\n                s.doubleTheDifference(Arrays.asList(-1, -2, 8)) == 0,\n                s.doubleTheDifference(Arrays.asList(0.2, 3, 5)) == 34\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n        List<Object> lst = new ArrayList<>();\n        for (int i = -99; i < 100; i += 2) {\n            lst.add(i);\n        }\n        int odd_sum = lst.stream().filter(i -> i instanceof Integer p && p % 2 != 0 && p > 0).map(i -> (Integer) i * (Integer) i).reduce(Integer::sum).orElse(0);\n        assert s.doubleTheDifference(lst) == odd_sum;\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    doubleTheDifference(Arrays.asList(1, 3, 2, 0)) == 1 + 9 + 0 + 0 = 10\n    doubleTheDifference(Arrays.asList(-1, -2, 0)) == 0\n    doubleTheDifference(Arrays.asList(9, -2)) == 81\n    doubleTheDifference(Arrays.asList(0)) == 0\n\n    If the input list is empty, return 0.\n     */\n    public int doubleTheDifference(List<Object> lst) {\n        // Let's think step by step\n        // Input: lst, a list of objects\n        // Output: sum, an integer\n        // Sequential structure:\n        // 1. If lst is null or empty, return 0.\n        // 2. Initialize a variable \"sum\" to 0 (use long to avoid intermediate overflow).\n        // Loop structure:\n        // 3. For each element \"o\" in lst:\n        // Branch structure:\n        //    a) If \"o\" is an integral type (Byte, Short, Integer, Long):\n        //       i) Convert it to a long value \"v\".\n        //      ii) If v >= 0 and v is odd, add v*v to sum.\n        //    b) Else: ignore the element.\n        // 4. Return sum as int.\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n        long sum = 0L;\n        for (Object o : lst) {\n            if (o instanceof Integer || o instanceof Long || o instanceof Short || o instanceof Byte) {\n                long v;\n                if (o instanceof Integer) {\n                    v = ((Integer) o).longValue();\n                } else if (o instanceof Long) {\n                    v = ((Long) o).longValue();\n                } else if (o instanceof Short) {\n                    v = ((Short) o).longValue();\n                } else {\n                    v = ((Byte) o).longValue();\n                }\n                if (v >= 0 && (v & 1L) == 1L) {\n                    sum += v * v;\n                }\n            }\n        }\n        return (int) sum;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int doubleTheDifference(List<Object> lst) {\n        if (lst == null || lst.isEmpty()) {\n            return 0;\n        }\n        \n        long sum = 0L;\n        for (Object o : lst) {\n            if (o instanceof Number) {\n                long v = ((Number) o).longValue();\n                if (v >= 0 && (v % 2 != 0)) {\n                    sum += v * v;\n                }\n            }\n        }\n        return (int) sum;\n    }\n}","nanoTime":"2890825500"}
{"taskId":"Java/152","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2)).equals(Arrays.asList(0, 0, 0, 0, 3, 3)),\n                s.compare(Arrays.asList(0,5,0,0,0,4), Arrays.asList(4,1,1,0,0,-2)).equals(Arrays.asList(4,4,1,0,0,6)),\n                s.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2)).equals(Arrays.asList(0, 0, 0, 0, 3, 3)),\n                s.compare(Arrays.asList(0, 0, 0, 0, 0, 0), Arrays.asList(0, 0, 0, 0, 0, 0)).equals(Arrays.asList(0, 0, 0, 0, 0, 0)),\n                s.compare(Arrays.asList(1, 2, 3), Arrays.asList(-1, -2, -3)).equals(Arrays.asList(2, 4, 6)),\n                s.compare(Arrays.asList(1, 2, 3, 5), Arrays.asList(-1, 2, 3, 4)).equals(Arrays.asList(2, 0, 0, 1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match.\n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    example:\n\n    compare(Arrays.asList(1,2,3,4,5,1),Arrays.asList(1,2,3,4,2,-2)) -> [0,0,0,0,3,3]\n    compare(Arrays.asList(0,5,0,0,0,4),Arrays.asList(4,1,1,0,0,-2)) -> [4,4,1,0,0,6]\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        // Let's think step by step\n        // Input: game, guess - two lists of integers of equal length\n        // Output: a list of integers where each element is how far off the guess was\n        // Sequential structure:\n        // 1. Initialize a result list to store differences.\n        // 2. Determine the number of matches n = game.size().\n        // Loop structure:\n        // 3. For each index i from 0 to n-1:\n        //    a. Compute diff = absolute value of (game[i] - guess[i]).\n        // Branch structure:\n        //    b. If diff == 0, add 0 to result (correct guess), else add diff to result.\n        // 4. Return the result list.\n\n        List<Integer> result = new ArrayList<>(game.size());\n        int n = game.size();\n        for (int i = 0; i < n; i++) {\n            int diff = Math.abs(game.get(i) - guess.get(i));\n            if (diff == 0) {\n                result.add(0);\n            } else {\n                result.add(diff);\n            }\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>(game.size());\n        for (int i = 0; i < game.size(); i++) {\n            result.add(Math.abs(game.get(i) - guess.get(i)));\n        }\n        return result;\n    }\n}","nanoTime":"1698652400"}
{"taskId":"Java/153","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.StrongestExtension(\"Watashi\", Arrays.asList(\"tEN\", \"niNE\", \"eIGHt8OKe\")), \"Watashi.eIGHt8OKe\"),\n                Objects.equals(s.StrongestExtension(\"Boku123\", Arrays.asList(\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\")), \"Boku123.YEs.WeCaNe\"),\n                Objects.equals(s.StrongestExtension(\"__YESIMHERE\", Arrays.asList(\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\")), \"__YESIMHERE.NuLl__\"),\n                Objects.equals(s.StrongestExtension(\"K\", Arrays.asList(\"Ta\", \"TAR\", \"t234An\", \"cosSo\")), \"K.TAR\"),\n                Objects.equals(s.StrongestExtension(\"__HAHA\", Arrays.asList(\"Tab\", \"123\", \"781345\", \"-_-\")), \"__HAHA.123\"),\n                Objects.equals(s.StrongestExtension(\"YameRore\", Arrays.asList(\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\")), \"YameRore.okIWILL123\"),\n                Objects.equals(s.StrongestExtension(\"finNNalLLly\", Arrays.asList(\"Die\", \"NowW\", \"Wow\", \"WoW\")), \"finNNalLLly.WoW\"),\n                Objects.equals(s.StrongestExtension(\"_\", Arrays.asList(\"Bb\", \"91245\")), \"_.Bb\"),\n                Objects.equals(s.StrongestExtension(\"Sp\", Arrays.asList(\"671235\", \"Bb\")), \"Sp.671235\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters\n    in the extension's name, the strength is given by the fraction CAP - SM.\n    You should find the strongest extension and return a string in this\n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"] then you should\n    return \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension\n    (its strength is -1).\n    Example:\n    for StrongestExtension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n     */\n    public String StrongestExtension(String class_name, List<String> extensions) {\n        // Let's think step by step\n        // Input: class_name (String), extensions (List<String>)\n        // Output: String formatted as \"ClassName.StrongestExtensionName\"\n        // Sequential structure:\n        // 1) Initialize tracking variables: maxStrength to the lowest integer and bestExt to empty string.\n        // Loop structure:\n        // 2) For each extension in the list:\n        //    - Count uppercase (CAP) and lowercase (SM) letters by looping over characters.\n        // Branch structure:\n        //    - If a character is uppercase, increment CAP; else if lowercase, increment SM.\n        //    - Compute strength = CAP - SM and update bestExt if strength is greater than current maxStrength.\n        // Final step:\n        // 3) Return class_name + \".\" + bestExt. If the list is null/empty, return class_name + \".\".\n        // Write your code here\n        if (extensions == null || extensions.isEmpty()) {\n            return class_name + \".\";\n        }\n\n        int maxStrength = Integer.MIN_VALUE;\n        String bestExt = extensions.get(0); // default to first for safety; will be updated if stronger found\n\n        for (int idx = 0; idx < extensions.size(); idx++) {\n            String ext = extensions.get(idx);\n            int cap = 0;\n            int sm = 0;\n\n            for (int i = 0; i < ext.length(); i++) {\n                char c = ext.charAt(i);\n                if (Character.isUpperCase(c)) {\n                    cap++;\n                } else if (Character.isLowerCase(c)) {\n                    sm++;\n                }\n                // Non-letter characters are ignored\n            }\n\n            int strength = cap - sm;\n\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                bestExt = ext; // update to current extension\n            }\n            // In case of tie (strength == maxStrength), we keep the first occurrence by doing nothing\n        }\n\n        return class_name + \".\" + bestExt;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String StrongestExtension(String className, List<String> extensions) {\n        if (extensions == null || extensions.isEmpty()) {\n            return className + \".\";\n        }\n\n        String bestExtension = extensions.get(0);\n        int maxStrength = calculateStrength(bestExtension);\n\n        for (int idx = 1; idx < extensions.size(); idx++) {\n            String extension = extensions.get(idx);\n            int strength = calculateStrength(extension);\n\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                bestExtension = extension;\n            }\n        }\n\n        return className + \".\" + bestExtension;\n    }\n\n    private int calculateStrength(String extension) {\n        int capCount = 0;\n        int smCount = 0;\n\n        for (char c : extension.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                capCount++;\n            } else if (Character.isLowerCase(c)) {\n                smCount++;\n            }\n        }\n\n        return capCount - smCount;\n    }\n}","nanoTime":"2720140600"}
{"taskId":"Java/154","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.cycpatternCheck(\"xyzw\", \"xyw\") == false,\n                s.cycpatternCheck(\"yello\", \"ell\") == true,\n                s.cycpatternCheck(\"whattup\", \"ptut\") == false,\n                s.cycpatternCheck(\"efef\", \"fee\") == true,\n                s.cycpatternCheck(\"abab\", \"aabb\") == false,\n                s.cycpatternCheck(\"winemtt\", \"tinem\") == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpatternCheck(\"abcd\",\"abd\") => false\n    cycpatternCheck(\"hello\",\"ell\") => true\n    cycpatternCheck(\"whassup\",\"psus\") => false\n    cycpatternCheck(\"abab\",\"baa\") => true\n    cycpatternCheck(\"efef\",\"eeff\") => false\n    cycpatternCheck(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpatternCheck(String a, String b) {\n        // Let's think step by step\n        // Input: a, b - strings\n        // Output: boolean indicating if b or any rotation of b is a substring of a\n        // Sequential steps:\n        // 1. Handle null and trivial cases.\n        // 2. If b is empty, return true (empty string is a substring of any string).\n        // 3. If b is longer than a, it cannot be a substring; return false.\n        // Loop structure:\n        // 4. For each rotation index i from 0 to b.length()-1:\n        //    - Construct the rotation: rot = b.substring(i) + b.substring(0, i)\n        // Branch structure:\n        //    - If a contains rot, return true immediately.\n        // 5. After checking all rotations, return false.\n\n        if (a == null || b == null) return false;\n        int n = a.length();\n        int m = b.length();\n        if (m == 0) return true;\n        if (m > n) return false;\n\n        for (int i = 0; i < m; i++) {\n            String rot = b.substring(i) + b.substring(0, i);\n            if (a.contains(rot)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpatternCheck(String a, String b) {\n        if (a == null || b == null || b.length() > a.length()) return false;\n        if (b.isEmpty()) return true;\n\n        String doubledB = b + b;\n        return doubledB.contains(a);\n    }\n}","nanoTime":"1181680200"}
{"taskId":"Java/155","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.evenOddCount(7).equals(Arrays.asList(0, 1)),\n                s.evenOddCount(-78).equals(Arrays.asList(1, 1)),\n                s.evenOddCount(3452).equals(Arrays.asList(2, 2)),\n                s.evenOddCount(346211).equals(Arrays.asList(3, 3)),\n                s.evenOddCount(-345821).equals(Arrays.asList(3, 3)),\n                s.evenOddCount(-2).equals(Arrays.asList(1, 0)),\n                s.evenOddCount(-45347).equals(Arrays.asList(2, 3)),\n                s.evenOddCount(0).equals(Arrays.asList(1, 0))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer. return a tuple that has the number of even and odd digits respectively.\n    \n     Example:\n        evenOddCount(-12) ==> (1, 1)\n        evenOddCount(123) ==> (1, 2)\n     */\n    public List<Integer> evenOddCount(int num) {\n        // Let's think step by step\n        // Input: num, an integer\n        // Output: List<Integer> with two elements [evenCount, oddCount]\n        //\n        // Sequential structure:\n        // 1. If num is 0, it has one digit '0' which is even -> return [1, 0].\n        // 2. Convert num to a non-negative long safely (handle Integer.MIN_VALUE) and initialize counters.\n        //\n        // Loop structure:\n        // 3. While the number n > 0:\n        //    a. Extract the last digit.\n        //    b. Branch: If digit is even, increment even count; else increment odd count.\n        //    c. Remove the last digit from n.\n        //\n        // Branch structure:\n        // 4. Return the result list [evenCount, oddCount].\n\n        // Step 1: Special case for zero\n        if (num == 0) {\n            return Arrays.asList(1, 0);\n        }\n\n        // Step 2: Safe absolute value using long to handle Integer.MIN_VALUE\n        long n = Math.abs((long) num);\n        int even = 0;\n        int odd = 0;\n\n        // Step 3: Process each digit\n        while (n > 0) {\n            int digit = (int) (n % 10);\n            if (digit % 2 == 0) { // Branch: check parity\n                even++;\n            } else {\n                odd++;\n            }\n            n /= 10; // Move to next digit\n        }\n\n        // Step 4: Return results\n        return Arrays.asList(even, odd);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an integer. return a tuple that has the number of even and odd digits respectively.\n    \n     Example:\n        evenOddCount(-12) ==> (1, 1)\n        evenOddCount(123) ==> (1, 2)\n     */\n    public List<Integer> evenOddCount(int num) {\n        if (num == 0) {\n            return Arrays.asList(1, 0);\n        }\n\n        long n = Math.abs((long) num);\n        int evenCount = 0;\n        int oddCount = 0;\n\n        while (n > 0) {\n            int digit = (int) (n % 10);\n            if (digit % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n            n /= 10;\n        }\n\n        return Arrays.asList(evenCount, oddCount);\n    }\n}","nanoTime":"2871550900"}
{"taskId":"Java/156","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.intToMiniRoman(19), \"xix\"),\n                Objects.equals(s.intToMiniRoman(152), \"clii\"),\n                Objects.equals(s.intToMiniRoman(251), \"ccli\"),\n                Objects.equals(s.intToMiniRoman(426), \"cdxxvi\"),\n                Objects.equals(s.intToMiniRoman(500), \"d\"),\n                Objects.equals(s.intToMiniRoman(1), \"i\"),\n                Objects.equals(s.intToMiniRoman(4), \"iv\"),\n                Objects.equals(s.intToMiniRoman(43), \"xliii\"),\n                Objects.equals(s.intToMiniRoman(90), \"xc\"),\n                Objects.equals(s.intToMiniRoman(94), \"xciv\"),\n                Objects.equals(s.intToMiniRoman(532), \"dxxxii\"),\n                Objects.equals(s.intToMiniRoman(900), \"cm\"),\n                Objects.equals(s.intToMiniRoman(994), \"cmxciv\"),\n                Objects.equals(s.intToMiniRoman(1000), \"m\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> intToMiniRoman(19) == \"xix\"\n    >>> intToMiniRoman(152) == \"clii\"\n    >>> intToMiniRoman(426) == \"cdxxvi\"\n     */\n    public String intToMiniRoman(int number) {\n        // Let's think step by step\n        // Input: number, a positive integer between 1 and 1000 inclusive\n        // Output: miniRoman, a lowercase roman numeral string\n        // 1. Initialize two arrays: \"values\" and \"symbols\" that map integer values to roman numerals (sequential).\n        // 2. If the input is out of the specified range, handle it (branch).\n        // 3. Loop through the mapping arrays; for each value, while the current number is >= value,\n        //    append the corresponding symbol to the result and subtract the value (loop).\n        // 4. Return the accumulated result string (sequential).\n        int[] values = new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = new String[] {\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n\n        if (number < 1 || number > 1000) {\n            // Out of range per restrictions; return empty or handle accordingly.\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < values.length; i++) {\n            while (number >= values[i]) {\n                sb.append(symbols[i]);\n                number -= values[i];\n            }\n        }\n        return sb.toString();\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intToMiniRoman(int number) {\n        if (number < 1 || number > 1000) {\n            return \"\";\n        }\n\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < values.length; i++) {\n            while (number >= values[i]) {\n                sb.append(symbols[i]);\n                number -= values[i];\n            }\n        }\n        return sb.toString();\n    }\n}","nanoTime":"2451618100"}
{"taskId":"Java/157","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rightAngleTriangle(3, 4, 5) == true,\n                s.rightAngleTriangle(1, 2, 3) == false,\n                s.rightAngleTriangle(10, 6, 8) == true,\n                s.rightAngleTriangle(2, 2, 2) == false,\n                s.rightAngleTriangle(7, 24, 25) == true,\n                s.rightAngleTriangle(10, 5, 7) == false,\n                s.rightAngleTriangle(5, 12, 13) == true,\n                s.rightAngleTriangle(15, 8, 17) == true,\n                s.rightAngleTriangle(48, 55, 73) == true,\n                s.rightAngleTriangle(1, 1, 1) == false,\n                s.rightAngleTriangle(2, 2, 10) == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given the lengths of the three sides of a triangle. Return true if the three\n    sides form a right-angled triangle, false otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or\n    90 degree.\n    Example:\n    rightAngleTriangle(3, 4, 5) == true\n    rightAngleTriangle(1, 2, 3) == false\n     */\n    public boolean rightAngleTriangle(int a, int b, int c) {\n        // Let's think step by step\n        // Input: a, b, c - integers representing side lengths\n        // Output: boolean - true if they form a right-angled triangle, else false\n        // Sequential structure:\n        // 1. Check that all sides are positive.\n        // 2. Identify the largest side (candidate hypotenuse).\n        // 3. Check triangle inequality.\n        // 4. Compare sum of squares of the two smaller sides with the square of the largest.\n        // Branch structure:\n        // - If any side is non-positive, return false.\n        // - If triangle inequality fails, return false.\n        // - Finally, return the result of the Pythagorean check.\n        // Loop structure:\n        // - Iterate over the sides to find the largest side.\n\n        // 1) Sequential + Branch: validate positive sides\n        if (a <= 0 || b <= 0 || c <= 0) {\n            return false;\n        }\n\n        // Prepare sides\n        int[] sides = {a, b, c};\n\n        // 2) Loop: find index of the largest side (hypotenuse candidate)\n        int maxIdx = 0;\n        for (int i = 1; i < 3; i++) {\n            if (sides[i] > sides[maxIdx]) {\n                maxIdx = i;\n            }\n        }\n\n        int hyp = sides[maxIdx];\n        int leg1 = sides[(maxIdx + 1) % 3];\n        int leg2 = sides[(maxIdx + 2) % 3];\n\n        // Use long to avoid overflow when squaring\n        long H = hyp;\n        long L1 = leg1;\n        long L2 = leg2;\n\n        // 3) Branch: triangle inequality (since hyp is largest, only need L1 + L2 > H)\n        if (L1 + L2 <= H) {\n            return false;\n        }\n\n        // 4) Sequential: Pythagorean theorem check\n        return (L1 * L1 + L2 * L2) == (H * H);\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean rightAngleTriangle(int a, int b, int c) {\n        if (a <= 0 || b <= 0 || c <= 0) {\n            return false;\n        }\n\n        int[] sides = {a, b, c};\n        Arrays.sort(sides);\n\n        long hyp = sides[2];\n        long leg1 = sides[0];\n        long leg2 = sides[1];\n\n        return (leg1 + leg2 > hyp) && (leg1 * leg1 + leg2 * leg2 == hyp * hyp);\n    }\n}","nanoTime":"2241562600"}
{"taskId":"Java/158","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.findMax(new ArrayList<>(Arrays.asList(\"name\", \"of\", \"string\"))).equals(\"string\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"name\", \"enam\", \"game\"))).equals(\"enam\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"aaaaaaa\", \"bb\", \"cc\"))).equals(\"aaaaaaa\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"abc\", \"cba\"))).equals(\"abc\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"play\", \"this\", \"game\", \"of\", \"footbott\"))).equals(\"footbott\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"we\", \"are\", \"gonna\", \"rock\"))).equals(\"gonna\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"we\", \"are\", \"a\", \"mad\", \"nation\"))).equals(\"nation\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"this\", \"is\", \"a\", \"prrk\"))).equals(\"this\"),\n                s.findMax(new ArrayList<>(List.of(\"b\"))).equals(\"b\"),\n                s.findMax(new ArrayList<>(Arrays.asList(\"play\", \"play\", \"play\"))).equals(\"play\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    findMax([\"name\", \"of\", \"string\"]) == \"string\"\n    findMax([\"name\", \"enam\", \"game\"]) == \"enam\"\n    findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n     */\n    public String findMax(List<String> words) {\n        // Let's think step by step\n        // Input: words, a list of strings\n        // Output: the word with the maximum number of unique characters; ties -> lexicographically smallest\n        // Sequential structure:\n        // 1. If the input list is null or empty, return an empty string.\n        // 2. Initialize bestWord as empty string and bestCount as -1.\n        // Loop structure:\n        // 3. For each word in the list:\n        //    a. Compute the number of unique characters using a set.\n        // Branch structure:\n        //    b. If the count is greater than bestCount, update bestWord and bestCount.\n        //       Else if the count equals bestCount and the word is lexicographically smaller than bestWord, update bestWord.\n        // 4. Return bestWord.\n\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        String bestWord = \"\";\n        int bestCount = -1;\n\n        for (String word : words) {\n            if (word == null) {\n                word = \"\";\n            }\n\n            Set<Character> unique = new HashSet<>();\n            for (int i = 0; i < word.length(); i++) {\n                unique.add(word.charAt(i));\n            }\n            int count = unique.size();\n\n            if (count > bestCount) {\n                bestCount = count;\n                bestWord = word;\n            } else if (count == bestCount && word.compareTo(bestWord) < 0) {\n                bestWord = word;\n            }\n        }\n\n        return bestWord;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String findMax(List<String> words) {\n        if (words == null || words.isEmpty()) {\n            return \"\";\n        }\n\n        String bestWord = \"\";\n        int bestCount = -1;\n\n        for (String word : words) {\n            if (word == null) {\n                continue;\n            }\n\n            int count = (int) word.chars().distinct().count();\n\n            if (count > bestCount || (count == bestCount && word.compareTo(bestWord) < 0)) {\n                bestCount = count;\n                bestWord = word;\n            }\n        }\n\n        return bestWord;\n    }\n}","nanoTime":"1836953300"}
{"taskId":"Java/159","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.eat(5, 6, 10).equals(Arrays.asList(11, 4)),\n                s.eat(4, 8, 9).equals(Arrays.asList(12, 1)),\n                s.eat(1, 10, 10).equals(Arrays.asList(11, 0)),\n                s.eat(2, 11, 5).equals(Arrays.asList(7, 0)),\n                s.eat(4, 5, 7).equals(Arrays.asList(9, 2)),\n                s.eat(4, 5, 1).equals(Arrays.asList(5, 0))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n\n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n\n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n     */\n    public List<Integer> eat(int number, int need, int remaining) {\n        // Let's think step by step\n        // Input: number, need, remaining (integers)\n        // Output: List<Integer> with two elements: [total after meals, carrots left]\n        // Sequential structure:\n        // 1. Decide how many carrots to eat now (eatNow).\n        // 2. Compute total = number + eatNow.\n        // 3. Compute left = remaining - eatNow.\n        // Branch structure:\n        // - If remaining < need, set eatNow = remaining (eat everything left).\n        // - Else, set eatNow = need (eat exactly what is needed).\n        // Loop structure:\n        // - Build the result list by iterating over an array of {total, left} and adding them to a List.\n\n        int eatNow;\n        if (remaining < need) {\n            eatNow = remaining;\n        } else {\n            eatNow = need;\n        }\n\n        int total = number + eatNow;\n        int left = remaining - eatNow;\n\n        List<Integer> result = new ArrayList<>(2);\n        int[] vals = new int[] { total, left };\n        for (int v : vals) {\n            result.add(v);\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> eat(int number, int need, int remaining) {\n        int eatNow = Math.min(remaining, need);\n        int total = number + eatNow;\n        int left = remaining - eatNow;\n\n        return new ArrayList<>(List.of(total, left));\n    }\n}","nanoTime":"1250935200"}
{"taskId":"Java/160","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"**\", \"*\", \"+\")), new ArrayList<>(Arrays.asList(2, 3, 4, 5))) == 37,\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"+\", \"*\", \"-\")), new ArrayList<>(Arrays.asList(2, 3, 4, 5))) == 9,\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"/\", \"*\")), new ArrayList<>(Arrays.asList(7, 3, 4))) == 8,\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"+\", \"**\", \"**\")), new ArrayList<>(Arrays.asList(7, 5, 3, 2))) == 1953132\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two lists operator, and operand. The first list has basic algebra operations, and\n    the second list is a list of integers. Use the two given lists to build the algebric\n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + )\n    Subtraction ( - )\n    Multiplication ( * )\n    Floor division ( / )\n    Exponentiation ( ** )\n\n    Example:\n    operator[\"+\", \"*\", \"-\"]\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n     */\n    public int doAlgebra(List<String> operator, List<Integer> operand) {\n        // Let's think step by step\n        // Input: operator (list of symbols), operand (list of integers)\n        // Output: integer result of the formed infix expression with standard precedence\n        //\n        // Sequential structure:\n        // 1) Define operator precedence and associativity.\n        // 2) Initialize two stacks: one for values, one for operators.\n        // 3) Push the first operand to the value stack.\n        //\n        // Loop structure:\n        // 4) For each operator in order:\n        //    - While the operator stack top has higher precedence (or same precedence and current is left-associative),\n        //      pop it and apply to the top two values.\n        //    - Push the current operator.\n        //    - Push the next operand.\n        //\n        // Branch structure:\n        // 5) During application, branch by operator symbol to perform +, -, *, floor /, or **.\n        //\n        // 6) After the loop, apply any remaining operators.\n        // 7) Return the final value as int.\n\n        Deque<Long> values = new ArrayDeque<>();\n        Deque<String> ops = new ArrayDeque<>();\n\n        // Push first operand\n        values.push(operand.get(0).longValue());\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n\n            // While there is an operator at the top with higher precedence,\n            // or same precedence and current operator is left-associative, apply it.\n            while (!ops.isEmpty() && shouldPopBefore(ops.peek(), op)) {\n                applyTopOperator(values, ops.pop());\n            }\n\n            // Push current operator\n            ops.push(op);\n\n            // Push next operand\n            values.push(operand.get(i + 1).longValue());\n        }\n\n        // Apply remaining operators\n        while (!ops.isEmpty()) {\n            applyTopOperator(values, ops.pop());\n        }\n\n        long result = values.pop();\n        return (int) result;\n    }\n\n    private static boolean shouldPopBefore(String top, String curr) {\n        int pt = precedence(top);\n        int pc = precedence(curr);\n        if (pt > pc) return true;\n        if (pt < pc) return false;\n        // Equal precedence: pop if current is left-associative\n        return !isRightAssociative(curr);\n    }\n\n    private static int precedence(String op) {\n        switch (op) {\n            case \"**\": return 3;\n            case \"*\":\n            case \"/\":  return 2;\n            case \"+\":\n            case \"-\":  return 1;\n            default:   return -1;\n        }\n    }\n\n    private static boolean isRightAssociative(String op) {\n        return \"**\".equals(op);\n    }\n\n    private static void applyTopOperator(Deque<Long> values, String op) {\n        long b = values.pop();\n        long a = values.pop();\n        long res;\n        switch (op) {\n            case \"+\": res = a + b; break;\n            case \"-\": res = a - b; break;\n            case \"*\": res = a * b; break;\n            case \"/\": res = Math.floorDiv(a, b); break; // floor division\n            case \"**\": res = pow(a, b); break;\n            default: throw new IllegalArgumentException(\"Unknown operator: \" + op);\n        }\n        values.push(res);\n    }\n\n    private static long pow(long base, long exp) {\n        // Fast exponentiation, treating 0**0 as 1 (common programming convention)\n        if (exp < 0) {\n            // Not expected per problem constraints (operands are non-negative)\n            throw new IllegalArgumentException(\"Negative exponent not supported\");\n        }\n        long result = 1L;\n        long b = base;\n        long e = exp;\n        while (e > 0) {\n            if ((e & 1L) == 1L) {\n                result = result * b;\n            }\n            b = b * b;\n            e >>= 1;\n        }\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int doAlgebra(List<String> operator, List<Integer> operand) {\n        Deque<Long> values = new ArrayDeque<>();\n        Deque<String> ops = new ArrayDeque<>();\n\n        values.push(operand.get(0).longValue());\n\n        for (int i = 0; i < operator.size(); i++) {\n            String op = operator.get(i);\n\n            while (!ops.isEmpty() && shouldPopBefore(ops.peek(), op)) {\n                applyTopOperator(values, ops.pop());\n            }\n\n            ops.push(op);\n            values.push(operand.get(i + 1).longValue());\n        }\n\n        while (!ops.isEmpty()) {\n            applyTopOperator(values, ops.pop());\n        }\n\n        return values.pop().intValue();\n    }\n\n    private static boolean shouldPopBefore(String top, String curr) {\n        return precedence(top) > precedence(curr) || \n               (precedence(top) == precedence(curr) && !isRightAssociative(curr));\n    }\n\n    private static int precedence(String op) {\n        switch (op) {\n            case \"**\": return 3;\n            case \"*\":\n            case \"/\":  return 2;\n            case \"+\":\n            case \"-\":  return 1;\n            default:   return -1;\n        }\n    }\n\n    private static boolean isRightAssociative(String op) {\n        return \"**\".equals(op);\n    }\n\n    private static void applyTopOperator(Deque<Long> values, String op) {\n        long b = values.pop();\n        long a = values.pop();\n        long res = switch (op) {\n            case \"+\" -> a + b;\n            case \"-\" -> a - b;\n            case \"*\" -> a * b;\n            case \"/\" -> Math.floorDiv(a, b);\n            case \"**\" -> pow(a, b);\n            default -> throw new IllegalArgumentException(\"Unknown operator: \" + op);\n        };\n        values.push(res);\n    }\n\n    private static long pow(long base, long exp) {\n        if (exp < 0) {\n            throw new IllegalArgumentException(\"Negative exponent not supported\");\n        }\n        long result = 1L;\n        while (exp > 0) {\n            if ((exp & 1L) == 1L) {\n                result *= base;\n            }\n            base *= base;\n            exp >>= 1;\n        }\n        return result;\n    }\n}","nanoTime":"5171682800"}
{"taskId":"Java/161","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.solve(\"AsDf\"), \"aSdF\"),\n                Objects.equals(s.solve(\"1234\"), \"4321\"),\n                Objects.equals(s.solve(\"ab\"), \"AB\"),\n                Objects.equals(s.solve(\"#a@C\"), \"#A@c\"),\n                Objects.equals(s.solve(\"#AsdfW^45\"), \"#aSDFw^45\"),\n                Objects.equals(s.solve(\"#6@2\"), \"2@6#\"),\n                Objects.equals(s.solve(\"#$a^D\"), \"#$A^d\"),\n                Objects.equals(s.solve(\"#ccc\"), \"#CCC\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa,\n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n     */\n    public String solve(String s) {\n        // Let's think step by step\n        // Input: s, a string\n        // Output: result, a string after applying the rules\n        // Sequential structure:\n        // 1. Initialize a boolean flag hasLetter = false.\n        // Loop structure:\n        // 2. Loop over characters of s to check if any character is a letter; if found, set hasLetter = true and break.\n        // Branch structure:\n        // 3. If hasLetter is true:\n        // 4.    Loop over characters again:\n        // 5.       If the character is a letter, toggle its case and append to result.\n        // 6.       Else, append the character as is.\n        // 7. Else (no letters in s):\n        // 8.    Reverse the string.\n        // 9. Return the result.\n\n        boolean hasLetter = false;\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isLetter(s.charAt(i))) {\n                hasLetter = true;\n                break;\n            }\n        }\n\n        if (hasLetter) {\n            StringBuilder sb = new StringBuilder(s.length());\n            for (int i = 0; i < s.length(); i++) {\n                char ch = s.charAt(i);\n                if (Character.isLetter(ch)) {\n                    if (Character.isUpperCase(ch)) {\n                        sb.append(Character.toLowerCase(ch));\n                    } else {\n                        sb.append(Character.toUpperCase(ch));\n                    }\n                } else {\n                    sb.append(ch);\n                }\n            }\n            return sb.toString();\n        } else {\n            return new StringBuilder(s).reverse().toString();\n        }\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String solve(String s) {\n        if (s.chars().anyMatch(Character::isLetter)) {\n            return toggleCase(s);\n        } else {\n            return new StringBuilder(s).reverse().toString();\n        }\n    }\n\n    private String toggleCase(String s) {\n        StringBuilder sb = new StringBuilder(s.length());\n        for (char ch : s.toCharArray()) {\n            sb.append(Character.isLetter(ch) ? toggleCharCase(ch) : ch);\n        }\n        return sb.toString();\n    }\n\n    private char toggleCharCase(char ch) {\n        return Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch);\n    }\n}","nanoTime":"2395532700"}
{"taskId":"Java/162","test":"public class Main {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.stringToMd5(\"Hello world\").get().equals(\"3e25960a79dbc69b674cd4ec67a72c62\"),\n                s.stringToMd5(\"\").isEmpty(),\n                s.stringToMd5(\"A B C\").get().equals(\"0ef78513b0cb8cef12743f5aeb35f888\"),\n                s.stringToMd5(\"password\").get().equals(\"5f4dcc3b5aa765d61d8327deb882cf99\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.nio.charset.StandardCharsets;\n\nclass Solution {\n    /**\n    Given a string \"text\", return its md5 hash equivalent string with length being 32.\n    If \"text\" is an empty string, return Optional.empty().\n    \n    >>> stringToMd5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n     */\n    public Optional<String> stringToMd5(String text) throws NoSuchAlgorithmException {\n        // Let's think step by step\n        // Input: text, a String\n        // Output: Optional<String> containing a 32-character lowercase MD5 hex string,\n        //         or Optional.empty() if text is empty\n        // 1. Branch: If text is null or empty, return Optional.empty().\n        // 2. Sequential: Initialize MD5 MessageDigest.\n        // 3. Sequential: Compute the digest bytes of the input text using UTF-8.\n        // 4. Loop: Convert each byte to two-digit lowercase hexadecimal and build the hash string.\n        // 5. Sequential: Wrap the 32-character hex string in Optional and return.\n        if (text == null || text.isEmpty()) {\n            return Optional.empty();\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] digest = md.digest(text.getBytes(StandardCharsets.UTF_8));\n        StringBuilder hex = new StringBuilder(digest.length * 2);\n        for (byte b : digest) {\n            hex.append(String.format(\"%02x\", b & 0xff));\n        }\n        return Optional.of(hex.toString());\n    }\n}","improvedCode":"import java.math.BigInteger;\nimport java.security.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.nio.charset.StandardCharsets;\n\nclass Solution {\n    public Optional<String> stringToMd5(String text) throws NoSuchAlgorithmException {\n        if (text == null || text.isEmpty()) {\n            return Optional.empty();\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] digest = md.digest(text.getBytes(StandardCharsets.UTF_8));\n        return Optional.of(bytesToHex(digest));\n    }\n\n    private String bytesToHex(byte[] bytes) {\n        StringBuilder hex = new StringBuilder(bytes.length * 2);\n        for (byte b : bytes) {\n            hex.append(String.format(\"%02x\", b & 0xff));\n        }\n        return hex.toString();\n    }\n}","nanoTime":"4635925900"}
{"taskId":"Java/163","test":"public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.generateIntegers(2, 10).equals(Arrays.asList(2, 4, 6, 8)),\n                s.generateIntegers(10, 2).equals(Arrays.asList(2, 4, 6, 8)),\n                s.generateIntegers(132, 2).equals(Arrays.asList(2, 4, 6, 8)),\n                s.generateIntegers(17, 89).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}","generatedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generateIntegers(2, 8) => [2, 4, 6, 8]\n    generateIntegers(8, 2) => [2, 4, 6, 8]\n    generateIntegers(10, 14) => []\n     */\n    public List<Integer> generateIntegers(int a, int b) {\n        // Let's think step by step\n        // Input: a, b (positive integers)\n        // Output: list of even digits within [min(a,b), max(a,b)] in ascending order\n        // Sequential structure:\n        // 1) Normalize the interval: lo = min(a, b), hi = max(a, b). Prepare the result list.\n        // Branch structure:\n        // 2) If [lo, hi] has no intersection with the digit domain [0..9], return empty immediately.\n        // Loop structure:\n        // 3) Iterate over the even digits {0, 2, 4, 6, 8}; for each digit d, if lo <= d <= hi, add to result.\n        // 4) Return the result.\n\n        int lo = Math.min(a, b);\n        int hi = Math.max(a, b);\n        List<Integer> result = new ArrayList<>();\n\n        // If the range doesn't intersect with [0..9], there can be no even digits.\n        if (lo > 9 || hi < 0) {\n            return result;\n        }\n\n        int[] evenDigits = new int[] {0, 2, 4, 6, 8};\n        for (int d : evenDigits) {\n            if (d >= lo && d <= hi) {\n                result.add(d);\n            }\n        }\n\n        return result;\n    }\n}","improvedCode":"import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> generateIntegers(int a, int b) {\n        int lo = Math.max(0, Math.min(a, b));\n        int hi = Math.min(9, Math.max(a, b));\n        List<Integer> result = new ArrayList<>();\n\n        for (int d = 0; d <= hi; d += 2) {\n            if (d >= lo) {\n                result.add(d);\n            }\n        }\n\n        return result;\n    }\n}","nanoTime":"2012001200"}
